#include <wrap/matlab.h>
#include <map>

#include <boost/serialization/export.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>

#include <gtsam/base/Matrix.h>
#include <gtsam/base/Value.h>
#include <gtsam/base/deprecated/LieMatrix.h>
#include <gtsam/base/deprecated/LieScalar.h>
#include <gtsam/base/deprecated/LieVector.h>
#include <gtsam/geometry/Cal3Bundler.h>
#include <gtsam/geometry/Cal3DS2.h>
#include <gtsam/geometry/Cal3DS2_Base.h>
#include <gtsam/geometry/Cal3Unified.h>
#include <gtsam/geometry/Cal3_S2.h>
#include <gtsam/geometry/Cal3_S2Stereo.h>
#include <gtsam/geometry/CalibratedCamera.h>
#include <gtsam/geometry/EssentialMatrix.h>
#include <gtsam/geometry/PinholeCamera.h>
#include <gtsam/geometry/Point2.h>
#include <gtsam/geometry/Point3.h>
#include <gtsam/geometry/Pose2.h>
#include <gtsam/geometry/Pose3.h>
#include <gtsam/geometry/Rot2.h>
#include <gtsam/geometry/Rot3.h>
#include <gtsam/geometry/SimpleCamera.h>
#include <gtsam/geometry/StereoCamera.h>
#include <gtsam/geometry/StereoPoint2.h>
#include <gtsam/geometry/Unit3.h>
#include <gtsam/geometry/triangulation.h>
#include <gtsam/inference/Key.h>
#include <gtsam/inference/LabeledSymbol.h>
#include <gtsam/inference/Ordering.h>
#include <gtsam/inference/Symbol.h>
#include <gtsam/inference/VariableIndex.h>
#include <gtsam/linear/ConjugateGradientSolver.h>
#include <gtsam/linear/Errors.h>
#include <gtsam/linear/GaussianBayesNet.h>
#include <gtsam/linear/GaussianBayesTree.h>
#include <gtsam/linear/GaussianConditional.h>
#include <gtsam/linear/GaussianDensity.h>
#include <gtsam/linear/GaussianFactor.h>
#include <gtsam/linear/GaussianFactorGraph.h>
#include <gtsam/linear/GaussianISAM.h>
#include <gtsam/linear/HessianFactor.h>
#include <gtsam/linear/IterativeSolver.h>
#include <gtsam/linear/JacobianFactor.h>
#include <gtsam/linear/KalmanFilter.h>
#include <gtsam/linear/NoiseModel.h>
#include <gtsam/linear/Sampler.h>
#include <gtsam/linear/SubgraphSolver.h>
#include <gtsam/linear/VectorValues.h>
#include <gtsam/navigation/AHRSFactor.h>
#include <gtsam/navigation/AttitudeFactor.h>
#include <gtsam/navigation/CombinedImuFactor.h>
#include <gtsam/navigation/ImuBias.h>
#include <gtsam/navigation/ImuFactor.h>
#include <gtsam/navigation/NavState.h>
#include <gtsam/navigation/PreintegratedRotation.h>
#include <gtsam/navigation/PreintegrationParams.h>
#include <gtsam/nonlinear/DoglegOptimizer.h>
#include <gtsam/nonlinear/GaussNewtonOptimizer.h>
#include <gtsam/nonlinear/ISAM2.h>
#include <gtsam/nonlinear/LevenbergMarquardtOptimizer.h>
#include <gtsam/nonlinear/LinearContainerFactor.h>
#include <gtsam/nonlinear/Marginals.h>
#include <gtsam/nonlinear/NonlinearEquality.h>
#include <gtsam/nonlinear/NonlinearFactor.h>
#include <gtsam/nonlinear/NonlinearFactorGraph.h>
#include <gtsam/nonlinear/NonlinearISAM.h>
#include <gtsam/nonlinear/NonlinearOptimizer.h>
#include <gtsam/nonlinear/NonlinearOptimizerParams.h>
#include <gtsam/nonlinear/Values.h>
#include <gtsam/nonlinear/utilities.h>
#include <gtsam/sam/BearingFactor.h>
#include <gtsam/sam/BearingRangeFactor.h>
#include <gtsam/sam/RangeFactor.h>
#include <gtsam/slam/BetweenFactor.h>
#include <gtsam/slam/EssentialMatrixFactor.h>
#include <gtsam/slam/GeneralSFMFactor.h>
#include <gtsam/slam/PoseRotationPrior.h>
#include <gtsam/slam/PoseTranslationPrior.h>
#include <gtsam/slam/PriorFactor.h>
#include <gtsam/slam/ProjectionFactor.h>
#include <gtsam/slam/SmartProjectionFactor.h>
#include <gtsam/slam/SmartProjectionPoseFactor.h>
#include <gtsam/slam/StereoFactor.h>
#include <gtsam/slam/dataset.h>
#include <gtsam/symbolic/SymbolicBayesNet.h>
#include <gtsam/symbolic/SymbolicBayesTree.h>
#include <gtsam/symbolic/SymbolicConditional.h>
#include <gtsam/symbolic/SymbolicFactor.h>
#include <gtsam/symbolic/SymbolicFactorGraph.h>

namespace gtsam { typedef gtsam::PriorFactor<Vector> PriorFactorVector; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::Point2> PriorFactorPoint2; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::StereoPoint2> PriorFactorStereoPoint2; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::Point3> PriorFactorPoint3; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::Rot2> PriorFactorRot2; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::Rot3> PriorFactorRot3; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::Pose2> PriorFactorPose2; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::Pose3> PriorFactorPose3; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::Cal3_S2> PriorFactorCal3_S2; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::CalibratedCamera> PriorFactorCalibratedCamera; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::SimpleCamera> PriorFactorSimpleCamera; }
namespace gtsam { typedef gtsam::PriorFactor<gtsam::imuBias::ConstantBias> PriorFactorConstantBias; }
namespace gtsam { typedef gtsam::BetweenFactor<gtsam::Point2> BetweenFactorPoint2; }
namespace gtsam { typedef gtsam::BetweenFactor<gtsam::Point3> BetweenFactorPoint3; }
namespace gtsam { typedef gtsam::BetweenFactor<gtsam::Rot2> BetweenFactorRot2; }
namespace gtsam { typedef gtsam::BetweenFactor<gtsam::Rot3> BetweenFactorRot3; }
namespace gtsam { typedef gtsam::BetweenFactor<gtsam::Pose2> BetweenFactorPose2; }
namespace gtsam { typedef gtsam::BetweenFactor<gtsam::Pose3> BetweenFactorPose3; }
namespace gtsam { typedef gtsam::BetweenFactor<gtsam::imuBias::ConstantBias> BetweenFactorConstantBias; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::Point2> NonlinearEqualityPoint2; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::StereoPoint2> NonlinearEqualityStereoPoint2; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::Point3> NonlinearEqualityPoint3; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::Rot2> NonlinearEqualityRot2; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::Rot3> NonlinearEqualityRot3; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::Pose2> NonlinearEqualityPose2; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::Pose3> NonlinearEqualityPose3; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::Cal3_S2> NonlinearEqualityCal3_S2; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::CalibratedCamera> NonlinearEqualityCalibratedCamera; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::SimpleCamera> NonlinearEqualitySimpleCamera; }
namespace gtsam { typedef gtsam::NonlinearEquality<gtsam::imuBias::ConstantBias> NonlinearEqualityConstantBias; }
namespace gtsam { typedef gtsam::GeneralSFMFactor2<gtsam::Cal3_S2> GeneralSFMFactor2Cal3_S2; }
namespace gtsam { typedef gtsam::PinholeCamera<gtsam::Cal3_S2> PinholeCameraCal3_S2; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::Pose2, gtsam::Point2> RangeFactorPosePoint2; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::Pose3, gtsam::Point3> RangeFactorPosePoint3; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::Pose2, gtsam::Pose2> RangeFactorPose2; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::Pose3, gtsam::Pose3> RangeFactorPose3; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::CalibratedCamera, gtsam::Point3> RangeFactorCalibratedCameraPoint; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::SimpleCamera, gtsam::Point3> RangeFactorSimpleCameraPoint; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::CalibratedCamera, gtsam::CalibratedCamera> RangeFactorCalibratedCamera; }
namespace gtsam { typedef gtsam::RangeFactor<gtsam::SimpleCamera, gtsam::SimpleCamera> RangeFactorSimpleCamera; }
namespace gtsam { typedef gtsam::RangeFactorWithTransform<gtsam::Pose2, gtsam::Point2> RangeFactorWithTransformPosePoint2; }
namespace gtsam { typedef gtsam::RangeFactorWithTransform<gtsam::Pose3, gtsam::Point3> RangeFactorWithTransformPosePoint3; }
namespace gtsam { typedef gtsam::RangeFactorWithTransform<gtsam::Pose2, gtsam::Pose2> RangeFactorWithTransformPose2; }
namespace gtsam { typedef gtsam::RangeFactorWithTransform<gtsam::Pose3, gtsam::Pose3> RangeFactorWithTransformPose3; }
namespace gtsam { typedef gtsam::BearingFactor<gtsam::Pose2, gtsam::Point2, gtsam::Rot2> BearingFactor2D; }
namespace gtsam { typedef gtsam::BearingRangeFactor<gtsam::Pose2, gtsam::Point2, gtsam::Rot2, double> BearingRangeFactor2D; }
namespace gtsam { typedef gtsam::GenericProjectionFactor<gtsam::Pose3, gtsam::Point3, gtsam::Cal3_S2> GenericProjectionFactorCal3_S2; }
namespace gtsam { typedef gtsam::GenericProjectionFactor<gtsam::Pose3, gtsam::Point3, gtsam::Cal3DS2> GenericProjectionFactorCal3DS2; }
namespace gtsam { typedef gtsam::GeneralSFMFactor<gtsam::SimpleCamera, gtsam::Point3> GeneralSFMFactorCal3_S2; }
namespace gtsam { typedef gtsam::SmartProjectionPoseFactor<gtsam::Cal3_S2> SmartProjectionPose3Factor; }
namespace gtsam { typedef gtsam::GenericStereoFactor<gtsam::Pose3, gtsam::Point3> GenericStereoFactor3D; }
namespace gtsam { typedef gtsam::PoseTranslationPrior<gtsam::Pose2> PoseTranslationPrior2D; }
namespace gtsam { typedef gtsam::PoseTranslationPrior<gtsam::Pose3> PoseTranslationPrior3D; }
namespace gtsam { typedef gtsam::PoseRotationPrior<gtsam::Pose2> PoseRotationPrior2D; }
namespace gtsam { typedef gtsam::PoseRotationPrior<gtsam::Pose3> PoseRotationPrior3D; }

BOOST_CLASS_EXPORT_GUID(gtsam::KeyList, "gtsamKeyList");
BOOST_CLASS_EXPORT_GUID(gtsam::KeySet, "gtsamKeySet");
BOOST_CLASS_EXPORT_GUID(gtsam::KeyVector, "gtsamKeyVector");
BOOST_CLASS_EXPORT_GUID(gtsam::LieVector, "gtsamLieVector");
BOOST_CLASS_EXPORT_GUID(gtsam::LieMatrix, "gtsamLieMatrix");
BOOST_CLASS_EXPORT_GUID(gtsam::Point2, "gtsamPoint2");
BOOST_CLASS_EXPORT_GUID(gtsam::StereoPoint2, "gtsamStereoPoint2");
BOOST_CLASS_EXPORT_GUID(gtsam::Point3, "gtsamPoint3");
BOOST_CLASS_EXPORT_GUID(gtsam::Rot2, "gtsamRot2");
BOOST_CLASS_EXPORT_GUID(gtsam::Rot3, "gtsamRot3");
BOOST_CLASS_EXPORT_GUID(gtsam::Pose2, "gtsamPose2");
BOOST_CLASS_EXPORT_GUID(gtsam::Pose3, "gtsamPose3");
BOOST_CLASS_EXPORT_GUID(gtsam::Cal3_S2, "gtsamCal3_S2");
BOOST_CLASS_EXPORT_GUID(gtsam::Cal3DS2_Base, "gtsamCal3DS2_Base");
BOOST_CLASS_EXPORT_GUID(gtsam::Cal3DS2, "gtsamCal3DS2");
BOOST_CLASS_EXPORT_GUID(gtsam::Cal3Unified, "gtsamCal3Unified");
BOOST_CLASS_EXPORT_GUID(gtsam::Cal3Bundler, "gtsamCal3Bundler");
BOOST_CLASS_EXPORT_GUID(gtsam::CalibratedCamera, "gtsamCalibratedCamera");
BOOST_CLASS_EXPORT_GUID(gtsam::SimpleCamera, "gtsamSimpleCamera");
BOOST_CLASS_EXPORT_GUID(gtsam::StereoCamera, "gtsamStereoCamera");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::Gaussian, "gtsamnoiseModelGaussian");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::Diagonal, "gtsamnoiseModelDiagonal");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::Constrained, "gtsamnoiseModelConstrained");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::Isotropic, "gtsamnoiseModelIsotropic");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::Unit, "gtsamnoiseModelUnit");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::mEstimator::Null, "gtsamnoiseModelmEstimatorNull");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::mEstimator::Fair, "gtsamnoiseModelmEstimatorFair");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::mEstimator::Huber, "gtsamnoiseModelmEstimatorHuber");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::mEstimator::Tukey, "gtsamnoiseModelmEstimatorTukey");
BOOST_CLASS_EXPORT_GUID(gtsam::noiseModel::Robust, "gtsamnoiseModelRobust");
BOOST_CLASS_EXPORT_GUID(gtsam::VectorValues, "gtsamVectorValues");
BOOST_CLASS_EXPORT_GUID(gtsam::JacobianFactor, "gtsamJacobianFactor");
BOOST_CLASS_EXPORT_GUID(gtsam::HessianFactor, "gtsamHessianFactor");
BOOST_CLASS_EXPORT_GUID(gtsam::GaussianFactorGraph, "gtsamGaussianFactorGraph");
BOOST_CLASS_EXPORT_GUID(gtsam::GaussianConditional, "gtsamGaussianConditional");
BOOST_CLASS_EXPORT_GUID(gtsam::Ordering, "gtsamOrdering");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearFactorGraph, "gtsamNonlinearFactorGraph");
BOOST_CLASS_EXPORT_GUID(gtsam::Values, "gtsamValues");
BOOST_CLASS_EXPORT_GUID(gtsam::LinearContainerFactor, "gtsamLinearContainerFactor");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorVector, "gtsamPriorFactorVector");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorPoint2, "gtsamPriorFactorPoint2");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorStereoPoint2, "gtsamPriorFactorStereoPoint2");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorPoint3, "gtsamPriorFactorPoint3");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorRot2, "gtsamPriorFactorRot2");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorRot3, "gtsamPriorFactorRot3");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorPose2, "gtsamPriorFactorPose2");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorPose3, "gtsamPriorFactorPose3");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorCal3_S2, "gtsamPriorFactorCal3_S2");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorCalibratedCamera, "gtsamPriorFactorCalibratedCamera");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorSimpleCamera, "gtsamPriorFactorSimpleCamera");
BOOST_CLASS_EXPORT_GUID(gtsam::PriorFactorConstantBias, "gtsamPriorFactorConstantBias");
BOOST_CLASS_EXPORT_GUID(gtsam::BetweenFactorPoint2, "gtsamBetweenFactorPoint2");
BOOST_CLASS_EXPORT_GUID(gtsam::BetweenFactorPoint3, "gtsamBetweenFactorPoint3");
BOOST_CLASS_EXPORT_GUID(gtsam::BetweenFactorRot2, "gtsamBetweenFactorRot2");
BOOST_CLASS_EXPORT_GUID(gtsam::BetweenFactorRot3, "gtsamBetweenFactorRot3");
BOOST_CLASS_EXPORT_GUID(gtsam::BetweenFactorPose2, "gtsamBetweenFactorPose2");
BOOST_CLASS_EXPORT_GUID(gtsam::BetweenFactorPose3, "gtsamBetweenFactorPose3");
BOOST_CLASS_EXPORT_GUID(gtsam::BetweenFactorConstantBias, "gtsamBetweenFactorConstantBias");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityPoint2, "gtsamNonlinearEqualityPoint2");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityStereoPoint2, "gtsamNonlinearEqualityStereoPoint2");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityPoint3, "gtsamNonlinearEqualityPoint3");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityRot2, "gtsamNonlinearEqualityRot2");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityRot3, "gtsamNonlinearEqualityRot3");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityPose2, "gtsamNonlinearEqualityPose2");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityPose3, "gtsamNonlinearEqualityPose3");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityCal3_S2, "gtsamNonlinearEqualityCal3_S2");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityCalibratedCamera, "gtsamNonlinearEqualityCalibratedCamera");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualitySimpleCamera, "gtsamNonlinearEqualitySimpleCamera");
BOOST_CLASS_EXPORT_GUID(gtsam::NonlinearEqualityConstantBias, "gtsamNonlinearEqualityConstantBias");
BOOST_CLASS_EXPORT_GUID(gtsam::GeneralSFMFactor2Cal3_S2, "gtsamGeneralSFMFactor2Cal3_S2");
BOOST_CLASS_EXPORT_GUID(gtsam::PinholeCameraCal3_S2, "gtsamPinholeCameraCal3_S2");
BOOST_CLASS_EXPORT_GUID(gtsam::BearingFactor2D, "gtsamBearingFactor2D");
BOOST_CLASS_EXPORT_GUID(gtsam::BearingRangeFactor2D, "gtsamBearingRangeFactor2D");
BOOST_CLASS_EXPORT_GUID(gtsam::GenericProjectionFactorCal3_S2, "gtsamGenericProjectionFactorCal3_S2");
BOOST_CLASS_EXPORT_GUID(gtsam::GenericProjectionFactorCal3DS2, "gtsamGenericProjectionFactorCal3DS2");
BOOST_CLASS_EXPORT_GUID(gtsam::GenericStereoFactor3D, "gtsamGenericStereoFactor3D");

typedef std::set<boost::shared_ptr<gtsam::KeyList>*> Collector_gtsamKeyList;
static Collector_gtsamKeyList collector_gtsamKeyList;
typedef std::set<boost::shared_ptr<gtsam::KeySet>*> Collector_gtsamKeySet;
static Collector_gtsamKeySet collector_gtsamKeySet;
typedef std::set<boost::shared_ptr<gtsam::KeyVector>*> Collector_gtsamKeyVector;
static Collector_gtsamKeyVector collector_gtsamKeyVector;
typedef std::set<boost::shared_ptr<gtsam::KeyGroupMap>*> Collector_gtsamKeyGroupMap;
static Collector_gtsamKeyGroupMap collector_gtsamKeyGroupMap;
typedef std::set<boost::shared_ptr<gtsam::Value>*> Collector_gtsamValue;
static Collector_gtsamValue collector_gtsamValue;
typedef std::set<boost::shared_ptr<gtsam::LieScalar>*> Collector_gtsamLieScalar;
static Collector_gtsamLieScalar collector_gtsamLieScalar;
typedef std::set<boost::shared_ptr<gtsam::LieVector>*> Collector_gtsamLieVector;
static Collector_gtsamLieVector collector_gtsamLieVector;
typedef std::set<boost::shared_ptr<gtsam::LieMatrix>*> Collector_gtsamLieMatrix;
static Collector_gtsamLieMatrix collector_gtsamLieMatrix;
typedef std::set<boost::shared_ptr<gtsam::Point2>*> Collector_gtsamPoint2;
static Collector_gtsamPoint2 collector_gtsamPoint2;
typedef std::set<boost::shared_ptr<gtsam::Point2Vector>*> Collector_gtsamPoint2Vector;
static Collector_gtsamPoint2Vector collector_gtsamPoint2Vector;
typedef std::set<boost::shared_ptr<gtsam::StereoPoint2>*> Collector_gtsamStereoPoint2;
static Collector_gtsamStereoPoint2 collector_gtsamStereoPoint2;
typedef std::set<boost::shared_ptr<gtsam::Point3>*> Collector_gtsamPoint3;
static Collector_gtsamPoint3 collector_gtsamPoint3;
typedef std::set<boost::shared_ptr<gtsam::Rot2>*> Collector_gtsamRot2;
static Collector_gtsamRot2 collector_gtsamRot2;
typedef std::set<boost::shared_ptr<gtsam::Rot3>*> Collector_gtsamRot3;
static Collector_gtsamRot3 collector_gtsamRot3;
typedef std::set<boost::shared_ptr<gtsam::Pose2>*> Collector_gtsamPose2;
static Collector_gtsamPose2 collector_gtsamPose2;
typedef std::set<boost::shared_ptr<gtsam::Pose3>*> Collector_gtsamPose3;
static Collector_gtsamPose3 collector_gtsamPose3;
typedef std::set<boost::shared_ptr<gtsam::Pose3Vector>*> Collector_gtsamPose3Vector;
static Collector_gtsamPose3Vector collector_gtsamPose3Vector;
typedef std::set<boost::shared_ptr<gtsam::Unit3>*> Collector_gtsamUnit3;
static Collector_gtsamUnit3 collector_gtsamUnit3;
typedef std::set<boost::shared_ptr<gtsam::EssentialMatrix>*> Collector_gtsamEssentialMatrix;
static Collector_gtsamEssentialMatrix collector_gtsamEssentialMatrix;
typedef std::set<boost::shared_ptr<gtsam::Cal3_S2>*> Collector_gtsamCal3_S2;
static Collector_gtsamCal3_S2 collector_gtsamCal3_S2;
typedef std::set<boost::shared_ptr<gtsam::Cal3DS2_Base>*> Collector_gtsamCal3DS2_Base;
static Collector_gtsamCal3DS2_Base collector_gtsamCal3DS2_Base;
typedef std::set<boost::shared_ptr<gtsam::Cal3DS2>*> Collector_gtsamCal3DS2;
static Collector_gtsamCal3DS2 collector_gtsamCal3DS2;
typedef std::set<boost::shared_ptr<gtsam::Cal3Unified>*> Collector_gtsamCal3Unified;
static Collector_gtsamCal3Unified collector_gtsamCal3Unified;
typedef std::set<boost::shared_ptr<gtsam::Cal3_S2Stereo>*> Collector_gtsamCal3_S2Stereo;
static Collector_gtsamCal3_S2Stereo collector_gtsamCal3_S2Stereo;
typedef std::set<boost::shared_ptr<gtsam::Cal3Bundler>*> Collector_gtsamCal3Bundler;
static Collector_gtsamCal3Bundler collector_gtsamCal3Bundler;
typedef std::set<boost::shared_ptr<gtsam::CalibratedCamera>*> Collector_gtsamCalibratedCamera;
static Collector_gtsamCalibratedCamera collector_gtsamCalibratedCamera;
typedef std::set<boost::shared_ptr<gtsam::SimpleCamera>*> Collector_gtsamSimpleCamera;
static Collector_gtsamSimpleCamera collector_gtsamSimpleCamera;
typedef std::set<boost::shared_ptr<gtsam::StereoCamera>*> Collector_gtsamStereoCamera;
static Collector_gtsamStereoCamera collector_gtsamStereoCamera;
typedef std::set<boost::shared_ptr<gtsam::SymbolicFactor>*> Collector_gtsamSymbolicFactor;
static Collector_gtsamSymbolicFactor collector_gtsamSymbolicFactor;
typedef std::set<boost::shared_ptr<gtsam::SymbolicFactorGraph>*> Collector_gtsamSymbolicFactorGraph;
static Collector_gtsamSymbolicFactorGraph collector_gtsamSymbolicFactorGraph;
typedef std::set<boost::shared_ptr<gtsam::SymbolicConditional>*> Collector_gtsamSymbolicConditional;
static Collector_gtsamSymbolicConditional collector_gtsamSymbolicConditional;
typedef std::set<boost::shared_ptr<gtsam::SymbolicBayesNet>*> Collector_gtsamSymbolicBayesNet;
static Collector_gtsamSymbolicBayesNet collector_gtsamSymbolicBayesNet;
typedef std::set<boost::shared_ptr<gtsam::SymbolicBayesTree>*> Collector_gtsamSymbolicBayesTree;
static Collector_gtsamSymbolicBayesTree collector_gtsamSymbolicBayesTree;
typedef std::set<boost::shared_ptr<gtsam::VariableIndex>*> Collector_gtsamVariableIndex;
static Collector_gtsamVariableIndex collector_gtsamVariableIndex;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::Base>*> Collector_gtsamnoiseModelBase;
static Collector_gtsamnoiseModelBase collector_gtsamnoiseModelBase;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::Gaussian>*> Collector_gtsamnoiseModelGaussian;
static Collector_gtsamnoiseModelGaussian collector_gtsamnoiseModelGaussian;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::Diagonal>*> Collector_gtsamnoiseModelDiagonal;
static Collector_gtsamnoiseModelDiagonal collector_gtsamnoiseModelDiagonal;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::Constrained>*> Collector_gtsamnoiseModelConstrained;
static Collector_gtsamnoiseModelConstrained collector_gtsamnoiseModelConstrained;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::Isotropic>*> Collector_gtsamnoiseModelIsotropic;
static Collector_gtsamnoiseModelIsotropic collector_gtsamnoiseModelIsotropic;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::Unit>*> Collector_gtsamnoiseModelUnit;
static Collector_gtsamnoiseModelUnit collector_gtsamnoiseModelUnit;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::mEstimator::Base>*> Collector_gtsamnoiseModelmEstimatorBase;
static Collector_gtsamnoiseModelmEstimatorBase collector_gtsamnoiseModelmEstimatorBase;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::mEstimator::Null>*> Collector_gtsamnoiseModelmEstimatorNull;
static Collector_gtsamnoiseModelmEstimatorNull collector_gtsamnoiseModelmEstimatorNull;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair>*> Collector_gtsamnoiseModelmEstimatorFair;
static Collector_gtsamnoiseModelmEstimatorFair collector_gtsamnoiseModelmEstimatorFair;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber>*> Collector_gtsamnoiseModelmEstimatorHuber;
static Collector_gtsamnoiseModelmEstimatorHuber collector_gtsamnoiseModelmEstimatorHuber;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey>*> Collector_gtsamnoiseModelmEstimatorTukey;
static Collector_gtsamnoiseModelmEstimatorTukey collector_gtsamnoiseModelmEstimatorTukey;
typedef std::set<boost::shared_ptr<gtsam::noiseModel::Robust>*> Collector_gtsamnoiseModelRobust;
static Collector_gtsamnoiseModelRobust collector_gtsamnoiseModelRobust;
typedef std::set<boost::shared_ptr<gtsam::Sampler>*> Collector_gtsamSampler;
static Collector_gtsamSampler collector_gtsamSampler;
typedef std::set<boost::shared_ptr<gtsam::VectorValues>*> Collector_gtsamVectorValues;
static Collector_gtsamVectorValues collector_gtsamVectorValues;
typedef std::set<boost::shared_ptr<gtsam::GaussianFactor>*> Collector_gtsamGaussianFactor;
static Collector_gtsamGaussianFactor collector_gtsamGaussianFactor;
typedef std::set<boost::shared_ptr<gtsam::JacobianFactor>*> Collector_gtsamJacobianFactor;
static Collector_gtsamJacobianFactor collector_gtsamJacobianFactor;
typedef std::set<boost::shared_ptr<gtsam::HessianFactor>*> Collector_gtsamHessianFactor;
static Collector_gtsamHessianFactor collector_gtsamHessianFactor;
typedef std::set<boost::shared_ptr<gtsam::GaussianFactorGraph>*> Collector_gtsamGaussianFactorGraph;
static Collector_gtsamGaussianFactorGraph collector_gtsamGaussianFactorGraph;
typedef std::set<boost::shared_ptr<gtsam::GaussianConditional>*> Collector_gtsamGaussianConditional;
static Collector_gtsamGaussianConditional collector_gtsamGaussianConditional;
typedef std::set<boost::shared_ptr<gtsam::GaussianDensity>*> Collector_gtsamGaussianDensity;
static Collector_gtsamGaussianDensity collector_gtsamGaussianDensity;
typedef std::set<boost::shared_ptr<gtsam::GaussianBayesNet>*> Collector_gtsamGaussianBayesNet;
static Collector_gtsamGaussianBayesNet collector_gtsamGaussianBayesNet;
typedef std::set<boost::shared_ptr<gtsam::GaussianBayesTree>*> Collector_gtsamGaussianBayesTree;
static Collector_gtsamGaussianBayesTree collector_gtsamGaussianBayesTree;
typedef std::set<boost::shared_ptr<gtsam::Errors>*> Collector_gtsamErrors;
static Collector_gtsamErrors collector_gtsamErrors;
typedef std::set<boost::shared_ptr<gtsam::GaussianISAM>*> Collector_gtsamGaussianISAM;
static Collector_gtsamGaussianISAM collector_gtsamGaussianISAM;
typedef std::set<boost::shared_ptr<gtsam::IterativeOptimizationParameters>*> Collector_gtsamIterativeOptimizationParameters;
static Collector_gtsamIterativeOptimizationParameters collector_gtsamIterativeOptimizationParameters;
typedef std::set<boost::shared_ptr<gtsam::ConjugateGradientParameters>*> Collector_gtsamConjugateGradientParameters;
static Collector_gtsamConjugateGradientParameters collector_gtsamConjugateGradientParameters;
typedef std::set<boost::shared_ptr<gtsam::SubgraphSolverParameters>*> Collector_gtsamSubgraphSolverParameters;
static Collector_gtsamSubgraphSolverParameters collector_gtsamSubgraphSolverParameters;
typedef std::set<boost::shared_ptr<gtsam::SubgraphSolver>*> Collector_gtsamSubgraphSolver;
static Collector_gtsamSubgraphSolver collector_gtsamSubgraphSolver;
typedef std::set<boost::shared_ptr<gtsam::KalmanFilter>*> Collector_gtsamKalmanFilter;
static Collector_gtsamKalmanFilter collector_gtsamKalmanFilter;
typedef std::set<boost::shared_ptr<gtsam::LabeledSymbol>*> Collector_gtsamLabeledSymbol;
static Collector_gtsamLabeledSymbol collector_gtsamLabeledSymbol;
typedef std::set<boost::shared_ptr<gtsam::Ordering>*> Collector_gtsamOrdering;
static Collector_gtsamOrdering collector_gtsamOrdering;
typedef std::set<boost::shared_ptr<gtsam::NonlinearFactorGraph>*> Collector_gtsamNonlinearFactorGraph;
static Collector_gtsamNonlinearFactorGraph collector_gtsamNonlinearFactorGraph;
typedef std::set<boost::shared_ptr<gtsam::NonlinearFactor>*> Collector_gtsamNonlinearFactor;
static Collector_gtsamNonlinearFactor collector_gtsamNonlinearFactor;
typedef std::set<boost::shared_ptr<gtsam::NoiseModelFactor>*> Collector_gtsamNoiseModelFactor;
static Collector_gtsamNoiseModelFactor collector_gtsamNoiseModelFactor;
typedef std::set<boost::shared_ptr<gtsam::Values>*> Collector_gtsamValues;
static Collector_gtsamValues collector_gtsamValues;
typedef std::set<boost::shared_ptr<gtsam::Marginals>*> Collector_gtsamMarginals;
static Collector_gtsamMarginals collector_gtsamMarginals;
typedef std::set<boost::shared_ptr<gtsam::JointMarginal>*> Collector_gtsamJointMarginal;
static Collector_gtsamJointMarginal collector_gtsamJointMarginal;
typedef std::set<boost::shared_ptr<gtsam::LinearContainerFactor>*> Collector_gtsamLinearContainerFactor;
static Collector_gtsamLinearContainerFactor collector_gtsamLinearContainerFactor;
typedef std::set<boost::shared_ptr<gtsam::NonlinearOptimizerParams>*> Collector_gtsamNonlinearOptimizerParams;
static Collector_gtsamNonlinearOptimizerParams collector_gtsamNonlinearOptimizerParams;
typedef std::set<boost::shared_ptr<gtsam::GaussNewtonParams>*> Collector_gtsamGaussNewtonParams;
static Collector_gtsamGaussNewtonParams collector_gtsamGaussNewtonParams;
typedef std::set<boost::shared_ptr<gtsam::LevenbergMarquardtParams>*> Collector_gtsamLevenbergMarquardtParams;
static Collector_gtsamLevenbergMarquardtParams collector_gtsamLevenbergMarquardtParams;
typedef std::set<boost::shared_ptr<gtsam::DoglegParams>*> Collector_gtsamDoglegParams;
static Collector_gtsamDoglegParams collector_gtsamDoglegParams;
typedef std::set<boost::shared_ptr<gtsam::NonlinearOptimizer>*> Collector_gtsamNonlinearOptimizer;
static Collector_gtsamNonlinearOptimizer collector_gtsamNonlinearOptimizer;
typedef std::set<boost::shared_ptr<gtsam::GaussNewtonOptimizer>*> Collector_gtsamGaussNewtonOptimizer;
static Collector_gtsamGaussNewtonOptimizer collector_gtsamGaussNewtonOptimizer;
typedef std::set<boost::shared_ptr<gtsam::DoglegOptimizer>*> Collector_gtsamDoglegOptimizer;
static Collector_gtsamDoglegOptimizer collector_gtsamDoglegOptimizer;
typedef std::set<boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer>*> Collector_gtsamLevenbergMarquardtOptimizer;
static Collector_gtsamLevenbergMarquardtOptimizer collector_gtsamLevenbergMarquardtOptimizer;
typedef std::set<boost::shared_ptr<gtsam::ISAM2GaussNewtonParams>*> Collector_gtsamISAM2GaussNewtonParams;
static Collector_gtsamISAM2GaussNewtonParams collector_gtsamISAM2GaussNewtonParams;
typedef std::set<boost::shared_ptr<gtsam::ISAM2DoglegParams>*> Collector_gtsamISAM2DoglegParams;
static Collector_gtsamISAM2DoglegParams collector_gtsamISAM2DoglegParams;
typedef std::set<boost::shared_ptr<gtsam::ISAM2ThresholdMapValue>*> Collector_gtsamISAM2ThresholdMapValue;
static Collector_gtsamISAM2ThresholdMapValue collector_gtsamISAM2ThresholdMapValue;
typedef std::set<boost::shared_ptr<gtsam::ISAM2ThresholdMap>*> Collector_gtsamISAM2ThresholdMap;
static Collector_gtsamISAM2ThresholdMap collector_gtsamISAM2ThresholdMap;
typedef std::set<boost::shared_ptr<gtsam::ISAM2Params>*> Collector_gtsamISAM2Params;
static Collector_gtsamISAM2Params collector_gtsamISAM2Params;
typedef std::set<boost::shared_ptr<gtsam::ISAM2Clique>*> Collector_gtsamISAM2Clique;
static Collector_gtsamISAM2Clique collector_gtsamISAM2Clique;
typedef std::set<boost::shared_ptr<gtsam::ISAM2Result>*> Collector_gtsamISAM2Result;
static Collector_gtsamISAM2Result collector_gtsamISAM2Result;
typedef std::set<boost::shared_ptr<gtsam::FactorIndices>*> Collector_gtsamFactorIndices;
static Collector_gtsamFactorIndices collector_gtsamFactorIndices;
typedef std::set<boost::shared_ptr<gtsam::ISAM2>*> Collector_gtsamISAM2;
static Collector_gtsamISAM2 collector_gtsamISAM2;
typedef std::set<boost::shared_ptr<gtsam::NonlinearISAM>*> Collector_gtsamNonlinearISAM;
static Collector_gtsamNonlinearISAM collector_gtsamNonlinearISAM;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorVector>*> Collector_gtsamPriorFactorVector;
static Collector_gtsamPriorFactorVector collector_gtsamPriorFactorVector;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorPoint2>*> Collector_gtsamPriorFactorPoint2;
static Collector_gtsamPriorFactorPoint2 collector_gtsamPriorFactorPoint2;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorStereoPoint2>*> Collector_gtsamPriorFactorStereoPoint2;
static Collector_gtsamPriorFactorStereoPoint2 collector_gtsamPriorFactorStereoPoint2;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorPoint3>*> Collector_gtsamPriorFactorPoint3;
static Collector_gtsamPriorFactorPoint3 collector_gtsamPriorFactorPoint3;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorRot2>*> Collector_gtsamPriorFactorRot2;
static Collector_gtsamPriorFactorRot2 collector_gtsamPriorFactorRot2;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorRot3>*> Collector_gtsamPriorFactorRot3;
static Collector_gtsamPriorFactorRot3 collector_gtsamPriorFactorRot3;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorPose2>*> Collector_gtsamPriorFactorPose2;
static Collector_gtsamPriorFactorPose2 collector_gtsamPriorFactorPose2;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorPose3>*> Collector_gtsamPriorFactorPose3;
static Collector_gtsamPriorFactorPose3 collector_gtsamPriorFactorPose3;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorCal3_S2>*> Collector_gtsamPriorFactorCal3_S2;
static Collector_gtsamPriorFactorCal3_S2 collector_gtsamPriorFactorCal3_S2;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorCalibratedCamera>*> Collector_gtsamPriorFactorCalibratedCamera;
static Collector_gtsamPriorFactorCalibratedCamera collector_gtsamPriorFactorCalibratedCamera;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorSimpleCamera>*> Collector_gtsamPriorFactorSimpleCamera;
static Collector_gtsamPriorFactorSimpleCamera collector_gtsamPriorFactorSimpleCamera;
typedef std::set<boost::shared_ptr<gtsam::PriorFactorConstantBias>*> Collector_gtsamPriorFactorConstantBias;
static Collector_gtsamPriorFactorConstantBias collector_gtsamPriorFactorConstantBias;
typedef std::set<boost::shared_ptr<gtsam::BetweenFactorPoint2>*> Collector_gtsamBetweenFactorPoint2;
static Collector_gtsamBetweenFactorPoint2 collector_gtsamBetweenFactorPoint2;
typedef std::set<boost::shared_ptr<gtsam::BetweenFactorPoint3>*> Collector_gtsamBetweenFactorPoint3;
static Collector_gtsamBetweenFactorPoint3 collector_gtsamBetweenFactorPoint3;
typedef std::set<boost::shared_ptr<gtsam::BetweenFactorRot2>*> Collector_gtsamBetweenFactorRot2;
static Collector_gtsamBetweenFactorRot2 collector_gtsamBetweenFactorRot2;
typedef std::set<boost::shared_ptr<gtsam::BetweenFactorRot3>*> Collector_gtsamBetweenFactorRot3;
static Collector_gtsamBetweenFactorRot3 collector_gtsamBetweenFactorRot3;
typedef std::set<boost::shared_ptr<gtsam::BetweenFactorPose2>*> Collector_gtsamBetweenFactorPose2;
static Collector_gtsamBetweenFactorPose2 collector_gtsamBetweenFactorPose2;
typedef std::set<boost::shared_ptr<gtsam::BetweenFactorPose3>*> Collector_gtsamBetweenFactorPose3;
static Collector_gtsamBetweenFactorPose3 collector_gtsamBetweenFactorPose3;
typedef std::set<boost::shared_ptr<gtsam::BetweenFactorConstantBias>*> Collector_gtsamBetweenFactorConstantBias;
static Collector_gtsamBetweenFactorConstantBias collector_gtsamBetweenFactorConstantBias;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityPoint2>*> Collector_gtsamNonlinearEqualityPoint2;
static Collector_gtsamNonlinearEqualityPoint2 collector_gtsamNonlinearEqualityPoint2;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2>*> Collector_gtsamNonlinearEqualityStereoPoint2;
static Collector_gtsamNonlinearEqualityStereoPoint2 collector_gtsamNonlinearEqualityStereoPoint2;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityPoint3>*> Collector_gtsamNonlinearEqualityPoint3;
static Collector_gtsamNonlinearEqualityPoint3 collector_gtsamNonlinearEqualityPoint3;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityRot2>*> Collector_gtsamNonlinearEqualityRot2;
static Collector_gtsamNonlinearEqualityRot2 collector_gtsamNonlinearEqualityRot2;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityRot3>*> Collector_gtsamNonlinearEqualityRot3;
static Collector_gtsamNonlinearEqualityRot3 collector_gtsamNonlinearEqualityRot3;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityPose2>*> Collector_gtsamNonlinearEqualityPose2;
static Collector_gtsamNonlinearEqualityPose2 collector_gtsamNonlinearEqualityPose2;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityPose3>*> Collector_gtsamNonlinearEqualityPose3;
static Collector_gtsamNonlinearEqualityPose3 collector_gtsamNonlinearEqualityPose3;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2>*> Collector_gtsamNonlinearEqualityCal3_S2;
static Collector_gtsamNonlinearEqualityCal3_S2 collector_gtsamNonlinearEqualityCal3_S2;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>*> Collector_gtsamNonlinearEqualityCalibratedCamera;
static Collector_gtsamNonlinearEqualityCalibratedCamera collector_gtsamNonlinearEqualityCalibratedCamera;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera>*> Collector_gtsamNonlinearEqualitySimpleCamera;
static Collector_gtsamNonlinearEqualitySimpleCamera collector_gtsamNonlinearEqualitySimpleCamera;
typedef std::set<boost::shared_ptr<gtsam::NonlinearEqualityConstantBias>*> Collector_gtsamNonlinearEqualityConstantBias;
static Collector_gtsamNonlinearEqualityConstantBias collector_gtsamNonlinearEqualityConstantBias;
typedef std::set<boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>*> Collector_gtsamGeneralSFMFactor2Cal3_S2;
static Collector_gtsamGeneralSFMFactor2Cal3_S2 collector_gtsamGeneralSFMFactor2Cal3_S2;
typedef std::set<boost::shared_ptr<gtsam::SmartProjectionParams>*> Collector_gtsamSmartProjectionParams;
static Collector_gtsamSmartProjectionParams collector_gtsamSmartProjectionParams;
typedef std::set<boost::shared_ptr<gtsam::EssentialMatrixFactor>*> Collector_gtsamEssentialMatrixFactor;
static Collector_gtsamEssentialMatrixFactor collector_gtsamEssentialMatrixFactor;
typedef std::set<boost::shared_ptr<gtsam::imuBias::ConstantBias>*> Collector_gtsamimuBiasConstantBias;
static Collector_gtsamimuBiasConstantBias collector_gtsamimuBiasConstantBias;
typedef std::set<boost::shared_ptr<gtsam::NavState>*> Collector_gtsamNavState;
static Collector_gtsamNavState collector_gtsamNavState;
typedef std::set<boost::shared_ptr<gtsam::PreintegratedRotationParams>*> Collector_gtsamPreintegratedRotationParams;
static Collector_gtsamPreintegratedRotationParams collector_gtsamPreintegratedRotationParams;
typedef std::set<boost::shared_ptr<gtsam::PreintegrationParams>*> Collector_gtsamPreintegrationParams;
static Collector_gtsamPreintegrationParams collector_gtsamPreintegrationParams;
typedef std::set<boost::shared_ptr<gtsam::PreintegratedImuMeasurements>*> Collector_gtsamPreintegratedImuMeasurements;
static Collector_gtsamPreintegratedImuMeasurements collector_gtsamPreintegratedImuMeasurements;
typedef std::set<boost::shared_ptr<gtsam::ImuFactor>*> Collector_gtsamImuFactor;
static Collector_gtsamImuFactor collector_gtsamImuFactor;
typedef std::set<boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements>*> Collector_gtsamPreintegratedCombinedMeasurements;
static Collector_gtsamPreintegratedCombinedMeasurements collector_gtsamPreintegratedCombinedMeasurements;
typedef std::set<boost::shared_ptr<gtsam::CombinedImuFactor>*> Collector_gtsamCombinedImuFactor;
static Collector_gtsamCombinedImuFactor collector_gtsamCombinedImuFactor;
typedef std::set<boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements>*> Collector_gtsamPreintegratedAhrsMeasurements;
static Collector_gtsamPreintegratedAhrsMeasurements collector_gtsamPreintegratedAhrsMeasurements;
typedef std::set<boost::shared_ptr<gtsam::AHRSFactor>*> Collector_gtsamAHRSFactor;
static Collector_gtsamAHRSFactor collector_gtsamAHRSFactor;
typedef std::set<boost::shared_ptr<gtsam::Rot3AttitudeFactor>*> Collector_gtsamRot3AttitudeFactor;
static Collector_gtsamRot3AttitudeFactor collector_gtsamRot3AttitudeFactor;
typedef std::set<boost::shared_ptr<gtsam::Pose3AttitudeFactor>*> Collector_gtsamPose3AttitudeFactor;
static Collector_gtsamPose3AttitudeFactor collector_gtsamPose3AttitudeFactor;
typedef std::set<boost::shared_ptr<gtsam::RedirectCout>*> Collector_gtsamRedirectCout;
static Collector_gtsamRedirectCout collector_gtsamRedirectCout;
typedef std::set<boost::shared_ptr<gtsam::PinholeCameraCal3_S2>*> Collector_gtsamPinholeCameraCal3_S2;
static Collector_gtsamPinholeCameraCal3_S2 collector_gtsamPinholeCameraCal3_S2;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorPosePoint2>*> Collector_gtsamRangeFactorPosePoint2;
static Collector_gtsamRangeFactorPosePoint2 collector_gtsamRangeFactorPosePoint2;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorPosePoint3>*> Collector_gtsamRangeFactorPosePoint3;
static Collector_gtsamRangeFactorPosePoint3 collector_gtsamRangeFactorPosePoint3;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorPose2>*> Collector_gtsamRangeFactorPose2;
static Collector_gtsamRangeFactorPose2 collector_gtsamRangeFactorPose2;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorPose3>*> Collector_gtsamRangeFactorPose3;
static Collector_gtsamRangeFactorPose3 collector_gtsamRangeFactorPose3;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>*> Collector_gtsamRangeFactorCalibratedCameraPoint;
static Collector_gtsamRangeFactorCalibratedCameraPoint collector_gtsamRangeFactorCalibratedCameraPoint;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint>*> Collector_gtsamRangeFactorSimpleCameraPoint;
static Collector_gtsamRangeFactorSimpleCameraPoint collector_gtsamRangeFactorSimpleCameraPoint;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorCalibratedCamera>*> Collector_gtsamRangeFactorCalibratedCamera;
static Collector_gtsamRangeFactorCalibratedCamera collector_gtsamRangeFactorCalibratedCamera;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorSimpleCamera>*> Collector_gtsamRangeFactorSimpleCamera;
static Collector_gtsamRangeFactorSimpleCamera collector_gtsamRangeFactorSimpleCamera;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>*> Collector_gtsamRangeFactorWithTransformPosePoint2;
static Collector_gtsamRangeFactorWithTransformPosePoint2 collector_gtsamRangeFactorWithTransformPosePoint2;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>*> Collector_gtsamRangeFactorWithTransformPosePoint3;
static Collector_gtsamRangeFactorWithTransformPosePoint3 collector_gtsamRangeFactorWithTransformPosePoint3;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorWithTransformPose2>*> Collector_gtsamRangeFactorWithTransformPose2;
static Collector_gtsamRangeFactorWithTransformPose2 collector_gtsamRangeFactorWithTransformPose2;
typedef std::set<boost::shared_ptr<gtsam::RangeFactorWithTransformPose3>*> Collector_gtsamRangeFactorWithTransformPose3;
static Collector_gtsamRangeFactorWithTransformPose3 collector_gtsamRangeFactorWithTransformPose3;
typedef std::set<boost::shared_ptr<gtsam::BearingFactor2D>*> Collector_gtsamBearingFactor2D;
static Collector_gtsamBearingFactor2D collector_gtsamBearingFactor2D;
typedef std::set<boost::shared_ptr<gtsam::BearingRangeFactor2D>*> Collector_gtsamBearingRangeFactor2D;
static Collector_gtsamBearingRangeFactor2D collector_gtsamBearingRangeFactor2D;
typedef std::set<boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2>*> Collector_gtsamGenericProjectionFactorCal3_S2;
static Collector_gtsamGenericProjectionFactorCal3_S2 collector_gtsamGenericProjectionFactorCal3_S2;
typedef std::set<boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2>*> Collector_gtsamGenericProjectionFactorCal3DS2;
static Collector_gtsamGenericProjectionFactorCal3DS2 collector_gtsamGenericProjectionFactorCal3DS2;
typedef std::set<boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2>*> Collector_gtsamGeneralSFMFactorCal3_S2;
static Collector_gtsamGeneralSFMFactorCal3_S2 collector_gtsamGeneralSFMFactorCal3_S2;
typedef std::set<boost::shared_ptr<gtsam::SmartProjectionPose3Factor>*> Collector_gtsamSmartProjectionPose3Factor;
static Collector_gtsamSmartProjectionPose3Factor collector_gtsamSmartProjectionPose3Factor;
typedef std::set<boost::shared_ptr<gtsam::GenericStereoFactor3D>*> Collector_gtsamGenericStereoFactor3D;
static Collector_gtsamGenericStereoFactor3D collector_gtsamGenericStereoFactor3D;
typedef std::set<boost::shared_ptr<gtsam::PoseTranslationPrior2D>*> Collector_gtsamPoseTranslationPrior2D;
static Collector_gtsamPoseTranslationPrior2D collector_gtsamPoseTranslationPrior2D;
typedef std::set<boost::shared_ptr<gtsam::PoseTranslationPrior3D>*> Collector_gtsamPoseTranslationPrior3D;
static Collector_gtsamPoseTranslationPrior3D collector_gtsamPoseTranslationPrior3D;
typedef std::set<boost::shared_ptr<gtsam::PoseRotationPrior2D>*> Collector_gtsamPoseRotationPrior2D;
static Collector_gtsamPoseRotationPrior2D collector_gtsamPoseRotationPrior2D;
typedef std::set<boost::shared_ptr<gtsam::PoseRotationPrior3D>*> Collector_gtsamPoseRotationPrior3D;
static Collector_gtsamPoseRotationPrior3D collector_gtsamPoseRotationPrior3D;

void _deleteAllObjects()
{
  mstream mout;
  std::streambuf *outbuf = std::cout.rdbuf(&mout);

  bool anyDeleted = false;
  { for(Collector_gtsamKeyList::iterator iter = collector_gtsamKeyList.begin();
      iter != collector_gtsamKeyList.end(); ) {
    delete *iter;
    collector_gtsamKeyList.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamKeySet::iterator iter = collector_gtsamKeySet.begin();
      iter != collector_gtsamKeySet.end(); ) {
    delete *iter;
    collector_gtsamKeySet.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamKeyVector::iterator iter = collector_gtsamKeyVector.begin();
      iter != collector_gtsamKeyVector.end(); ) {
    delete *iter;
    collector_gtsamKeyVector.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamKeyGroupMap::iterator iter = collector_gtsamKeyGroupMap.begin();
      iter != collector_gtsamKeyGroupMap.end(); ) {
    delete *iter;
    collector_gtsamKeyGroupMap.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamValue::iterator iter = collector_gtsamValue.begin();
      iter != collector_gtsamValue.end(); ) {
    delete *iter;
    collector_gtsamValue.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamLieScalar::iterator iter = collector_gtsamLieScalar.begin();
      iter != collector_gtsamLieScalar.end(); ) {
    delete *iter;
    collector_gtsamLieScalar.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamLieVector::iterator iter = collector_gtsamLieVector.begin();
      iter != collector_gtsamLieVector.end(); ) {
    delete *iter;
    collector_gtsamLieVector.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamLieMatrix::iterator iter = collector_gtsamLieMatrix.begin();
      iter != collector_gtsamLieMatrix.end(); ) {
    delete *iter;
    collector_gtsamLieMatrix.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPoint2::iterator iter = collector_gtsamPoint2.begin();
      iter != collector_gtsamPoint2.end(); ) {
    delete *iter;
    collector_gtsamPoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPoint2Vector::iterator iter = collector_gtsamPoint2Vector.begin();
      iter != collector_gtsamPoint2Vector.end(); ) {
    delete *iter;
    collector_gtsamPoint2Vector.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamStereoPoint2::iterator iter = collector_gtsamStereoPoint2.begin();
      iter != collector_gtsamStereoPoint2.end(); ) {
    delete *iter;
    collector_gtsamStereoPoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPoint3::iterator iter = collector_gtsamPoint3.begin();
      iter != collector_gtsamPoint3.end(); ) {
    delete *iter;
    collector_gtsamPoint3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRot2::iterator iter = collector_gtsamRot2.begin();
      iter != collector_gtsamRot2.end(); ) {
    delete *iter;
    collector_gtsamRot2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRot3::iterator iter = collector_gtsamRot3.begin();
      iter != collector_gtsamRot3.end(); ) {
    delete *iter;
    collector_gtsamRot3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPose2::iterator iter = collector_gtsamPose2.begin();
      iter != collector_gtsamPose2.end(); ) {
    delete *iter;
    collector_gtsamPose2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPose3::iterator iter = collector_gtsamPose3.begin();
      iter != collector_gtsamPose3.end(); ) {
    delete *iter;
    collector_gtsamPose3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPose3Vector::iterator iter = collector_gtsamPose3Vector.begin();
      iter != collector_gtsamPose3Vector.end(); ) {
    delete *iter;
    collector_gtsamPose3Vector.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamUnit3::iterator iter = collector_gtsamUnit3.begin();
      iter != collector_gtsamUnit3.end(); ) {
    delete *iter;
    collector_gtsamUnit3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamEssentialMatrix::iterator iter = collector_gtsamEssentialMatrix.begin();
      iter != collector_gtsamEssentialMatrix.end(); ) {
    delete *iter;
    collector_gtsamEssentialMatrix.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCal3_S2::iterator iter = collector_gtsamCal3_S2.begin();
      iter != collector_gtsamCal3_S2.end(); ) {
    delete *iter;
    collector_gtsamCal3_S2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCal3DS2_Base::iterator iter = collector_gtsamCal3DS2_Base.begin();
      iter != collector_gtsamCal3DS2_Base.end(); ) {
    delete *iter;
    collector_gtsamCal3DS2_Base.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCal3DS2::iterator iter = collector_gtsamCal3DS2.begin();
      iter != collector_gtsamCal3DS2.end(); ) {
    delete *iter;
    collector_gtsamCal3DS2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCal3Unified::iterator iter = collector_gtsamCal3Unified.begin();
      iter != collector_gtsamCal3Unified.end(); ) {
    delete *iter;
    collector_gtsamCal3Unified.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCal3_S2Stereo::iterator iter = collector_gtsamCal3_S2Stereo.begin();
      iter != collector_gtsamCal3_S2Stereo.end(); ) {
    delete *iter;
    collector_gtsamCal3_S2Stereo.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCal3Bundler::iterator iter = collector_gtsamCal3Bundler.begin();
      iter != collector_gtsamCal3Bundler.end(); ) {
    delete *iter;
    collector_gtsamCal3Bundler.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCalibratedCamera::iterator iter = collector_gtsamCalibratedCamera.begin();
      iter != collector_gtsamCalibratedCamera.end(); ) {
    delete *iter;
    collector_gtsamCalibratedCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSimpleCamera::iterator iter = collector_gtsamSimpleCamera.begin();
      iter != collector_gtsamSimpleCamera.end(); ) {
    delete *iter;
    collector_gtsamSimpleCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamStereoCamera::iterator iter = collector_gtsamStereoCamera.begin();
      iter != collector_gtsamStereoCamera.end(); ) {
    delete *iter;
    collector_gtsamStereoCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSymbolicFactor::iterator iter = collector_gtsamSymbolicFactor.begin();
      iter != collector_gtsamSymbolicFactor.end(); ) {
    delete *iter;
    collector_gtsamSymbolicFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSymbolicFactorGraph::iterator iter = collector_gtsamSymbolicFactorGraph.begin();
      iter != collector_gtsamSymbolicFactorGraph.end(); ) {
    delete *iter;
    collector_gtsamSymbolicFactorGraph.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSymbolicConditional::iterator iter = collector_gtsamSymbolicConditional.begin();
      iter != collector_gtsamSymbolicConditional.end(); ) {
    delete *iter;
    collector_gtsamSymbolicConditional.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSymbolicBayesNet::iterator iter = collector_gtsamSymbolicBayesNet.begin();
      iter != collector_gtsamSymbolicBayesNet.end(); ) {
    delete *iter;
    collector_gtsamSymbolicBayesNet.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSymbolicBayesTree::iterator iter = collector_gtsamSymbolicBayesTree.begin();
      iter != collector_gtsamSymbolicBayesTree.end(); ) {
    delete *iter;
    collector_gtsamSymbolicBayesTree.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamVariableIndex::iterator iter = collector_gtsamVariableIndex.begin();
      iter != collector_gtsamVariableIndex.end(); ) {
    delete *iter;
    collector_gtsamVariableIndex.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelBase::iterator iter = collector_gtsamnoiseModelBase.begin();
      iter != collector_gtsamnoiseModelBase.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelBase.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelGaussian::iterator iter = collector_gtsamnoiseModelGaussian.begin();
      iter != collector_gtsamnoiseModelGaussian.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelGaussian.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelDiagonal::iterator iter = collector_gtsamnoiseModelDiagonal.begin();
      iter != collector_gtsamnoiseModelDiagonal.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelDiagonal.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelConstrained::iterator iter = collector_gtsamnoiseModelConstrained.begin();
      iter != collector_gtsamnoiseModelConstrained.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelConstrained.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelIsotropic::iterator iter = collector_gtsamnoiseModelIsotropic.begin();
      iter != collector_gtsamnoiseModelIsotropic.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelIsotropic.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelUnit::iterator iter = collector_gtsamnoiseModelUnit.begin();
      iter != collector_gtsamnoiseModelUnit.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelUnit.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelmEstimatorBase::iterator iter = collector_gtsamnoiseModelmEstimatorBase.begin();
      iter != collector_gtsamnoiseModelmEstimatorBase.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelmEstimatorBase.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelmEstimatorNull::iterator iter = collector_gtsamnoiseModelmEstimatorNull.begin();
      iter != collector_gtsamnoiseModelmEstimatorNull.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelmEstimatorNull.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelmEstimatorFair::iterator iter = collector_gtsamnoiseModelmEstimatorFair.begin();
      iter != collector_gtsamnoiseModelmEstimatorFair.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelmEstimatorFair.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelmEstimatorHuber::iterator iter = collector_gtsamnoiseModelmEstimatorHuber.begin();
      iter != collector_gtsamnoiseModelmEstimatorHuber.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelmEstimatorHuber.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelmEstimatorTukey::iterator iter = collector_gtsamnoiseModelmEstimatorTukey.begin();
      iter != collector_gtsamnoiseModelmEstimatorTukey.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelmEstimatorTukey.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamnoiseModelRobust::iterator iter = collector_gtsamnoiseModelRobust.begin();
      iter != collector_gtsamnoiseModelRobust.end(); ) {
    delete *iter;
    collector_gtsamnoiseModelRobust.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSampler::iterator iter = collector_gtsamSampler.begin();
      iter != collector_gtsamSampler.end(); ) {
    delete *iter;
    collector_gtsamSampler.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamVectorValues::iterator iter = collector_gtsamVectorValues.begin();
      iter != collector_gtsamVectorValues.end(); ) {
    delete *iter;
    collector_gtsamVectorValues.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussianFactor::iterator iter = collector_gtsamGaussianFactor.begin();
      iter != collector_gtsamGaussianFactor.end(); ) {
    delete *iter;
    collector_gtsamGaussianFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamJacobianFactor::iterator iter = collector_gtsamJacobianFactor.begin();
      iter != collector_gtsamJacobianFactor.end(); ) {
    delete *iter;
    collector_gtsamJacobianFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamHessianFactor::iterator iter = collector_gtsamHessianFactor.begin();
      iter != collector_gtsamHessianFactor.end(); ) {
    delete *iter;
    collector_gtsamHessianFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussianFactorGraph::iterator iter = collector_gtsamGaussianFactorGraph.begin();
      iter != collector_gtsamGaussianFactorGraph.end(); ) {
    delete *iter;
    collector_gtsamGaussianFactorGraph.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussianConditional::iterator iter = collector_gtsamGaussianConditional.begin();
      iter != collector_gtsamGaussianConditional.end(); ) {
    delete *iter;
    collector_gtsamGaussianConditional.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussianDensity::iterator iter = collector_gtsamGaussianDensity.begin();
      iter != collector_gtsamGaussianDensity.end(); ) {
    delete *iter;
    collector_gtsamGaussianDensity.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussianBayesNet::iterator iter = collector_gtsamGaussianBayesNet.begin();
      iter != collector_gtsamGaussianBayesNet.end(); ) {
    delete *iter;
    collector_gtsamGaussianBayesNet.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussianBayesTree::iterator iter = collector_gtsamGaussianBayesTree.begin();
      iter != collector_gtsamGaussianBayesTree.end(); ) {
    delete *iter;
    collector_gtsamGaussianBayesTree.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamErrors::iterator iter = collector_gtsamErrors.begin();
      iter != collector_gtsamErrors.end(); ) {
    delete *iter;
    collector_gtsamErrors.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussianISAM::iterator iter = collector_gtsamGaussianISAM.begin();
      iter != collector_gtsamGaussianISAM.end(); ) {
    delete *iter;
    collector_gtsamGaussianISAM.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamIterativeOptimizationParameters::iterator iter = collector_gtsamIterativeOptimizationParameters.begin();
      iter != collector_gtsamIterativeOptimizationParameters.end(); ) {
    delete *iter;
    collector_gtsamIterativeOptimizationParameters.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamConjugateGradientParameters::iterator iter = collector_gtsamConjugateGradientParameters.begin();
      iter != collector_gtsamConjugateGradientParameters.end(); ) {
    delete *iter;
    collector_gtsamConjugateGradientParameters.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSubgraphSolverParameters::iterator iter = collector_gtsamSubgraphSolverParameters.begin();
      iter != collector_gtsamSubgraphSolverParameters.end(); ) {
    delete *iter;
    collector_gtsamSubgraphSolverParameters.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSubgraphSolver::iterator iter = collector_gtsamSubgraphSolver.begin();
      iter != collector_gtsamSubgraphSolver.end(); ) {
    delete *iter;
    collector_gtsamSubgraphSolver.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamKalmanFilter::iterator iter = collector_gtsamKalmanFilter.begin();
      iter != collector_gtsamKalmanFilter.end(); ) {
    delete *iter;
    collector_gtsamKalmanFilter.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamLabeledSymbol::iterator iter = collector_gtsamLabeledSymbol.begin();
      iter != collector_gtsamLabeledSymbol.end(); ) {
    delete *iter;
    collector_gtsamLabeledSymbol.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamOrdering::iterator iter = collector_gtsamOrdering.begin();
      iter != collector_gtsamOrdering.end(); ) {
    delete *iter;
    collector_gtsamOrdering.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearFactorGraph::iterator iter = collector_gtsamNonlinearFactorGraph.begin();
      iter != collector_gtsamNonlinearFactorGraph.end(); ) {
    delete *iter;
    collector_gtsamNonlinearFactorGraph.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearFactor::iterator iter = collector_gtsamNonlinearFactor.begin();
      iter != collector_gtsamNonlinearFactor.end(); ) {
    delete *iter;
    collector_gtsamNonlinearFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNoiseModelFactor::iterator iter = collector_gtsamNoiseModelFactor.begin();
      iter != collector_gtsamNoiseModelFactor.end(); ) {
    delete *iter;
    collector_gtsamNoiseModelFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamValues::iterator iter = collector_gtsamValues.begin();
      iter != collector_gtsamValues.end(); ) {
    delete *iter;
    collector_gtsamValues.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamMarginals::iterator iter = collector_gtsamMarginals.begin();
      iter != collector_gtsamMarginals.end(); ) {
    delete *iter;
    collector_gtsamMarginals.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamJointMarginal::iterator iter = collector_gtsamJointMarginal.begin();
      iter != collector_gtsamJointMarginal.end(); ) {
    delete *iter;
    collector_gtsamJointMarginal.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamLinearContainerFactor::iterator iter = collector_gtsamLinearContainerFactor.begin();
      iter != collector_gtsamLinearContainerFactor.end(); ) {
    delete *iter;
    collector_gtsamLinearContainerFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearOptimizerParams::iterator iter = collector_gtsamNonlinearOptimizerParams.begin();
      iter != collector_gtsamNonlinearOptimizerParams.end(); ) {
    delete *iter;
    collector_gtsamNonlinearOptimizerParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussNewtonParams::iterator iter = collector_gtsamGaussNewtonParams.begin();
      iter != collector_gtsamGaussNewtonParams.end(); ) {
    delete *iter;
    collector_gtsamGaussNewtonParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamLevenbergMarquardtParams::iterator iter = collector_gtsamLevenbergMarquardtParams.begin();
      iter != collector_gtsamLevenbergMarquardtParams.end(); ) {
    delete *iter;
    collector_gtsamLevenbergMarquardtParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamDoglegParams::iterator iter = collector_gtsamDoglegParams.begin();
      iter != collector_gtsamDoglegParams.end(); ) {
    delete *iter;
    collector_gtsamDoglegParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearOptimizer::iterator iter = collector_gtsamNonlinearOptimizer.begin();
      iter != collector_gtsamNonlinearOptimizer.end(); ) {
    delete *iter;
    collector_gtsamNonlinearOptimizer.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGaussNewtonOptimizer::iterator iter = collector_gtsamGaussNewtonOptimizer.begin();
      iter != collector_gtsamGaussNewtonOptimizer.end(); ) {
    delete *iter;
    collector_gtsamGaussNewtonOptimizer.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamDoglegOptimizer::iterator iter = collector_gtsamDoglegOptimizer.begin();
      iter != collector_gtsamDoglegOptimizer.end(); ) {
    delete *iter;
    collector_gtsamDoglegOptimizer.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamLevenbergMarquardtOptimizer::iterator iter = collector_gtsamLevenbergMarquardtOptimizer.begin();
      iter != collector_gtsamLevenbergMarquardtOptimizer.end(); ) {
    delete *iter;
    collector_gtsamLevenbergMarquardtOptimizer.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2GaussNewtonParams::iterator iter = collector_gtsamISAM2GaussNewtonParams.begin();
      iter != collector_gtsamISAM2GaussNewtonParams.end(); ) {
    delete *iter;
    collector_gtsamISAM2GaussNewtonParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2DoglegParams::iterator iter = collector_gtsamISAM2DoglegParams.begin();
      iter != collector_gtsamISAM2DoglegParams.end(); ) {
    delete *iter;
    collector_gtsamISAM2DoglegParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2ThresholdMapValue::iterator iter = collector_gtsamISAM2ThresholdMapValue.begin();
      iter != collector_gtsamISAM2ThresholdMapValue.end(); ) {
    delete *iter;
    collector_gtsamISAM2ThresholdMapValue.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2ThresholdMap::iterator iter = collector_gtsamISAM2ThresholdMap.begin();
      iter != collector_gtsamISAM2ThresholdMap.end(); ) {
    delete *iter;
    collector_gtsamISAM2ThresholdMap.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2Params::iterator iter = collector_gtsamISAM2Params.begin();
      iter != collector_gtsamISAM2Params.end(); ) {
    delete *iter;
    collector_gtsamISAM2Params.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2Clique::iterator iter = collector_gtsamISAM2Clique.begin();
      iter != collector_gtsamISAM2Clique.end(); ) {
    delete *iter;
    collector_gtsamISAM2Clique.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2Result::iterator iter = collector_gtsamISAM2Result.begin();
      iter != collector_gtsamISAM2Result.end(); ) {
    delete *iter;
    collector_gtsamISAM2Result.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamFactorIndices::iterator iter = collector_gtsamFactorIndices.begin();
      iter != collector_gtsamFactorIndices.end(); ) {
    delete *iter;
    collector_gtsamFactorIndices.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamISAM2::iterator iter = collector_gtsamISAM2.begin();
      iter != collector_gtsamISAM2.end(); ) {
    delete *iter;
    collector_gtsamISAM2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearISAM::iterator iter = collector_gtsamNonlinearISAM.begin();
      iter != collector_gtsamNonlinearISAM.end(); ) {
    delete *iter;
    collector_gtsamNonlinearISAM.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorVector::iterator iter = collector_gtsamPriorFactorVector.begin();
      iter != collector_gtsamPriorFactorVector.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorVector.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorPoint2::iterator iter = collector_gtsamPriorFactorPoint2.begin();
      iter != collector_gtsamPriorFactorPoint2.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorPoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorStereoPoint2::iterator iter = collector_gtsamPriorFactorStereoPoint2.begin();
      iter != collector_gtsamPriorFactorStereoPoint2.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorStereoPoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorPoint3::iterator iter = collector_gtsamPriorFactorPoint3.begin();
      iter != collector_gtsamPriorFactorPoint3.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorPoint3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorRot2::iterator iter = collector_gtsamPriorFactorRot2.begin();
      iter != collector_gtsamPriorFactorRot2.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorRot2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorRot3::iterator iter = collector_gtsamPriorFactorRot3.begin();
      iter != collector_gtsamPriorFactorRot3.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorRot3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorPose2::iterator iter = collector_gtsamPriorFactorPose2.begin();
      iter != collector_gtsamPriorFactorPose2.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorPose2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorPose3::iterator iter = collector_gtsamPriorFactorPose3.begin();
      iter != collector_gtsamPriorFactorPose3.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorPose3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorCal3_S2::iterator iter = collector_gtsamPriorFactorCal3_S2.begin();
      iter != collector_gtsamPriorFactorCal3_S2.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorCal3_S2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorCalibratedCamera::iterator iter = collector_gtsamPriorFactorCalibratedCamera.begin();
      iter != collector_gtsamPriorFactorCalibratedCamera.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorCalibratedCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorSimpleCamera::iterator iter = collector_gtsamPriorFactorSimpleCamera.begin();
      iter != collector_gtsamPriorFactorSimpleCamera.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorSimpleCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPriorFactorConstantBias::iterator iter = collector_gtsamPriorFactorConstantBias.begin();
      iter != collector_gtsamPriorFactorConstantBias.end(); ) {
    delete *iter;
    collector_gtsamPriorFactorConstantBias.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBetweenFactorPoint2::iterator iter = collector_gtsamBetweenFactorPoint2.begin();
      iter != collector_gtsamBetweenFactorPoint2.end(); ) {
    delete *iter;
    collector_gtsamBetweenFactorPoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBetweenFactorPoint3::iterator iter = collector_gtsamBetweenFactorPoint3.begin();
      iter != collector_gtsamBetweenFactorPoint3.end(); ) {
    delete *iter;
    collector_gtsamBetweenFactorPoint3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBetweenFactorRot2::iterator iter = collector_gtsamBetweenFactorRot2.begin();
      iter != collector_gtsamBetweenFactorRot2.end(); ) {
    delete *iter;
    collector_gtsamBetweenFactorRot2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBetweenFactorRot3::iterator iter = collector_gtsamBetweenFactorRot3.begin();
      iter != collector_gtsamBetweenFactorRot3.end(); ) {
    delete *iter;
    collector_gtsamBetweenFactorRot3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBetweenFactorPose2::iterator iter = collector_gtsamBetweenFactorPose2.begin();
      iter != collector_gtsamBetweenFactorPose2.end(); ) {
    delete *iter;
    collector_gtsamBetweenFactorPose2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBetweenFactorPose3::iterator iter = collector_gtsamBetweenFactorPose3.begin();
      iter != collector_gtsamBetweenFactorPose3.end(); ) {
    delete *iter;
    collector_gtsamBetweenFactorPose3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBetweenFactorConstantBias::iterator iter = collector_gtsamBetweenFactorConstantBias.begin();
      iter != collector_gtsamBetweenFactorConstantBias.end(); ) {
    delete *iter;
    collector_gtsamBetweenFactorConstantBias.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityPoint2::iterator iter = collector_gtsamNonlinearEqualityPoint2.begin();
      iter != collector_gtsamNonlinearEqualityPoint2.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityPoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityStereoPoint2::iterator iter = collector_gtsamNonlinearEqualityStereoPoint2.begin();
      iter != collector_gtsamNonlinearEqualityStereoPoint2.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityStereoPoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityPoint3::iterator iter = collector_gtsamNonlinearEqualityPoint3.begin();
      iter != collector_gtsamNonlinearEqualityPoint3.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityPoint3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityRot2::iterator iter = collector_gtsamNonlinearEqualityRot2.begin();
      iter != collector_gtsamNonlinearEqualityRot2.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityRot2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityRot3::iterator iter = collector_gtsamNonlinearEqualityRot3.begin();
      iter != collector_gtsamNonlinearEqualityRot3.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityRot3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityPose2::iterator iter = collector_gtsamNonlinearEqualityPose2.begin();
      iter != collector_gtsamNonlinearEqualityPose2.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityPose2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityPose3::iterator iter = collector_gtsamNonlinearEqualityPose3.begin();
      iter != collector_gtsamNonlinearEqualityPose3.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityPose3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityCal3_S2::iterator iter = collector_gtsamNonlinearEqualityCal3_S2.begin();
      iter != collector_gtsamNonlinearEqualityCal3_S2.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityCal3_S2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityCalibratedCamera::iterator iter = collector_gtsamNonlinearEqualityCalibratedCamera.begin();
      iter != collector_gtsamNonlinearEqualityCalibratedCamera.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityCalibratedCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualitySimpleCamera::iterator iter = collector_gtsamNonlinearEqualitySimpleCamera.begin();
      iter != collector_gtsamNonlinearEqualitySimpleCamera.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualitySimpleCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNonlinearEqualityConstantBias::iterator iter = collector_gtsamNonlinearEqualityConstantBias.begin();
      iter != collector_gtsamNonlinearEqualityConstantBias.end(); ) {
    delete *iter;
    collector_gtsamNonlinearEqualityConstantBias.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGeneralSFMFactor2Cal3_S2::iterator iter = collector_gtsamGeneralSFMFactor2Cal3_S2.begin();
      iter != collector_gtsamGeneralSFMFactor2Cal3_S2.end(); ) {
    delete *iter;
    collector_gtsamGeneralSFMFactor2Cal3_S2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSmartProjectionParams::iterator iter = collector_gtsamSmartProjectionParams.begin();
      iter != collector_gtsamSmartProjectionParams.end(); ) {
    delete *iter;
    collector_gtsamSmartProjectionParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamEssentialMatrixFactor::iterator iter = collector_gtsamEssentialMatrixFactor.begin();
      iter != collector_gtsamEssentialMatrixFactor.end(); ) {
    delete *iter;
    collector_gtsamEssentialMatrixFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamimuBiasConstantBias::iterator iter = collector_gtsamimuBiasConstantBias.begin();
      iter != collector_gtsamimuBiasConstantBias.end(); ) {
    delete *iter;
    collector_gtsamimuBiasConstantBias.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamNavState::iterator iter = collector_gtsamNavState.begin();
      iter != collector_gtsamNavState.end(); ) {
    delete *iter;
    collector_gtsamNavState.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPreintegratedRotationParams::iterator iter = collector_gtsamPreintegratedRotationParams.begin();
      iter != collector_gtsamPreintegratedRotationParams.end(); ) {
    delete *iter;
    collector_gtsamPreintegratedRotationParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPreintegrationParams::iterator iter = collector_gtsamPreintegrationParams.begin();
      iter != collector_gtsamPreintegrationParams.end(); ) {
    delete *iter;
    collector_gtsamPreintegrationParams.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPreintegratedImuMeasurements::iterator iter = collector_gtsamPreintegratedImuMeasurements.begin();
      iter != collector_gtsamPreintegratedImuMeasurements.end(); ) {
    delete *iter;
    collector_gtsamPreintegratedImuMeasurements.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamImuFactor::iterator iter = collector_gtsamImuFactor.begin();
      iter != collector_gtsamImuFactor.end(); ) {
    delete *iter;
    collector_gtsamImuFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPreintegratedCombinedMeasurements::iterator iter = collector_gtsamPreintegratedCombinedMeasurements.begin();
      iter != collector_gtsamPreintegratedCombinedMeasurements.end(); ) {
    delete *iter;
    collector_gtsamPreintegratedCombinedMeasurements.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamCombinedImuFactor::iterator iter = collector_gtsamCombinedImuFactor.begin();
      iter != collector_gtsamCombinedImuFactor.end(); ) {
    delete *iter;
    collector_gtsamCombinedImuFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPreintegratedAhrsMeasurements::iterator iter = collector_gtsamPreintegratedAhrsMeasurements.begin();
      iter != collector_gtsamPreintegratedAhrsMeasurements.end(); ) {
    delete *iter;
    collector_gtsamPreintegratedAhrsMeasurements.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamAHRSFactor::iterator iter = collector_gtsamAHRSFactor.begin();
      iter != collector_gtsamAHRSFactor.end(); ) {
    delete *iter;
    collector_gtsamAHRSFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRot3AttitudeFactor::iterator iter = collector_gtsamRot3AttitudeFactor.begin();
      iter != collector_gtsamRot3AttitudeFactor.end(); ) {
    delete *iter;
    collector_gtsamRot3AttitudeFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPose3AttitudeFactor::iterator iter = collector_gtsamPose3AttitudeFactor.begin();
      iter != collector_gtsamPose3AttitudeFactor.end(); ) {
    delete *iter;
    collector_gtsamPose3AttitudeFactor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRedirectCout::iterator iter = collector_gtsamRedirectCout.begin();
      iter != collector_gtsamRedirectCout.end(); ) {
    delete *iter;
    collector_gtsamRedirectCout.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPinholeCameraCal3_S2::iterator iter = collector_gtsamPinholeCameraCal3_S2.begin();
      iter != collector_gtsamPinholeCameraCal3_S2.end(); ) {
    delete *iter;
    collector_gtsamPinholeCameraCal3_S2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorPosePoint2::iterator iter = collector_gtsamRangeFactorPosePoint2.begin();
      iter != collector_gtsamRangeFactorPosePoint2.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorPosePoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorPosePoint3::iterator iter = collector_gtsamRangeFactorPosePoint3.begin();
      iter != collector_gtsamRangeFactorPosePoint3.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorPosePoint3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorPose2::iterator iter = collector_gtsamRangeFactorPose2.begin();
      iter != collector_gtsamRangeFactorPose2.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorPose2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorPose3::iterator iter = collector_gtsamRangeFactorPose3.begin();
      iter != collector_gtsamRangeFactorPose3.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorPose3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorCalibratedCameraPoint::iterator iter = collector_gtsamRangeFactorCalibratedCameraPoint.begin();
      iter != collector_gtsamRangeFactorCalibratedCameraPoint.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorCalibratedCameraPoint.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorSimpleCameraPoint::iterator iter = collector_gtsamRangeFactorSimpleCameraPoint.begin();
      iter != collector_gtsamRangeFactorSimpleCameraPoint.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorSimpleCameraPoint.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorCalibratedCamera::iterator iter = collector_gtsamRangeFactorCalibratedCamera.begin();
      iter != collector_gtsamRangeFactorCalibratedCamera.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorCalibratedCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorSimpleCamera::iterator iter = collector_gtsamRangeFactorSimpleCamera.begin();
      iter != collector_gtsamRangeFactorSimpleCamera.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorSimpleCamera.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorWithTransformPosePoint2::iterator iter = collector_gtsamRangeFactorWithTransformPosePoint2.begin();
      iter != collector_gtsamRangeFactorWithTransformPosePoint2.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorWithTransformPosePoint2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorWithTransformPosePoint3::iterator iter = collector_gtsamRangeFactorWithTransformPosePoint3.begin();
      iter != collector_gtsamRangeFactorWithTransformPosePoint3.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorWithTransformPosePoint3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorWithTransformPose2::iterator iter = collector_gtsamRangeFactorWithTransformPose2.begin();
      iter != collector_gtsamRangeFactorWithTransformPose2.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorWithTransformPose2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamRangeFactorWithTransformPose3::iterator iter = collector_gtsamRangeFactorWithTransformPose3.begin();
      iter != collector_gtsamRangeFactorWithTransformPose3.end(); ) {
    delete *iter;
    collector_gtsamRangeFactorWithTransformPose3.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBearingFactor2D::iterator iter = collector_gtsamBearingFactor2D.begin();
      iter != collector_gtsamBearingFactor2D.end(); ) {
    delete *iter;
    collector_gtsamBearingFactor2D.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamBearingRangeFactor2D::iterator iter = collector_gtsamBearingRangeFactor2D.begin();
      iter != collector_gtsamBearingRangeFactor2D.end(); ) {
    delete *iter;
    collector_gtsamBearingRangeFactor2D.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGenericProjectionFactorCal3_S2::iterator iter = collector_gtsamGenericProjectionFactorCal3_S2.begin();
      iter != collector_gtsamGenericProjectionFactorCal3_S2.end(); ) {
    delete *iter;
    collector_gtsamGenericProjectionFactorCal3_S2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGenericProjectionFactorCal3DS2::iterator iter = collector_gtsamGenericProjectionFactorCal3DS2.begin();
      iter != collector_gtsamGenericProjectionFactorCal3DS2.end(); ) {
    delete *iter;
    collector_gtsamGenericProjectionFactorCal3DS2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGeneralSFMFactorCal3_S2::iterator iter = collector_gtsamGeneralSFMFactorCal3_S2.begin();
      iter != collector_gtsamGeneralSFMFactorCal3_S2.end(); ) {
    delete *iter;
    collector_gtsamGeneralSFMFactorCal3_S2.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamSmartProjectionPose3Factor::iterator iter = collector_gtsamSmartProjectionPose3Factor.begin();
      iter != collector_gtsamSmartProjectionPose3Factor.end(); ) {
    delete *iter;
    collector_gtsamSmartProjectionPose3Factor.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamGenericStereoFactor3D::iterator iter = collector_gtsamGenericStereoFactor3D.begin();
      iter != collector_gtsamGenericStereoFactor3D.end(); ) {
    delete *iter;
    collector_gtsamGenericStereoFactor3D.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPoseTranslationPrior2D::iterator iter = collector_gtsamPoseTranslationPrior2D.begin();
      iter != collector_gtsamPoseTranslationPrior2D.end(); ) {
    delete *iter;
    collector_gtsamPoseTranslationPrior2D.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPoseTranslationPrior3D::iterator iter = collector_gtsamPoseTranslationPrior3D.begin();
      iter != collector_gtsamPoseTranslationPrior3D.end(); ) {
    delete *iter;
    collector_gtsamPoseTranslationPrior3D.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPoseRotationPrior2D::iterator iter = collector_gtsamPoseRotationPrior2D.begin();
      iter != collector_gtsamPoseRotationPrior2D.end(); ) {
    delete *iter;
    collector_gtsamPoseRotationPrior2D.erase(iter++);
    anyDeleted = true;
  } }
  { for(Collector_gtsamPoseRotationPrior3D::iterator iter = collector_gtsamPoseRotationPrior3D.begin();
      iter != collector_gtsamPoseRotationPrior3D.end(); ) {
    delete *iter;
    collector_gtsamPoseRotationPrior3D.erase(iter++);
    anyDeleted = true;
  } }
  if(anyDeleted)
    cout <<
      "WARNING:  Wrap modules with variables in the workspace have been reloaded due to\n"
      "calling destructors, call 'clear all' again if you plan to now recompile a wrap\n"
      "module, so that your recompiled module is used instead of the old one." << endl;
  std::cout.rdbuf(outbuf);
}

void _gtsam_RTTIRegister() {
  const mxArray *alreadyCreated = mexGetVariablePtr("global", "gtsam_gtsam_rttiRegistry_created");
  if(!alreadyCreated) {
    std::map<std::string, std::string> types;
    types.insert(std::make_pair(typeid(gtsam::Value).name(), "gtsam.Value"));
    types.insert(std::make_pair(typeid(gtsam::Cal3DS2_Base).name(), "gtsam.Cal3DS2_Base"));
    types.insert(std::make_pair(typeid(gtsam::Cal3DS2).name(), "gtsam.Cal3DS2"));
    types.insert(std::make_pair(typeid(gtsam::Cal3Unified).name(), "gtsam.Cal3Unified"));
    types.insert(std::make_pair(typeid(gtsam::SimpleCamera).name(), "gtsam.SimpleCamera"));
    types.insert(std::make_pair(typeid(gtsam::SymbolicFactor).name(), "gtsam.SymbolicFactor"));
    types.insert(std::make_pair(typeid(gtsam::SymbolicFactorGraph).name(), "gtsam.SymbolicFactorGraph"));
    types.insert(std::make_pair(typeid(gtsam::SymbolicConditional).name(), "gtsam.SymbolicConditional"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::Base).name(), "gtsam.noiseModel.Base"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::Gaussian).name(), "gtsam.noiseModel.Gaussian"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::Diagonal).name(), "gtsam.noiseModel.Diagonal"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::Constrained).name(), "gtsam.noiseModel.Constrained"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::Isotropic).name(), "gtsam.noiseModel.Isotropic"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::Unit).name(), "gtsam.noiseModel.Unit"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::mEstimator::Base).name(), "gtsam.noiseModel.mEstimator.Base"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::mEstimator::Null).name(), "gtsam.noiseModel.mEstimator.Null"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::mEstimator::Fair).name(), "gtsam.noiseModel.mEstimator.Fair"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::mEstimator::Huber).name(), "gtsam.noiseModel.mEstimator.Huber"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::mEstimator::Tukey).name(), "gtsam.noiseModel.mEstimator.Tukey"));
    types.insert(std::make_pair(typeid(gtsam::noiseModel::Robust).name(), "gtsam.noiseModel.Robust"));
    types.insert(std::make_pair(typeid(gtsam::GaussianFactor).name(), "gtsam.GaussianFactor"));
    types.insert(std::make_pair(typeid(gtsam::JacobianFactor).name(), "gtsam.JacobianFactor"));
    types.insert(std::make_pair(typeid(gtsam::HessianFactor).name(), "gtsam.HessianFactor"));
    types.insert(std::make_pair(typeid(gtsam::GaussianConditional).name(), "gtsam.GaussianConditional"));
    types.insert(std::make_pair(typeid(gtsam::GaussianDensity).name(), "gtsam.GaussianDensity"));
    types.insert(std::make_pair(typeid(gtsam::GaussianBayesNet).name(), "gtsam.GaussianBayesNet"));
    types.insert(std::make_pair(typeid(gtsam::GaussianBayesTree).name(), "gtsam.GaussianBayesTree"));
    types.insert(std::make_pair(typeid(gtsam::IterativeOptimizationParameters).name(), "gtsam.IterativeOptimizationParameters"));
    types.insert(std::make_pair(typeid(gtsam::ConjugateGradientParameters).name(), "gtsam.ConjugateGradientParameters"));
    types.insert(std::make_pair(typeid(gtsam::SubgraphSolverParameters).name(), "gtsam.SubgraphSolverParameters"));
    types.insert(std::make_pair(typeid(gtsam::SubgraphSolver).name(), "gtsam.SubgraphSolver"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearFactor).name(), "gtsam.NonlinearFactor"));
    types.insert(std::make_pair(typeid(gtsam::NoiseModelFactor).name(), "gtsam.NoiseModelFactor"));
    types.insert(std::make_pair(typeid(gtsam::LinearContainerFactor).name(), "gtsam.LinearContainerFactor"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearOptimizerParams).name(), "gtsam.NonlinearOptimizerParams"));
    types.insert(std::make_pair(typeid(gtsam::GaussNewtonParams).name(), "gtsam.GaussNewtonParams"));
    types.insert(std::make_pair(typeid(gtsam::LevenbergMarquardtParams).name(), "gtsam.LevenbergMarquardtParams"));
    types.insert(std::make_pair(typeid(gtsam::DoglegParams).name(), "gtsam.DoglegParams"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearOptimizer).name(), "gtsam.NonlinearOptimizer"));
    types.insert(std::make_pair(typeid(gtsam::GaussNewtonOptimizer).name(), "gtsam.GaussNewtonOptimizer"));
    types.insert(std::make_pair(typeid(gtsam::DoglegOptimizer).name(), "gtsam.DoglegOptimizer"));
    types.insert(std::make_pair(typeid(gtsam::LevenbergMarquardtOptimizer).name(), "gtsam.LevenbergMarquardtOptimizer"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorVector).name(), "gtsam.PriorFactorVector"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorPoint2).name(), "gtsam.PriorFactorPoint2"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorStereoPoint2).name(), "gtsam.PriorFactorStereoPoint2"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorPoint3).name(), "gtsam.PriorFactorPoint3"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorRot2).name(), "gtsam.PriorFactorRot2"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorRot3).name(), "gtsam.PriorFactorRot3"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorPose2).name(), "gtsam.PriorFactorPose2"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorPose3).name(), "gtsam.PriorFactorPose3"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorCal3_S2).name(), "gtsam.PriorFactorCal3_S2"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorCalibratedCamera).name(), "gtsam.PriorFactorCalibratedCamera"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorSimpleCamera).name(), "gtsam.PriorFactorSimpleCamera"));
    types.insert(std::make_pair(typeid(gtsam::PriorFactorConstantBias).name(), "gtsam.PriorFactorConstantBias"));
    types.insert(std::make_pair(typeid(gtsam::BetweenFactorPoint2).name(), "gtsam.BetweenFactorPoint2"));
    types.insert(std::make_pair(typeid(gtsam::BetweenFactorPoint3).name(), "gtsam.BetweenFactorPoint3"));
    types.insert(std::make_pair(typeid(gtsam::BetweenFactorRot2).name(), "gtsam.BetweenFactorRot2"));
    types.insert(std::make_pair(typeid(gtsam::BetweenFactorRot3).name(), "gtsam.BetweenFactorRot3"));
    types.insert(std::make_pair(typeid(gtsam::BetweenFactorPose2).name(), "gtsam.BetweenFactorPose2"));
    types.insert(std::make_pair(typeid(gtsam::BetweenFactorPose3).name(), "gtsam.BetweenFactorPose3"));
    types.insert(std::make_pair(typeid(gtsam::BetweenFactorConstantBias).name(), "gtsam.BetweenFactorConstantBias"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityPoint2).name(), "gtsam.NonlinearEqualityPoint2"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityStereoPoint2).name(), "gtsam.NonlinearEqualityStereoPoint2"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityPoint3).name(), "gtsam.NonlinearEqualityPoint3"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityRot2).name(), "gtsam.NonlinearEqualityRot2"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityRot3).name(), "gtsam.NonlinearEqualityRot3"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityPose2).name(), "gtsam.NonlinearEqualityPose2"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityPose3).name(), "gtsam.NonlinearEqualityPose3"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityCal3_S2).name(), "gtsam.NonlinearEqualityCal3_S2"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityCalibratedCamera).name(), "gtsam.NonlinearEqualityCalibratedCamera"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualitySimpleCamera).name(), "gtsam.NonlinearEqualitySimpleCamera"));
    types.insert(std::make_pair(typeid(gtsam::NonlinearEqualityConstantBias).name(), "gtsam.NonlinearEqualityConstantBias"));
    types.insert(std::make_pair(typeid(gtsam::GeneralSFMFactor2Cal3_S2).name(), "gtsam.GeneralSFMFactor2Cal3_S2"));
    types.insert(std::make_pair(typeid(gtsam::EssentialMatrixFactor).name(), "gtsam.EssentialMatrixFactor"));
    types.insert(std::make_pair(typeid(gtsam::PreintegratedRotationParams).name(), "gtsam.PreintegratedRotationParams"));
    types.insert(std::make_pair(typeid(gtsam::PreintegrationParams).name(), "gtsam.PreintegrationParams"));
    types.insert(std::make_pair(typeid(gtsam::ImuFactor).name(), "gtsam.ImuFactor"));
    types.insert(std::make_pair(typeid(gtsam::CombinedImuFactor).name(), "gtsam.CombinedImuFactor"));
    types.insert(std::make_pair(typeid(gtsam::AHRSFactor).name(), "gtsam.AHRSFactor"));
    types.insert(std::make_pair(typeid(gtsam::Rot3AttitudeFactor).name(), "gtsam.Rot3AttitudeFactor"));
    types.insert(std::make_pair(typeid(gtsam::Pose3AttitudeFactor).name(), "gtsam.Pose3AttitudeFactor"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorPosePoint2).name(), "gtsam.RangeFactorPosePoint2"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorPosePoint3).name(), "gtsam.RangeFactorPosePoint3"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorPose2).name(), "gtsam.RangeFactorPose2"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorPose3).name(), "gtsam.RangeFactorPose3"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorCalibratedCameraPoint).name(), "gtsam.RangeFactorCalibratedCameraPoint"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorSimpleCameraPoint).name(), "gtsam.RangeFactorSimpleCameraPoint"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorCalibratedCamera).name(), "gtsam.RangeFactorCalibratedCamera"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorSimpleCamera).name(), "gtsam.RangeFactorSimpleCamera"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorWithTransformPosePoint2).name(), "gtsam.RangeFactorWithTransformPosePoint2"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorWithTransformPosePoint3).name(), "gtsam.RangeFactorWithTransformPosePoint3"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorWithTransformPose2).name(), "gtsam.RangeFactorWithTransformPose2"));
    types.insert(std::make_pair(typeid(gtsam::RangeFactorWithTransformPose3).name(), "gtsam.RangeFactorWithTransformPose3"));
    types.insert(std::make_pair(typeid(gtsam::BearingFactor2D).name(), "gtsam.BearingFactor2D"));
    types.insert(std::make_pair(typeid(gtsam::BearingRangeFactor2D).name(), "gtsam.BearingRangeFactor2D"));
    types.insert(std::make_pair(typeid(gtsam::GenericProjectionFactorCal3_S2).name(), "gtsam.GenericProjectionFactorCal3_S2"));
    types.insert(std::make_pair(typeid(gtsam::GenericProjectionFactorCal3DS2).name(), "gtsam.GenericProjectionFactorCal3DS2"));
    types.insert(std::make_pair(typeid(gtsam::GeneralSFMFactorCal3_S2).name(), "gtsam.GeneralSFMFactorCal3_S2"));
    types.insert(std::make_pair(typeid(gtsam::SmartProjectionPose3Factor).name(), "gtsam.SmartProjectionPose3Factor"));
    types.insert(std::make_pair(typeid(gtsam::GenericStereoFactor3D).name(), "gtsam.GenericStereoFactor3D"));
    types.insert(std::make_pair(typeid(gtsam::PoseTranslationPrior2D).name(), "gtsam.PoseTranslationPrior2D"));
    types.insert(std::make_pair(typeid(gtsam::PoseTranslationPrior3D).name(), "gtsam.PoseTranslationPrior3D"));
    types.insert(std::make_pair(typeid(gtsam::PoseRotationPrior2D).name(), "gtsam.PoseRotationPrior2D"));
    types.insert(std::make_pair(typeid(gtsam::PoseRotationPrior3D).name(), "gtsam.PoseRotationPrior3D"));

    mxArray *registry = mexGetVariable("global", "gtsamwrap_rttiRegistry");
    if(!registry)
      registry = mxCreateStructMatrix(1, 1, 0, NULL);
    typedef std::pair<std::string, std::string> StringPair;
    for(const StringPair& rtti_matlab: types) {
      int fieldId = mxAddField(registry, rtti_matlab.first.c_str());
      if(fieldId < 0)
        mexErrMsgTxt("gtsam wrap:  Error indexing RTTI types, inheritance will not work correctly");
      mxArray *matlabName = mxCreateString(rtti_matlab.second.c_str());
      mxSetFieldByNumber(registry, 0, fieldId, matlabName);
    }
    if(mexPutVariable("global", "gtsamwrap_rttiRegistry", registry) != 0)
      mexErrMsgTxt("gtsam wrap:  Error indexing RTTI types, inheritance will not work correctly");
    mxDestroyArray(registry);
    
    mxArray *newAlreadyCreated = mxCreateNumericMatrix(0, 0, mxINT8_CLASS, mxREAL);
    if(mexPutVariable("global", "gtsam_gtsam_rttiRegistry_created", newAlreadyCreated) != 0)
      mexErrMsgTxt("gtsam wrap:  Error indexing RTTI types, inheritance will not work correctly");
    mxDestroyArray(newAlreadyCreated);
  }
}

void gtsamKeyList_collectorInsertAndMakeBase_0(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyList> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamKeyList.insert(self);
}

void gtsamKeyList_constructor_1(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyList> Shared;

  Shared *self = new Shared(new gtsam::KeyList());
  collector_gtsamKeyList.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeyList_constructor_2(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyList> Shared;

  gtsam::KeyList& other = *unwrap_shared_ptr< gtsam::KeyList >(in[0], "ptr_gtsamKeyList");
  Shared *self = new Shared(new gtsam::KeyList(other));
  collector_gtsamKeyList.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeyList_deconstructor_3(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("delete_gtsamKeyList",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamKeyList::iterator item;
  item = collector_gtsamKeyList.find(self);
  if(item != collector_gtsamKeyList.end()) {
    delete self;
    collector_gtsamKeyList.erase(item);
  }
}

void gtsamKeyList_back_4(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("back",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  out[0] = wrap< size_t >(obj->back());
}

void gtsamKeyList_clear_5(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  obj->clear();
}

void gtsamKeyList_empty_6(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamKeyList_front_7(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("front",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  out[0] = wrap< size_t >(obj->front());
}

void gtsamKeyList_pop_back_8(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("pop_back",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  obj->pop_back();
}

void gtsamKeyList_pop_front_9(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("pop_front",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  obj->pop_front();
}

void gtsamKeyList_push_back_10(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  size_t key = unwrap< size_t >(in[1]);
  obj->push_back(key);
}

void gtsamKeyList_push_front_11(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("push_front",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  size_t key = unwrap< size_t >(in[1]);
  obj->push_front(key);
}

void gtsamKeyList_remove_12(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("remove",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  size_t key = unwrap< size_t >(in[1]);
  obj->remove(key);
}

void gtsamKeyList_size_13(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamKeyList_sort_14(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("sort",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  obj->sort();
}

void gtsamKeyList_string_serialize_15(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyList>(in[0], "ptr_gtsamKeyList");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamKeyList_string_deserialize_16(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> Shared;
  checkArguments("gtsamKeyList.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::KeyList());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.KeyList", false);
}
void gtsamKeySet_collectorInsertAndMakeBase_17(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeySet> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamKeySet.insert(self);
}

void gtsamKeySet_constructor_18(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeySet> Shared;

  Shared *self = new Shared(new gtsam::KeySet());
  collector_gtsamKeySet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeySet_constructor_19(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeySet> Shared;

  gtsam::KeySet& set = *unwrap_shared_ptr< gtsam::KeySet >(in[0], "ptr_gtsamKeySet");
  Shared *self = new Shared(new gtsam::KeySet(set));
  collector_gtsamKeySet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeySet_constructor_20(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeySet> Shared;

  gtsam::KeyVector& vector = *unwrap_shared_ptr< gtsam::KeyVector >(in[0], "ptr_gtsamKeyVector");
  Shared *self = new Shared(new gtsam::KeySet(vector));
  collector_gtsamKeySet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeySet_constructor_21(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeySet> Shared;

  gtsam::KeyList& list = *unwrap_shared_ptr< gtsam::KeyList >(in[0], "ptr_gtsamKeyList");
  Shared *self = new Shared(new gtsam::KeySet(list));
  collector_gtsamKeySet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeySet_deconstructor_22(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("delete_gtsamKeySet",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamKeySet::iterator item;
  item = collector_gtsamKeySet.find(self);
  if(item != collector_gtsamKeySet.end()) {
    delete self;
    collector_gtsamKeySet.erase(item);
  }
}

void gtsamKeySet_clear_23(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  obj->clear();
}

void gtsamKeySet_count_24(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("count",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->count(key));
}

void gtsamKeySet_empty_25(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamKeySet_equals_26(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("equals",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  gtsam::KeySet& other = *unwrap_shared_ptr< gtsam::KeySet >(in[1], "ptr_gtsamKeySet");
  out[0] = wrap< bool >(obj->equals(other));
}

void gtsamKeySet_erase_27(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("erase",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->erase(key));
}

void gtsamKeySet_insert_28(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("insert",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  size_t key = unwrap< size_t >(in[1]);
  obj->insert(key);
}

void gtsamKeySet_merge_29(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("merge",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  gtsam::KeySet& other = *unwrap_shared_ptr< gtsam::KeySet >(in[1], "ptr_gtsamKeySet");
  obj->merge(other);
}

void gtsamKeySet_print_30(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamKeySet_size_31(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamKeySet_string_serialize_32(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeySet>(in[0], "ptr_gtsamKeySet");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamKeySet_string_deserialize_33(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> Shared;
  checkArguments("gtsamKeySet.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::KeySet());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.KeySet", false);
}
void gtsamKeyVector_collectorInsertAndMakeBase_34(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamKeyVector.insert(self);
}

void gtsamKeyVector_constructor_35(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;

  Shared *self = new Shared(new gtsam::KeyVector());
  collector_gtsamKeyVector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeyVector_constructor_36(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;

  gtsam::KeyVector& other = *unwrap_shared_ptr< gtsam::KeyVector >(in[0], "ptr_gtsamKeyVector");
  Shared *self = new Shared(new gtsam::KeyVector(other));
  collector_gtsamKeyVector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeyVector_deconstructor_37(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("delete_gtsamKeyVector",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamKeyVector::iterator item;
  item = collector_gtsamKeyVector.find(self);
  if(item != collector_gtsamKeyVector.end()) {
    delete self;
    collector_gtsamKeyVector.erase(item);
  }
}

void gtsamKeyVector_at_38(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  size_t i = unwrap< size_t >(in[1]);
  out[0] = wrap< size_t >(obj->at(i));
}

void gtsamKeyVector_back_39(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("back",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  out[0] = wrap< size_t >(obj->back());
}

void gtsamKeyVector_clear_40(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  obj->clear();
}

void gtsamKeyVector_empty_41(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamKeyVector_front_42(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("front",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  out[0] = wrap< size_t >(obj->front());
}

void gtsamKeyVector_push_back_43(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  size_t key = unwrap< size_t >(in[1]);
  obj->push_back(key);
}

void gtsamKeyVector_size_44(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamKeyVector_string_serialize_45(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyVector>(in[0], "ptr_gtsamKeyVector");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamKeyVector_string_deserialize_46(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> Shared;
  checkArguments("gtsamKeyVector.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::KeyVector());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.KeyVector", false);
}
void gtsamKeyGroupMap_collectorInsertAndMakeBase_47(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamKeyGroupMap.insert(self);
}

void gtsamKeyGroupMap_constructor_48(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;

  Shared *self = new Shared(new gtsam::KeyGroupMap());
  collector_gtsamKeyGroupMap.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKeyGroupMap_deconstructor_49(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;
  checkArguments("delete_gtsamKeyGroupMap",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamKeyGroupMap::iterator item;
  item = collector_gtsamKeyGroupMap.find(self);
  if(item != collector_gtsamKeyGroupMap.end()) {
    delete self;
    collector_gtsamKeyGroupMap.erase(item);
  }
}

void gtsamKeyGroupMap_at_50(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeyGroupMap>(in[0], "ptr_gtsamKeyGroupMap");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< size_t >(obj->at(key));
}

void gtsamKeyGroupMap_clear_51(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyGroupMap>(in[0], "ptr_gtsamKeyGroupMap");
  obj->clear();
}

void gtsamKeyGroupMap_empty_52(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyGroupMap>(in[0], "ptr_gtsamKeyGroupMap");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamKeyGroupMap_erase_53(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;
  checkArguments("erase",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KeyGroupMap>(in[0], "ptr_gtsamKeyGroupMap");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< int >(obj->erase(key));
}

void gtsamKeyGroupMap_insert2_54(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;
  checkArguments("insert2",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::KeyGroupMap>(in[0], "ptr_gtsamKeyGroupMap");
  size_t key = unwrap< size_t >(in[1]);
  int val = unwrap< int >(in[2]);
  out[0] = wrap< bool >(obj->insert2(key,val));
}

void gtsamKeyGroupMap_size_55(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyGroupMap> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::KeyGroupMap>(in[0], "ptr_gtsamKeyGroupMap");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamValue_collectorInsertAndMakeBase_56(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Value> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamValue.insert(self);
}

void gtsamValue_upcastFromVoid_57(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Value> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::Value>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamValue_deconstructor_58(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Value> Shared;
  checkArguments("delete_gtsamValue",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamValue::iterator item;
  item = collector_gtsamValue.find(self);
  if(item != collector_gtsamValue.end()) {
    delete self;
    collector_gtsamValue.erase(item);
  }
}

void gtsamValue_dim_59(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Value> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Value>(in[0], "ptr_gtsamValue");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamValue_print_60(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Value> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Value>(in[0], "ptr_gtsamValue");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamLieScalar_collectorInsertAndMakeBase_61(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamLieScalar.insert(self);
}

void gtsamLieScalar_constructor_62(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;

  Shared *self = new Shared(new gtsam::LieScalar());
  collector_gtsamLieScalar.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLieScalar_constructor_63(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;

  double d = unwrap< double >(in[0]);
  Shared *self = new Shared(new gtsam::LieScalar(d));
  collector_gtsamLieScalar.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLieScalar_deconstructor_64(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("delete_gtsamLieScalar",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamLieScalar::iterator item;
  item = collector_gtsamLieScalar.find(self);
  if(item != collector_gtsamLieScalar.end()) {
    delete self;
    collector_gtsamLieScalar.erase(item);
  }
}

void gtsamLieScalar_between_65(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> SharedLieScalar;
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  gtsam::LieScalar& l2 = *unwrap_shared_ptr< gtsam::LieScalar >(in[1], "ptr_gtsamLieScalar");
  out[0] = wrap_shared_ptr(SharedLieScalar(new gtsam::LieScalar(obj->between(l2))),"gtsam.LieScalar", false);
}

void gtsamLieScalar_compose_66(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> SharedLieScalar;
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  gtsam::LieScalar& p = *unwrap_shared_ptr< gtsam::LieScalar >(in[1], "ptr_gtsamLieScalar");
  out[0] = wrap_shared_ptr(SharedLieScalar(new gtsam::LieScalar(obj->compose(p))),"gtsam.LieScalar", false);
}

void gtsamLieScalar_dim_67(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamLieScalar_equals_68(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  gtsam::LieScalar& expected = *unwrap_shared_ptr< gtsam::LieScalar >(in[1], "ptr_gtsamLieScalar");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamLieScalar_inverse_69(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> SharedLieScalar;
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  out[0] = wrap_shared_ptr(SharedLieScalar(new gtsam::LieScalar(obj->inverse())),"gtsam.LieScalar", false);
}

void gtsamLieScalar_localCoordinates_70(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  gtsam::LieScalar& t2 = *unwrap_shared_ptr< gtsam::LieScalar >(in[1], "ptr_gtsamLieScalar");
  out[0] = wrap< Vector >(obj->localCoordinates(t2));
}

void gtsamLieScalar_print_71(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamLieScalar_retract_72(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> SharedLieScalar;
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedLieScalar(new gtsam::LieScalar(obj->retract(v))),"gtsam.LieScalar", false);
}

void gtsamLieScalar_value_73(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("value",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieScalar>(in[0], "ptr_gtsamLieScalar");
  out[0] = wrap< double >(obj->value());
}

void gtsamLieScalar_Expmap_74(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> SharedLieScalar;
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("gtsamLieScalar.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedLieScalar(new gtsam::LieScalar(gtsam::LieScalar::Expmap(v))),"gtsam.LieScalar", false);
}

void gtsamLieScalar_Logmap_75(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("gtsamLieScalar.Logmap",nargout,nargin,1);
  gtsam::LieScalar& p = *unwrap_shared_ptr< gtsam::LieScalar >(in[0], "ptr_gtsamLieScalar");
  out[0] = wrap< Vector >(gtsam::LieScalar::Logmap(p));
}

void gtsamLieScalar_identity_76(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieScalar> SharedLieScalar;
  typedef boost::shared_ptr<gtsam::LieScalar> Shared;
  checkArguments("gtsamLieScalar.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedLieScalar(new gtsam::LieScalar(gtsam::LieScalar::identity())),"gtsam.LieScalar", false);
}

void gtsamLieVector_collectorInsertAndMakeBase_77(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieVector> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamLieVector.insert(self);
}

void gtsamLieVector_constructor_78(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieVector> Shared;

  Shared *self = new Shared(new gtsam::LieVector());
  collector_gtsamLieVector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLieVector_constructor_79(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieVector> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::LieVector(v));
  collector_gtsamLieVector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLieVector_deconstructor_80(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("delete_gtsamLieVector",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamLieVector::iterator item;
  item = collector_gtsamLieVector.find(self);
  if(item != collector_gtsamLieVector.end()) {
    delete self;
    collector_gtsamLieVector.erase(item);
  }
}

void gtsamLieVector_between_81(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> SharedLieVector;
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  gtsam::LieVector& l2 = *unwrap_shared_ptr< gtsam::LieVector >(in[1], "ptr_gtsamLieVector");
  out[0] = wrap_shared_ptr(SharedLieVector(new gtsam::LieVector(obj->between(l2))),"gtsam.LieVector", false);
}

void gtsamLieVector_compose_82(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> SharedLieVector;
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  gtsam::LieVector& p = *unwrap_shared_ptr< gtsam::LieVector >(in[1], "ptr_gtsamLieVector");
  out[0] = wrap_shared_ptr(SharedLieVector(new gtsam::LieVector(obj->compose(p))),"gtsam.LieVector", false);
}

void gtsamLieVector_dim_83(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamLieVector_equals_84(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  gtsam::LieVector& expected = *unwrap_shared_ptr< gtsam::LieVector >(in[1], "ptr_gtsamLieVector");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamLieVector_inverse_85(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> SharedLieVector;
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  out[0] = wrap_shared_ptr(SharedLieVector(new gtsam::LieVector(obj->inverse())),"gtsam.LieVector", false);
}

void gtsamLieVector_localCoordinates_86(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  gtsam::LieVector& t2 = *unwrap_shared_ptr< gtsam::LieVector >(in[1], "ptr_gtsamLieVector");
  out[0] = wrap< Vector >(obj->localCoordinates(t2));
}

void gtsamLieVector_print_87(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamLieVector_retract_88(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> SharedLieVector;
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedLieVector(new gtsam::LieVector(obj->retract(v))),"gtsam.LieVector", false);
}

void gtsamLieVector_vector_89(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamLieVector_string_serialize_90(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieVector>(in[0], "ptr_gtsamLieVector");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamLieVector_Expmap_91(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> SharedLieVector;
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("gtsamLieVector.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedLieVector(new gtsam::LieVector(gtsam::LieVector::Expmap(v))),"gtsam.LieVector", false);
}

void gtsamLieVector_Logmap_92(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("gtsamLieVector.Logmap",nargout,nargin,1);
  gtsam::LieVector& p = *unwrap_shared_ptr< gtsam::LieVector >(in[0], "ptr_gtsamLieVector");
  out[0] = wrap< Vector >(gtsam::LieVector::Logmap(p));
}

void gtsamLieVector_identity_93(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> SharedLieVector;
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("gtsamLieVector.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedLieVector(new gtsam::LieVector(gtsam::LieVector::identity())),"gtsam.LieVector", false);
}

void gtsamLieVector_string_deserialize_94(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieVector> Shared;
  checkArguments("gtsamLieVector.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::LieVector());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.LieVector", false);
}
void gtsamLieMatrix_collectorInsertAndMakeBase_95(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamLieMatrix.insert(self);
}

void gtsamLieMatrix_constructor_96(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;

  Shared *self = new Shared(new gtsam::LieMatrix());
  collector_gtsamLieMatrix.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLieMatrix_constructor_97(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;

  Matrix v = unwrap< Matrix >(in[0]);
  Shared *self = new Shared(new gtsam::LieMatrix(v));
  collector_gtsamLieMatrix.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLieMatrix_deconstructor_98(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("delete_gtsamLieMatrix",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamLieMatrix::iterator item;
  item = collector_gtsamLieMatrix.find(self);
  if(item != collector_gtsamLieMatrix.end()) {
    delete self;
    collector_gtsamLieMatrix.erase(item);
  }
}

void gtsamLieMatrix_between_99(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> SharedLieMatrix;
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  gtsam::LieMatrix& l2 = *unwrap_shared_ptr< gtsam::LieMatrix >(in[1], "ptr_gtsamLieMatrix");
  out[0] = wrap_shared_ptr(SharedLieMatrix(new gtsam::LieMatrix(obj->between(l2))),"gtsam.LieMatrix", false);
}

void gtsamLieMatrix_compose_100(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> SharedLieMatrix;
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  gtsam::LieMatrix& p = *unwrap_shared_ptr< gtsam::LieMatrix >(in[1], "ptr_gtsamLieMatrix");
  out[0] = wrap_shared_ptr(SharedLieMatrix(new gtsam::LieMatrix(obj->compose(p))),"gtsam.LieMatrix", false);
}

void gtsamLieMatrix_dim_101(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamLieMatrix_equals_102(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  gtsam::LieMatrix& expected = *unwrap_shared_ptr< gtsam::LieMatrix >(in[1], "ptr_gtsamLieMatrix");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamLieMatrix_inverse_103(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> SharedLieMatrix;
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  out[0] = wrap_shared_ptr(SharedLieMatrix(new gtsam::LieMatrix(obj->inverse())),"gtsam.LieMatrix", false);
}

void gtsamLieMatrix_localCoordinates_104(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  gtsam::LieMatrix& t2 = *unwrap_shared_ptr< gtsam::LieMatrix >(in[1], "ptr_gtsamLieMatrix");
  out[0] = wrap< Vector >(obj->localCoordinates(t2));
}

void gtsamLieMatrix_matrix_105(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("matrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  out[0] = wrap< Matrix >(obj->matrix());
}

void gtsamLieMatrix_print_106(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamLieMatrix_retract_107(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> SharedLieMatrix;
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedLieMatrix(new gtsam::LieMatrix(obj->retract(v))),"gtsam.LieMatrix", false);
}

void gtsamLieMatrix_string_serialize_108(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LieMatrix>(in[0], "ptr_gtsamLieMatrix");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamLieMatrix_Expmap_109(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> SharedLieMatrix;
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("gtsamLieMatrix.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedLieMatrix(new gtsam::LieMatrix(gtsam::LieMatrix::Expmap(v))),"gtsam.LieMatrix", false);
}

void gtsamLieMatrix_Logmap_110(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("gtsamLieMatrix.Logmap",nargout,nargin,1);
  gtsam::LieMatrix& p = *unwrap_shared_ptr< gtsam::LieMatrix >(in[0], "ptr_gtsamLieMatrix");
  out[0] = wrap< Vector >(gtsam::LieMatrix::Logmap(p));
}

void gtsamLieMatrix_identity_111(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> SharedLieMatrix;
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("gtsamLieMatrix.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedLieMatrix(new gtsam::LieMatrix(gtsam::LieMatrix::identity())),"gtsam.LieMatrix", false);
}

void gtsamLieMatrix_string_deserialize_112(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LieMatrix> Shared;
  checkArguments("gtsamLieMatrix.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::LieMatrix());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.LieMatrix", false);
}
void gtsamPoint2_collectorInsertAndMakeBase_113(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPoint2.insert(self);
}

void gtsamPoint2_constructor_114(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point2> Shared;

  Shared *self = new Shared(new gtsam::Point2());
  collector_gtsamPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint2_constructor_115(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point2> Shared;

  double x = unwrap< double >(in[0]);
  double y = unwrap< double >(in[1]);
  Shared *self = new Shared(new gtsam::Point2(x,y));
  collector_gtsamPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint2_constructor_116(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point2> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::Point2(v));
  collector_gtsamPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint2_deconstructor_117(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("delete_gtsamPoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPoint2::iterator item;
  item = collector_gtsamPoint2.find(self);
  if(item != collector_gtsamPoint2.end()) {
    delete self;
    collector_gtsamPoint2.erase(item);
  }
}

void gtsamPoint2_distance_118(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("distance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  gtsam::Point2& p2 = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap< double >(obj->distance(p2));
}

void gtsamPoint2_equals_119(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  gtsam::Point2& point = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(point,tol));
}

void gtsamPoint2_norm_120(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("norm",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  out[0] = wrap< double >(obj->norm());
}

void gtsamPoint2_print_121(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPoint2_vector_122(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamPoint2_x_123(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("x",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  out[0] = wrap< double >(obj->x());
}

void gtsamPoint2_y_124(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("y",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  out[0] = wrap< double >(obj->y());
}

void gtsamPoint2_string_serialize_125(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2>(in[0], "ptr_gtsamPoint2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPoint2_identity_126(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("gtsamPoint2.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(gtsam::Point2::identity())),"gtsam.Point2", false);
}

void gtsamPoint2_string_deserialize_127(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> Shared;
  checkArguments("gtsamPoint2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Point2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Point2", false);
}
void gtsamPoint2Vector_collectorInsertAndMakeBase_128(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPoint2Vector.insert(self);
}

void gtsamPoint2Vector_constructor_129(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;

  Shared *self = new Shared(new gtsam::Point2Vector());
  collector_gtsamPoint2Vector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint2Vector_constructor_130(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;

  gtsam::Point2Vector& v = *unwrap_shared_ptr< gtsam::Point2Vector >(in[0], "ptr_gtsamPoint2Vector");
  Shared *self = new Shared(new gtsam::Point2Vector(v));
  collector_gtsamPoint2Vector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint2Vector_deconstructor_131(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("delete_gtsamPoint2Vector",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPoint2Vector::iterator item;
  item = collector_gtsamPoint2Vector.find(self);
  if(item != collector_gtsamPoint2Vector.end()) {
    delete self;
    collector_gtsamPoint2Vector.erase(item);
  }
}

void gtsamPoint2Vector_assign_132(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("assign",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  size_t n = unwrap< size_t >(in[1]);
  gtsam::Point2& u = *unwrap_shared_ptr< gtsam::Point2 >(in[2], "ptr_gtsamPoint2");
  obj->assign(n,u);
}

void gtsamPoint2Vector_at_133(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  size_t n = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->at(n))),"gtsam.Point2", false);
}

void gtsamPoint2Vector_back_134(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("back",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->back())),"gtsam.Point2", false);
}

void gtsamPoint2Vector_capacity_135(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("capacity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  out[0] = wrap< size_t >(obj->capacity());
}

void gtsamPoint2Vector_empty_136(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamPoint2Vector_front_137(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("front",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->front())),"gtsam.Point2", false);
}

void gtsamPoint2Vector_max_size_138(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("max_size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  out[0] = wrap< size_t >(obj->max_size());
}

void gtsamPoint2Vector_pop_back_139(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("pop_back",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  obj->pop_back();
}

void gtsamPoint2Vector_push_back_140(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  gtsam::Point2& x = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  obj->push_back(x);
}

void gtsamPoint2Vector_reserve_141(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("reserve",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  size_t n = unwrap< size_t >(in[1]);
  obj->reserve(n);
}

void gtsamPoint2Vector_resize_142(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("resize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  size_t sz = unwrap< size_t >(in[1]);
  obj->resize(sz);
}

void gtsamPoint2Vector_size_143(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2Vector> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point2Vector>(in[0], "ptr_gtsamPoint2Vector");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamStereoPoint2_collectorInsertAndMakeBase_144(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamStereoPoint2.insert(self);
}

void gtsamStereoPoint2_constructor_145(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;

  Shared *self = new Shared(new gtsam::StereoPoint2());
  collector_gtsamStereoPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamStereoPoint2_constructor_146(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;

  double uL = unwrap< double >(in[0]);
  double uR = unwrap< double >(in[1]);
  double v = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::StereoPoint2(uL,uR,v));
  collector_gtsamStereoPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamStereoPoint2_deconstructor_147(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("delete_gtsamStereoPoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamStereoPoint2::iterator item;
  item = collector_gtsamStereoPoint2.find(self);
  if(item != collector_gtsamStereoPoint2.end()) {
    delete self;
    collector_gtsamStereoPoint2.erase(item);
  }
}

void gtsamStereoPoint2_between_148(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  gtsam::StereoPoint2& p2 = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(obj->between(p2))),"gtsam.StereoPoint2", false);
}

void gtsamStereoPoint2_compose_149(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  gtsam::StereoPoint2& p2 = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(obj->compose(p2))),"gtsam.StereoPoint2", false);
}

void gtsamStereoPoint2_equals_150(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  gtsam::StereoPoint2& point = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(point,tol));
}

void gtsamStereoPoint2_inverse_151(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(obj->inverse())),"gtsam.StereoPoint2", false);
}

void gtsamStereoPoint2_localCoordinates_152(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  gtsam::StereoPoint2& p = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  out[0] = wrap< Vector >(obj->localCoordinates(p));
}

void gtsamStereoPoint2_print_153(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamStereoPoint2_retract_154(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(obj->retract(v))),"gtsam.StereoPoint2", false);
}

void gtsamStereoPoint2_uL_155(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("uL",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  out[0] = wrap< double >(obj->uL());
}

void gtsamStereoPoint2_uR_156(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("uR",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  out[0] = wrap< double >(obj->uR());
}

void gtsamStereoPoint2_v_157(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("v",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  out[0] = wrap< double >(obj->v());
}

void gtsamStereoPoint2_vector_158(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamStereoPoint2_string_serialize_159(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoPoint2>(in[0], "ptr_gtsamStereoPoint2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamStereoPoint2_Expmap_160(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("gtsamStereoPoint2.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(gtsam::StereoPoint2::Expmap(v))),"gtsam.StereoPoint2", false);
}

void gtsamStereoPoint2_Logmap_161(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("gtsamStereoPoint2.Logmap",nargout,nargin,1);
  gtsam::StereoPoint2& p = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[0], "ptr_gtsamStereoPoint2");
  out[0] = wrap< Vector >(gtsam::StereoPoint2::Logmap(p));
}

void gtsamStereoPoint2_identity_162(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("gtsamStereoPoint2.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(gtsam::StereoPoint2::identity())),"gtsam.StereoPoint2", false);
}

void gtsamStereoPoint2_string_deserialize_163(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> Shared;
  checkArguments("gtsamStereoPoint2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::StereoPoint2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.StereoPoint2", false);
}
void gtsamPoint3_collectorInsertAndMakeBase_164(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPoint3.insert(self);
}

void gtsamPoint3_constructor_165(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point3> Shared;

  Shared *self = new Shared(new gtsam::Point3());
  collector_gtsamPoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint3_constructor_166(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point3> Shared;

  double x = unwrap< double >(in[0]);
  double y = unwrap< double >(in[1]);
  double z = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::Point3(x,y,z));
  collector_gtsamPoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint3_constructor_167(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Point3> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::Point3(v));
  collector_gtsamPoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPoint3_deconstructor_168(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("delete_gtsamPoint3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPoint3::iterator item;
  item = collector_gtsamPoint3.find(self);
  if(item != collector_gtsamPoint3.end()) {
    delete self;
    collector_gtsamPoint3.erase(item);
  }
}

void gtsamPoint3_equals_169(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Point3>(in[0], "ptr_gtsamPoint3");
  gtsam::Point3& p = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(p,tol));
}

void gtsamPoint3_print_170(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Point3>(in[0], "ptr_gtsamPoint3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPoint3_vector_171(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point3>(in[0], "ptr_gtsamPoint3");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamPoint3_x_172(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("x",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point3>(in[0], "ptr_gtsamPoint3");
  out[0] = wrap< double >(obj->x());
}

void gtsamPoint3_y_173(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("y",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point3>(in[0], "ptr_gtsamPoint3");
  out[0] = wrap< double >(obj->y());
}

void gtsamPoint3_z_174(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("z",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point3>(in[0], "ptr_gtsamPoint3");
  out[0] = wrap< double >(obj->z());
}

void gtsamPoint3_string_serialize_175(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Point3>(in[0], "ptr_gtsamPoint3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPoint3_identity_176(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("gtsamPoint3.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(gtsam::Point3::identity())),"gtsam.Point3", false);
}

void gtsamPoint3_string_deserialize_177(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> Shared;
  checkArguments("gtsamPoint3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Point3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Point3", false);
}
void gtsamRot2_collectorInsertAndMakeBase_178(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRot2.insert(self);
}

void gtsamRot2_constructor_179(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot2> Shared;

  Shared *self = new Shared(new gtsam::Rot2());
  collector_gtsamRot2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamRot2_constructor_180(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot2> Shared;

  double theta = unwrap< double >(in[0]);
  Shared *self = new Shared(new gtsam::Rot2(theta));
  collector_gtsamRot2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamRot2_deconstructor_181(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("delete_gtsamRot2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRot2::iterator item;
  item = collector_gtsamRot2.find(self);
  if(item != collector_gtsamRot2.end()) {
    delete self;
    collector_gtsamRot2.erase(item);
  }
}

void gtsamRot2_between_182(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  gtsam::Rot2& p2 = *unwrap_shared_ptr< gtsam::Rot2 >(in[1], "ptr_gtsamRot2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->between(p2))),"gtsam.Rot2", false);
}

void gtsamRot2_c_183(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("c",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  out[0] = wrap< double >(obj->c());
}

void gtsamRot2_compose_184(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  gtsam::Rot2& p2 = *unwrap_shared_ptr< gtsam::Rot2 >(in[1], "ptr_gtsamRot2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->compose(p2))),"gtsam.Rot2", false);
}

void gtsamRot2_degrees_185(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("degrees",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  out[0] = wrap< double >(obj->degrees());
}

void gtsamRot2_equals_186(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  gtsam::Rot2& rot = *unwrap_shared_ptr< gtsam::Rot2 >(in[1], "ptr_gtsamRot2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(rot,tol));
}

void gtsamRot2_inverse_187(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->inverse())),"gtsam.Rot2", false);
}

void gtsamRot2_localCoordinates_188(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  gtsam::Rot2& p = *unwrap_shared_ptr< gtsam::Rot2 >(in[1], "ptr_gtsamRot2");
  out[0] = wrap< Vector >(obj->localCoordinates(p));
}

void gtsamRot2_matrix_189(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("matrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  out[0] = wrap< Matrix >(obj->matrix());
}

void gtsamRot2_print_190(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRot2_retract_191(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->retract(v))),"gtsam.Rot2", false);
}

void gtsamRot2_rotate_192(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("rotate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  gtsam::Point2& point = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->rotate(point))),"gtsam.Point2", false);
}

void gtsamRot2_s_193(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("s",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  out[0] = wrap< double >(obj->s());
}

void gtsamRot2_theta_194(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("theta",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  out[0] = wrap< double >(obj->theta());
}

void gtsamRot2_unrotate_195(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("unrotate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  gtsam::Point2& point = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->unrotate(point))),"gtsam.Point2", false);
}

void gtsamRot2_string_serialize_196(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot2>(in[0], "ptr_gtsamRot2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamRot2_Expmap_197(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(gtsam::Rot2::Expmap(v))),"gtsam.Rot2", false);
}

void gtsamRot2_Logmap_198(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.Logmap",nargout,nargin,1);
  gtsam::Rot2& p = *unwrap_shared_ptr< gtsam::Rot2 >(in[0], "ptr_gtsamRot2");
  out[0] = wrap< Vector >(gtsam::Rot2::Logmap(p));
}

void gtsamRot2_atan2_199(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.atan2",nargout,nargin,2);
  double y = unwrap< double >(in[0]);
  double x = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(gtsam::Rot2::atan2(y,x))),"gtsam.Rot2", false);
}

void gtsamRot2_fromAngle_200(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.fromAngle",nargout,nargin,1);
  double theta = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(gtsam::Rot2::fromAngle(theta))),"gtsam.Rot2", false);
}

void gtsamRot2_fromCosSin_201(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.fromCosSin",nargout,nargin,2);
  double c = unwrap< double >(in[0]);
  double s = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(gtsam::Rot2::fromCosSin(c,s))),"gtsam.Rot2", false);
}

void gtsamRot2_fromDegrees_202(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.fromDegrees",nargout,nargin,1);
  double theta = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(gtsam::Rot2::fromDegrees(theta))),"gtsam.Rot2", false);
}

void gtsamRot2_identity_203(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(gtsam::Rot2::identity())),"gtsam.Rot2", false);
}

void gtsamRot2_relativeBearing_204(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.relativeBearing",nargout,nargin,1);
  gtsam::Point2& d = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(gtsam::Rot2::relativeBearing(d))),"gtsam.Rot2", false);
}

void gtsamRot2_string_deserialize_205(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> Shared;
  checkArguments("gtsamRot2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Rot2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Rot2", false);
}
void gtsamRot3_collectorInsertAndMakeBase_206(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRot3.insert(self);
}

void gtsamRot3_constructor_207(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3> Shared;

  Shared *self = new Shared(new gtsam::Rot3());
  collector_gtsamRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamRot3_constructor_208(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3> Shared;

  Matrix R = unwrap< Matrix >(in[0]);
  Shared *self = new Shared(new gtsam::Rot3(R));
  collector_gtsamRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamRot3_constructor_209(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3> Shared;

  gtsam::Point3& col1 = *unwrap_shared_ptr< gtsam::Point3 >(in[0], "ptr_gtsamPoint3");
  gtsam::Point3& col2 = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  gtsam::Point3& col3 = *unwrap_shared_ptr< gtsam::Point3 >(in[2], "ptr_gtsamPoint3");
  Shared *self = new Shared(new gtsam::Rot3(col1,col2,col3));
  collector_gtsamRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamRot3_constructor_210(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3> Shared;

  double R11 = unwrap< double >(in[0]);
  double R12 = unwrap< double >(in[1]);
  double R13 = unwrap< double >(in[2]);
  double R21 = unwrap< double >(in[3]);
  double R22 = unwrap< double >(in[4]);
  double R23 = unwrap< double >(in[5]);
  double R31 = unwrap< double >(in[6]);
  double R32 = unwrap< double >(in[7]);
  double R33 = unwrap< double >(in[8]);
  Shared *self = new Shared(new gtsam::Rot3(R11,R12,R13,R21,R22,R23,R31,R32,R33));
  collector_gtsamRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamRot3_deconstructor_211(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("delete_gtsamRot3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRot3::iterator item;
  item = collector_gtsamRot3.find(self);
  if(item != collector_gtsamRot3.end()) {
    delete self;
    collector_gtsamRot3.erase(item);
  }
}

void gtsamRot3_between_212(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  gtsam::Rot3& p2 = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->between(p2))),"gtsam.Rot3", false);
}

void gtsamRot3_column_213(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("column",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  size_t index = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->column(index))),"gtsam.Point3", false);
}

void gtsamRot3_compose_214(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  gtsam::Rot3& p2 = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->compose(p2))),"gtsam.Rot3", false);
}

void gtsamRot3_equals_215(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  gtsam::Rot3& rot = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(rot,tol));
}

void gtsamRot3_inverse_216(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->inverse())),"gtsam.Rot3", false);
}

void gtsamRot3_localCoordinates_217(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  gtsam::Rot3& p = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  out[0] = wrap< Vector >(obj->localCoordinates(p));
}

void gtsamRot3_matrix_218(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("matrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< Matrix >(obj->matrix());
}

void gtsamRot3_pitch_219(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("pitch",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< double >(obj->pitch());
}

void gtsamRot3_print_220(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRot3_quaternion_221(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("quaternion",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< Vector >(obj->quaternion());
}

void gtsamRot3_retract_222(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->retract(v))),"gtsam.Rot3", false);
}

void gtsamRot3_roll_223(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("roll",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< double >(obj->roll());
}

void gtsamRot3_rotate_224(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("rotate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  gtsam::Point3& p = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->rotate(p))),"gtsam.Point3", false);
}

void gtsamRot3_rpy_225(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("rpy",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< Vector >(obj->rpy());
}

void gtsamRot3_transpose_226(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("transpose",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< Matrix >(obj->transpose());
}

void gtsamRot3_unrotate_227(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("unrotate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  gtsam::Point3& p = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->unrotate(p))),"gtsam.Point3", false);
}

void gtsamRot3_xyz_228(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("xyz",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< Vector >(obj->xyz());
}

void gtsamRot3_yaw_229(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("yaw",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< double >(obj->yaw());
}

void gtsamRot3_ypr_230(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("ypr",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  out[0] = wrap< Vector >(obj->ypr());
}

void gtsamRot3_string_serialize_231(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3>(in[0], "ptr_gtsamRot3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamRot3_Expmap_232(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Expmap(v))),"gtsam.Rot3", false);
}

void gtsamRot3_Logmap_233(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Logmap",nargout,nargin,1);
  gtsam::Rot3& p = *unwrap_shared_ptr< gtsam::Rot3 >(in[0], "ptr_gtsamRot3");
  out[0] = wrap< Vector >(gtsam::Rot3::Logmap(p));
}

void gtsamRot3_Pitch_234(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Pitch",nargout,nargin,1);
  double t = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Pitch(t))),"gtsam.Rot3", false);
}

void gtsamRot3_Quaternion_235(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Quaternion",nargout,nargin,4);
  double w = unwrap< double >(in[0]);
  double x = unwrap< double >(in[1]);
  double y = unwrap< double >(in[2]);
  double z = unwrap< double >(in[3]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Quaternion(w,x,y,z))),"gtsam.Rot3", false);
}

void gtsamRot3_Rodrigues_236(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Rodrigues",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Rodrigues(v))),"gtsam.Rot3", false);
}
void gtsamRot3_Rodrigues_237(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Rodrigues",nargout,nargin,3);
  double wx = unwrap< double >(in[0]);
  double wy = unwrap< double >(in[1]);
  double wz = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Rodrigues(wx,wy,wz))),"gtsam.Rot3", false);
}

void gtsamRot3_Roll_238(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Roll",nargout,nargin,1);
  double t = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Roll(t))),"gtsam.Rot3", false);
}

void gtsamRot3_Rx_239(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Rx",nargout,nargin,1);
  double t = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Rx(t))),"gtsam.Rot3", false);
}

void gtsamRot3_Ry_240(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Ry",nargout,nargin,1);
  double t = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Ry(t))),"gtsam.Rot3", false);
}

void gtsamRot3_Rz_241(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Rz",nargout,nargin,1);
  double t = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Rz(t))),"gtsam.Rot3", false);
}

void gtsamRot3_RzRyRx_242(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.RzRyRx",nargout,nargin,3);
  double x = unwrap< double >(in[0]);
  double y = unwrap< double >(in[1]);
  double z = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::RzRyRx(x,y,z))),"gtsam.Rot3", false);
}
void gtsamRot3_RzRyRx_243(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.RzRyRx",nargout,nargin,1);
  Vector xyz = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::RzRyRx(xyz))),"gtsam.Rot3", false);
}

void gtsamRot3_Yaw_244(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Yaw",nargout,nargin,1);
  double t = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Yaw(t))),"gtsam.Rot3", false);
}

void gtsamRot3_Ypr_245(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.Ypr",nargout,nargin,3);
  double y = unwrap< double >(in[0]);
  double p = unwrap< double >(in[1]);
  double r = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::Ypr(y,p,r))),"gtsam.Rot3", false);
}

void gtsamRot3_identity_246(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(gtsam::Rot3::identity())),"gtsam.Rot3", false);
}

void gtsamRot3_string_deserialize_247(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> Shared;
  checkArguments("gtsamRot3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Rot3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Rot3", false);
}
void gtsamPose2_collectorInsertAndMakeBase_248(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPose2.insert(self);
}

void gtsamPose2_constructor_249(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose2> Shared;

  Shared *self = new Shared(new gtsam::Pose2());
  collector_gtsamPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose2_constructor_250(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose2> Shared;

  gtsam::Pose2& other = *unwrap_shared_ptr< gtsam::Pose2 >(in[0], "ptr_gtsamPose2");
  Shared *self = new Shared(new gtsam::Pose2(other));
  collector_gtsamPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose2_constructor_251(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose2> Shared;

  double x = unwrap< double >(in[0]);
  double y = unwrap< double >(in[1]);
  double theta = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::Pose2(x,y,theta));
  collector_gtsamPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose2_constructor_252(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose2> Shared;

  double theta = unwrap< double >(in[0]);
  gtsam::Point2& t = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  Shared *self = new Shared(new gtsam::Pose2(theta,t));
  collector_gtsamPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose2_constructor_253(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose2> Shared;

  gtsam::Rot2& r = *unwrap_shared_ptr< gtsam::Rot2 >(in[0], "ptr_gtsamRot2");
  gtsam::Point2& t = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  Shared *self = new Shared(new gtsam::Pose2(r,t));
  collector_gtsamPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose2_constructor_254(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose2> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::Pose2(v));
  collector_gtsamPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose2_deconstructor_255(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("delete_gtsamPose2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPose2::iterator item;
  item = collector_gtsamPose2.find(self);
  if(item != collector_gtsamPose2.end()) {
    delete self;
    collector_gtsamPose2.erase(item);
  }
}

void gtsamPose2_Adjoint_256(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("Adjoint",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  Vector xi = unwrap< Vector >(in[1]);
  out[0] = wrap< Vector >(obj->Adjoint(xi));
}

void gtsamPose2_AdjointMap_257(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("AdjointMap",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap< Matrix >(obj->AdjointMap());
}

void gtsamPose2_bearing_258(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("bearing",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Point2& point = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->bearing(point))),"gtsam.Rot2", false);
}

void gtsamPose2_between_259(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Pose2& p2 = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->between(p2))),"gtsam.Pose2", false);
}

void gtsamPose2_compose_260(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Pose2& p2 = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->compose(p2))),"gtsam.Pose2", false);
}

void gtsamPose2_equals_261(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Pose2& pose = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(pose,tol));
}

void gtsamPose2_inverse_262(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->inverse())),"gtsam.Pose2", false);
}

void gtsamPose2_localCoordinates_263(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Pose2& p = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  out[0] = wrap< Vector >(obj->localCoordinates(p));
}

void gtsamPose2_matrix_264(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("matrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap< Matrix >(obj->matrix());
}

void gtsamPose2_print_265(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPose2_range_266(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Point2& point = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap< double >(obj->range(point));
}

void gtsamPose2_retract_267(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->retract(v))),"gtsam.Pose2", false);
}

void gtsamPose2_rotation_268(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("rotation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->rotation())),"gtsam.Rot2", false);
}

void gtsamPose2_theta_269(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("theta",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap< double >(obj->theta());
}

void gtsamPose2_transform_from_270(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("transform_from",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->transform_from(p))),"gtsam.Point2", false);
}

void gtsamPose2_transform_to_271(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("transform_to",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->transform_to(p))),"gtsam.Point2", false);
}

void gtsamPose2_translation_272(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("translation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->translation())),"gtsam.Point2", false);
}

void gtsamPose2_x_273(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("x",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap< double >(obj->x());
}

void gtsamPose2_y_274(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("y",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  out[0] = wrap< double >(obj->y());
}

void gtsamPose2_string_serialize_275(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose2>(in[0], "ptr_gtsamPose2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPose2_Expmap_276(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("gtsamPose2.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(gtsam::Pose2::Expmap(v))),"gtsam.Pose2", false);
}

void gtsamPose2_Logmap_277(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("gtsamPose2.Logmap",nargout,nargin,1);
  gtsam::Pose2& p = *unwrap_shared_ptr< gtsam::Pose2 >(in[0], "ptr_gtsamPose2");
  out[0] = wrap< Vector >(gtsam::Pose2::Logmap(p));
}

void gtsamPose2_identity_278(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("gtsamPose2.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(gtsam::Pose2::identity())),"gtsam.Pose2", false);
}

void gtsamPose2_wedge_279(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("gtsamPose2.wedge",nargout,nargin,3);
  double vx = unwrap< double >(in[0]);
  double vy = unwrap< double >(in[1]);
  double w = unwrap< double >(in[2]);
  out[0] = wrap< Matrix >(gtsam::Pose2::wedge(vx,vy,w));
}

void gtsamPose2_string_deserialize_280(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> Shared;
  checkArguments("gtsamPose2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Pose2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Pose2", false);
}
void gtsamPose3_collectorInsertAndMakeBase_281(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPose3.insert(self);
}

void gtsamPose3_constructor_282(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3> Shared;

  Shared *self = new Shared(new gtsam::Pose3());
  collector_gtsamPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose3_constructor_283(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3> Shared;

  gtsam::Pose3& other = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::Pose3(other));
  collector_gtsamPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose3_constructor_284(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3> Shared;

  gtsam::Rot3& r = *unwrap_shared_ptr< gtsam::Rot3 >(in[0], "ptr_gtsamRot3");
  gtsam::Point3& t = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  Shared *self = new Shared(new gtsam::Pose3(r,t));
  collector_gtsamPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose3_constructor_285(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3> Shared;

  gtsam::Pose2& pose2 = *unwrap_shared_ptr< gtsam::Pose2 >(in[0], "ptr_gtsamPose2");
  Shared *self = new Shared(new gtsam::Pose3(pose2));
  collector_gtsamPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose3_constructor_286(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3> Shared;

  Matrix mat = unwrap< Matrix >(in[0]);
  Shared *self = new Shared(new gtsam::Pose3(mat));
  collector_gtsamPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose3_deconstructor_287(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("delete_gtsamPose3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPose3::iterator item;
  item = collector_gtsamPose3.find(self);
  if(item != collector_gtsamPose3.end()) {
    delete self;
    collector_gtsamPose3.erase(item);
  }
}

void gtsamPose3_Adjoint_288(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("Adjoint",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  Vector xi = unwrap< Vector >(in[1]);
  out[0] = wrap< Vector >(obj->Adjoint(xi));
}

void gtsamPose3_AdjointMap_289(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("AdjointMap",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap< Matrix >(obj->AdjointMap());
}

void gtsamPose3_between_290(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->between(pose))),"gtsam.Pose3", false);
}

void gtsamPose3_compose_291(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->compose(pose))),"gtsam.Pose3", false);
}

void gtsamPose3_equals_292(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(pose,tol));
}

void gtsamPose3_inverse_293(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->inverse())),"gtsam.Pose3", false);
}

void gtsamPose3_localCoordinates_294(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  out[0] = wrap< Vector >(obj->localCoordinates(pose));
}

void gtsamPose3_matrix_295(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("matrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap< Matrix >(obj->matrix());
}

void gtsamPose3_print_296(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPose3_range_297(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap< double >(obj->range(point));
}
void gtsamPose3_range_298(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  out[0] = wrap< double >(obj->range(pose));
}

void gtsamPose3_retract_299(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->retract(v))),"gtsam.Pose3", false);
}

void gtsamPose3_rotation_300(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("rotation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->rotation())),"gtsam.Rot3", false);
}

void gtsamPose3_transform_from_301(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("transform_from",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->transform_from(point))),"gtsam.Point3", false);
}

void gtsamPose3_transform_to_302(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("transform_to",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->transform_to(point))),"gtsam.Point3", false);
}
void gtsamPose3_transform_to_303(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("transform_to",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->transform_to(pose))),"gtsam.Pose3", false);
}

void gtsamPose3_translation_304(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("translation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->translation())),"gtsam.Point3", false);
}

void gtsamPose3_x_305(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("x",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap< double >(obj->x());
}

void gtsamPose3_y_306(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("y",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap< double >(obj->y());
}

void gtsamPose3_z_307(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("z",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  out[0] = wrap< double >(obj->z());
}

void gtsamPose3_string_serialize_308(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3>(in[0], "ptr_gtsamPose3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPose3_Expmap_309(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("gtsamPose3.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(gtsam::Pose3::Expmap(v))),"gtsam.Pose3", false);
}

void gtsamPose3_Logmap_310(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("gtsamPose3.Logmap",nargout,nargin,1);
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  out[0] = wrap< Vector >(gtsam::Pose3::Logmap(pose));
}

void gtsamPose3_identity_311(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("gtsamPose3.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(gtsam::Pose3::identity())),"gtsam.Pose3", false);
}

void gtsamPose3_wedge_312(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("gtsamPose3.wedge",nargout,nargin,6);
  double wx = unwrap< double >(in[0]);
  double wy = unwrap< double >(in[1]);
  double wz = unwrap< double >(in[2]);
  double vx = unwrap< double >(in[3]);
  double vy = unwrap< double >(in[4]);
  double vz = unwrap< double >(in[5]);
  out[0] = wrap< Matrix >(gtsam::Pose3::wedge(wx,wy,wz,vx,vy,vz));
}

void gtsamPose3_string_deserialize_313(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> Shared;
  checkArguments("gtsamPose3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Pose3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Pose3", false);
}
void gtsamPose3Vector_collectorInsertAndMakeBase_314(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3Vector> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPose3Vector.insert(self);
}

void gtsamPose3Vector_constructor_315(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3Vector> Shared;

  Shared *self = new Shared(new gtsam::Pose3Vector());
  collector_gtsamPose3Vector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPose3Vector_deconstructor_316(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3Vector> Shared;
  checkArguments("delete_gtsamPose3Vector",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPose3Vector::iterator item;
  item = collector_gtsamPose3Vector.find(self);
  if(item != collector_gtsamPose3Vector.end()) {
    delete self;
    collector_gtsamPose3Vector.erase(item);
  }
}

void gtsamPose3Vector_at_317(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Pose3Vector> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3Vector>(in[0], "ptr_gtsamPose3Vector");
  size_t n = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->at(n))),"gtsam.Pose3", false);
}

void gtsamPose3Vector_empty_318(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3Vector> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3Vector>(in[0], "ptr_gtsamPose3Vector");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamPose3Vector_push_back_319(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3Vector> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3Vector>(in[0], "ptr_gtsamPose3Vector");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  obj->push_back(pose);
}

void gtsamPose3Vector_size_320(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3Vector> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3Vector>(in[0], "ptr_gtsamPose3Vector");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamUnit3_collectorInsertAndMakeBase_321(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Unit3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamUnit3.insert(self);
}

void gtsamUnit3_constructor_322(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Unit3> Shared;

  Shared *self = new Shared(new gtsam::Unit3());
  collector_gtsamUnit3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamUnit3_constructor_323(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Unit3> Shared;

  gtsam::Point3& pose = *unwrap_shared_ptr< gtsam::Point3 >(in[0], "ptr_gtsamPoint3");
  Shared *self = new Shared(new gtsam::Unit3(pose));
  collector_gtsamUnit3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamUnit3_deconstructor_324(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("delete_gtsamUnit3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamUnit3::iterator item;
  item = collector_gtsamUnit3.find(self);
  if(item != collector_gtsamUnit3.end()) {
    delete self;
    collector_gtsamUnit3.erase(item);
  }
}

void gtsamUnit3_basis_325(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("basis",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Unit3>(in[0], "ptr_gtsamUnit3");
  out[0] = wrap< Matrix >(obj->basis());
}

void gtsamUnit3_dim_326(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Unit3>(in[0], "ptr_gtsamUnit3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamUnit3_equals_327(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Unit3>(in[0], "ptr_gtsamUnit3");
  gtsam::Unit3& pose = *unwrap_shared_ptr< gtsam::Unit3 >(in[1], "ptr_gtsamUnit3");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(pose,tol));
}

void gtsamUnit3_localCoordinates_328(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Unit3>(in[0], "ptr_gtsamUnit3");
  gtsam::Unit3& s = *unwrap_shared_ptr< gtsam::Unit3 >(in[1], "ptr_gtsamUnit3");
  out[0] = wrap< Vector >(obj->localCoordinates(s));
}

void gtsamUnit3_print_329(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Unit3>(in[0], "ptr_gtsamUnit3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamUnit3_retract_330(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> SharedUnit3;
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Unit3>(in[0], "ptr_gtsamUnit3");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedUnit3(new gtsam::Unit3(obj->retract(v))),"gtsam.Unit3", false);
}

void gtsamUnit3_skew_331(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("skew",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Unit3>(in[0], "ptr_gtsamUnit3");
  out[0] = wrap< Matrix >(obj->skew());
}

void gtsamUnit3_Dim_332(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> Shared;
  checkArguments("gtsamUnit3.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::Unit3::Dim());
}

void gtsamEssentialMatrix_collectorInsertAndMakeBase_333(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamEssentialMatrix.insert(self);
}

void gtsamEssentialMatrix_constructor_334(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;

  gtsam::Rot3& aRb = *unwrap_shared_ptr< gtsam::Rot3 >(in[0], "ptr_gtsamRot3");
  gtsam::Unit3& aTb = *unwrap_shared_ptr< gtsam::Unit3 >(in[1], "ptr_gtsamUnit3");
  Shared *self = new Shared(new gtsam::EssentialMatrix(aRb,aTb));
  collector_gtsamEssentialMatrix.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamEssentialMatrix_deconstructor_335(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("delete_gtsamEssentialMatrix",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamEssentialMatrix::iterator item;
  item = collector_gtsamEssentialMatrix.find(self);
  if(item != collector_gtsamEssentialMatrix.end()) {
    delete self;
    collector_gtsamEssentialMatrix.erase(item);
  }
}

void gtsamEssentialMatrix_dim_336(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamEssentialMatrix_direction_337(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> SharedUnit3;
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("direction",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  out[0] = wrap_shared_ptr(SharedUnit3(new gtsam::Unit3(obj->direction())),"gtsam.Unit3", false);
}

void gtsamEssentialMatrix_equals_338(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  gtsam::EssentialMatrix& pose = *unwrap_shared_ptr< gtsam::EssentialMatrix >(in[1], "ptr_gtsamEssentialMatrix");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(pose,tol));
}

void gtsamEssentialMatrix_error_339(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("error",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  Vector vA = unwrap< Vector >(in[1]);
  Vector vB = unwrap< Vector >(in[2]);
  out[0] = wrap< double >(obj->error(vA,vB));
}

void gtsamEssentialMatrix_localCoordinates_340(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  gtsam::EssentialMatrix& s = *unwrap_shared_ptr< gtsam::EssentialMatrix >(in[1], "ptr_gtsamEssentialMatrix");
  out[0] = wrap< Vector >(obj->localCoordinates(s));
}

void gtsamEssentialMatrix_matrix_341(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("matrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  out[0] = wrap< Matrix >(obj->matrix());
}

void gtsamEssentialMatrix_print_342(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamEssentialMatrix_retract_343(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> SharedEssentialMatrix;
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedEssentialMatrix(new gtsam::EssentialMatrix(obj->retract(v))),"gtsam.EssentialMatrix", false);
}

void gtsamEssentialMatrix_rotation_344(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("rotation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrix>(in[0], "ptr_gtsamEssentialMatrix");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->rotation())),"gtsam.Rot3", false);
}

void gtsamEssentialMatrix_Dim_345(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> Shared;
  checkArguments("gtsamEssentialMatrix.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::EssentialMatrix::Dim());
}

void gtsamCal3_S2_collectorInsertAndMakeBase_346(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCal3_S2.insert(self);
}

void gtsamCal3_S2_constructor_347(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;

  Shared *self = new Shared(new gtsam::Cal3_S2());
  collector_gtsamCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3_S2_constructor_348(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;

  double fx = unwrap< double >(in[0]);
  double fy = unwrap< double >(in[1]);
  double s = unwrap< double >(in[2]);
  double u0 = unwrap< double >(in[3]);
  double v0 = unwrap< double >(in[4]);
  Shared *self = new Shared(new gtsam::Cal3_S2(fx,fy,s,u0,v0));
  collector_gtsamCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3_S2_constructor_349(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::Cal3_S2(v));
  collector_gtsamCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3_S2_constructor_350(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;

  double fov = unwrap< double >(in[0]);
  int w = unwrap< int >(in[1]);
  int h = unwrap< int >(in[2]);
  Shared *self = new Shared(new gtsam::Cal3_S2(fov,w,h));
  collector_gtsamCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3_S2_deconstructor_351(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("delete_gtsamCal3_S2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCal3_S2::iterator item;
  item = collector_gtsamCal3_S2.find(self);
  if(item != collector_gtsamCal3_S2.end()) {
    delete self;
    collector_gtsamCal3_S2.erase(item);
  }
}

void gtsamCal3_S2_calibrate_352(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("calibrate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->calibrate(p))),"gtsam.Point2", false);
}

void gtsamCal3_S2_dim_353(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamCal3_S2_equals_354(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  gtsam::Cal3_S2& rhs = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(rhs,tol));
}

void gtsamCal3_S2_fx_355(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("fx",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< double >(obj->fx());
}

void gtsamCal3_S2_fy_356(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("fy",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< double >(obj->fy());
}

void gtsamCal3_S2_localCoordinates_357(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  gtsam::Cal3_S2& c = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  out[0] = wrap< Vector >(obj->localCoordinates(c));
}

void gtsamCal3_S2_matrix_358(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("matrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< Matrix >(obj->matrix());
}

void gtsamCal3_S2_matrix_inverse_359(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("matrix_inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< Matrix >(obj->matrix_inverse());
}

void gtsamCal3_S2_principalPoint_360(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("principalPoint",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->principalPoint())),"gtsam.Point2", false);
}

void gtsamCal3_S2_print_361(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCal3_S2_px_362(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("px",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< double >(obj->px());
}

void gtsamCal3_S2_py_363(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("py",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< double >(obj->py());
}

void gtsamCal3_S2_retract_364(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> SharedCal3_S2;
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedCal3_S2(new gtsam::Cal3_S2(obj->retract(v))),"gtsam.Cal3_S2", false);
}

void gtsamCal3_S2_skew_365(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("skew",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< double >(obj->skew());
}

void gtsamCal3_S2_uncalibrate_366(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("uncalibrate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->uncalibrate(p))),"gtsam.Point2", false);
}

void gtsamCal3_S2_vector_367(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamCal3_S2_string_serialize_368(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2>(in[0], "ptr_gtsamCal3_S2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamCal3_S2_Dim_369(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("gtsamCal3_S2.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::Cal3_S2::Dim());
}

void gtsamCal3_S2_string_deserialize_370(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> Shared;
  checkArguments("gtsamCal3_S2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Cal3_S2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Cal3_S2", false);
}
void gtsamCal3DS2_Base_collectorInsertAndMakeBase_371(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCal3DS2_Base.insert(self);
}

void gtsamCal3DS2_Base_upcastFromVoid_372(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::Cal3DS2_Base>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamCal3DS2_Base_constructor_373(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;

  Shared *self = new Shared(new gtsam::Cal3DS2_Base());
  collector_gtsamCal3DS2_Base.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3DS2_Base_deconstructor_374(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("delete_gtsamCal3DS2_Base",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCal3DS2_Base::iterator item;
  item = collector_gtsamCal3DS2_Base.find(self);
  if(item != collector_gtsamCal3DS2_Base.end()) {
    delete self;
    collector_gtsamCal3DS2_Base.erase(item);
  }
}

void gtsamCal3DS2_Base_K_375(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("K",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< Matrix >(obj->K());
}

void gtsamCal3DS2_Base_calibrate_376(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("calibrate",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->calibrate(p,tol))),"gtsam.Point2", false);
}

void gtsamCal3DS2_Base_fx_377(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("fx",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< double >(obj->fx());
}

void gtsamCal3DS2_Base_fy_378(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("fy",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< double >(obj->fy());
}

void gtsamCal3DS2_Base_k_379(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("k",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< Vector >(obj->k());
}

void gtsamCal3DS2_Base_k1_380(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("k1",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< double >(obj->k1());
}

void gtsamCal3DS2_Base_k2_381(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("k2",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< double >(obj->k2());
}

void gtsamCal3DS2_Base_print_382(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCal3DS2_Base_px_383(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("px",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< double >(obj->px());
}

void gtsamCal3DS2_Base_py_384(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("py",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< double >(obj->py());
}

void gtsamCal3DS2_Base_skew_385(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("skew",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< double >(obj->skew());
}

void gtsamCal3DS2_Base_uncalibrate_386(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("uncalibrate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->uncalibrate(p))),"gtsam.Point2", false);
}

void gtsamCal3DS2_Base_vector_387(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamCal3DS2_Base_string_serialize_388(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2_Base>(in[0], "ptr_gtsamCal3DS2_Base");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamCal3DS2_Base_string_deserialize_389(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> Shared;
  checkArguments("gtsamCal3DS2_Base.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Cal3DS2_Base());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Cal3DS2_Base", false);
}
void gtsamCal3DS2_collectorInsertAndMakeBase_390(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCal3DS2.insert(self);

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamCal3DS2_upcastFromVoid_391(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::Cal3DS2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamCal3DS2_constructor_392(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;

  Shared *self = new Shared(new gtsam::Cal3DS2());
  collector_gtsamCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3DS2_constructor_393(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;

  double fx = unwrap< double >(in[0]);
  double fy = unwrap< double >(in[1]);
  double s = unwrap< double >(in[2]);
  double u0 = unwrap< double >(in[3]);
  double v0 = unwrap< double >(in[4]);
  double k1 = unwrap< double >(in[5]);
  double k2 = unwrap< double >(in[6]);
  Shared *self = new Shared(new gtsam::Cal3DS2(fx,fy,s,u0,v0,k1,k2));
  collector_gtsamCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3DS2_constructor_394(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;

  double fx = unwrap< double >(in[0]);
  double fy = unwrap< double >(in[1]);
  double s = unwrap< double >(in[2]);
  double u0 = unwrap< double >(in[3]);
  double v0 = unwrap< double >(in[4]);
  double k1 = unwrap< double >(in[5]);
  double k2 = unwrap< double >(in[6]);
  double p1 = unwrap< double >(in[7]);
  double p2 = unwrap< double >(in[8]);
  Shared *self = new Shared(new gtsam::Cal3DS2(fx,fy,s,u0,v0,k1,k2,p1,p2));
  collector_gtsamCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3DS2_constructor_395(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::Cal3DS2(v));
  collector_gtsamCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3DS2_deconstructor_396(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("delete_gtsamCal3DS2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCal3DS2::iterator item;
  item = collector_gtsamCal3DS2.find(self);
  if(item != collector_gtsamCal3DS2.end()) {
    delete self;
    collector_gtsamCal3DS2.erase(item);
  }
}

void gtsamCal3DS2_K_397(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("K",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< Matrix >(obj->K());
}

void gtsamCal3DS2_calibrate_398(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("calibrate",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->calibrate(p,tol))),"gtsam.Point2", false);
}

void gtsamCal3DS2_dim_399(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamCal3DS2_equals_400(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  gtsam::Cal3DS2& rhs = *unwrap_shared_ptr< gtsam::Cal3DS2 >(in[1], "ptr_gtsamCal3DS2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(rhs,tol));
}

void gtsamCal3DS2_fx_401(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("fx",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< double >(obj->fx());
}

void gtsamCal3DS2_fy_402(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("fy",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< double >(obj->fy());
}

void gtsamCal3DS2_k_403(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("k",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< Vector >(obj->k());
}

void gtsamCal3DS2_k1_404(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("k1",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< double >(obj->k1());
}

void gtsamCal3DS2_k2_405(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("k2",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< double >(obj->k2());
}

void gtsamCal3DS2_localCoordinates_406(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  gtsam::Cal3DS2& c = *unwrap_shared_ptr< gtsam::Cal3DS2 >(in[1], "ptr_gtsamCal3DS2");
  out[0] = wrap< Vector >(obj->localCoordinates(c));
}

void gtsamCal3DS2_print_407(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCal3DS2_px_408(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("px",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< double >(obj->px());
}

void gtsamCal3DS2_py_409(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("py",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< double >(obj->py());
}

void gtsamCal3DS2_retract_410(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> SharedCal3DS2;
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(obj->retract(v).clone(),"gtsam.Cal3DS2", true);
}

void gtsamCal3DS2_skew_411(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("skew",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< double >(obj->skew());
}

void gtsamCal3DS2_uncalibrate_412(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("uncalibrate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->uncalibrate(p))),"gtsam.Point2", false);
}

void gtsamCal3DS2_vector_413(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamCal3DS2_string_serialize_414(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3DS2>(in[0], "ptr_gtsamCal3DS2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamCal3DS2_Dim_415(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("gtsamCal3DS2.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::Cal3DS2::Dim());
}

void gtsamCal3DS2_string_deserialize_416(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> Shared;
  checkArguments("gtsamCal3DS2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Cal3DS2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Cal3DS2", false);
}
void gtsamCal3Unified_collectorInsertAndMakeBase_417(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCal3Unified.insert(self);

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamCal3Unified_upcastFromVoid_418(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::Cal3Unified>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamCal3Unified_constructor_419(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;

  Shared *self = new Shared(new gtsam::Cal3Unified());
  collector_gtsamCal3Unified.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3Unified_constructor_420(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;

  double fx = unwrap< double >(in[0]);
  double fy = unwrap< double >(in[1]);
  double s = unwrap< double >(in[2]);
  double u0 = unwrap< double >(in[3]);
  double v0 = unwrap< double >(in[4]);
  double k1 = unwrap< double >(in[5]);
  double k2 = unwrap< double >(in[6]);
  Shared *self = new Shared(new gtsam::Cal3Unified(fx,fy,s,u0,v0,k1,k2));
  collector_gtsamCal3Unified.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3Unified_constructor_421(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;

  double fx = unwrap< double >(in[0]);
  double fy = unwrap< double >(in[1]);
  double s = unwrap< double >(in[2]);
  double u0 = unwrap< double >(in[3]);
  double v0 = unwrap< double >(in[4]);
  double k1 = unwrap< double >(in[5]);
  double k2 = unwrap< double >(in[6]);
  double p1 = unwrap< double >(in[7]);
  double p2 = unwrap< double >(in[8]);
  double xi = unwrap< double >(in[9]);
  Shared *self = new Shared(new gtsam::Cal3Unified(fx,fy,s,u0,v0,k1,k2,p1,p2,xi));
  collector_gtsamCal3Unified.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3Unified_constructor_422(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::Cal3Unified(v));
  collector_gtsamCal3Unified.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::Cal3DS2_Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCal3Unified_deconstructor_423(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("delete_gtsamCal3Unified",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCal3Unified::iterator item;
  item = collector_gtsamCal3Unified.find(self);
  if(item != collector_gtsamCal3Unified.end()) {
    delete self;
    collector_gtsamCal3Unified.erase(item);
  }
}

void gtsamCal3Unified_K_424(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("K",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< Matrix >(obj->K());
}

void gtsamCal3Unified_calibrate_425(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("calibrate",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->calibrate(p,tol))),"gtsam.Point2", false);
}

void gtsamCal3Unified_dim_426(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamCal3Unified_equals_427(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  gtsam::Cal3Unified& rhs = *unwrap_shared_ptr< gtsam::Cal3Unified >(in[1], "ptr_gtsamCal3Unified");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(rhs,tol));
}

void gtsamCal3Unified_fx_428(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("fx",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->fx());
}

void gtsamCal3Unified_fy_429(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("fy",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->fy());
}

void gtsamCal3Unified_k_430(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("k",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< Vector >(obj->k());
}

void gtsamCal3Unified_k1_431(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("k1",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->k1());
}

void gtsamCal3Unified_k2_432(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("k2",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->k2());
}

void gtsamCal3Unified_localCoordinates_433(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  gtsam::Cal3Unified& c = *unwrap_shared_ptr< gtsam::Cal3Unified >(in[1], "ptr_gtsamCal3Unified");
  out[0] = wrap< Vector >(obj->localCoordinates(c));
}

void gtsamCal3Unified_nPlaneToSpace_434(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("nPlaneToSpace",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->nPlaneToSpace(p))),"gtsam.Point2", false);
}

void gtsamCal3Unified_print_435(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCal3Unified_px_436(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("px",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->px());
}

void gtsamCal3Unified_py_437(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("py",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->py());
}

void gtsamCal3Unified_retract_438(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> SharedCal3Unified;
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(obj->retract(v).clone(),"gtsam.Cal3Unified", true);
}

void gtsamCal3Unified_skew_439(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("skew",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->skew());
}

void gtsamCal3Unified_spaceToNPlane_440(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("spaceToNPlane",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->spaceToNPlane(p))),"gtsam.Point2", false);
}

void gtsamCal3Unified_uncalibrate_441(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("uncalibrate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->uncalibrate(p))),"gtsam.Point2", false);
}

void gtsamCal3Unified_vector_442(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamCal3Unified_xi_443(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("xi",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  out[0] = wrap< double >(obj->xi());
}

void gtsamCal3Unified_string_serialize_444(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Unified>(in[0], "ptr_gtsamCal3Unified");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamCal3Unified_Dim_445(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("gtsamCal3Unified.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::Cal3Unified::Dim());
}

void gtsamCal3Unified_string_deserialize_446(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Unified> Shared;
  checkArguments("gtsamCal3Unified.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Cal3Unified());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Cal3Unified", false);
}
void gtsamCal3_S2Stereo_collectorInsertAndMakeBase_447(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCal3_S2Stereo.insert(self);
}

void gtsamCal3_S2Stereo_constructor_448(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;

  Shared *self = new Shared(new gtsam::Cal3_S2Stereo());
  collector_gtsamCal3_S2Stereo.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3_S2Stereo_constructor_449(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;

  double fx = unwrap< double >(in[0]);
  double fy = unwrap< double >(in[1]);
  double s = unwrap< double >(in[2]);
  double u0 = unwrap< double >(in[3]);
  double v0 = unwrap< double >(in[4]);
  double b = unwrap< double >(in[5]);
  Shared *self = new Shared(new gtsam::Cal3_S2Stereo(fx,fy,s,u0,v0,b));
  collector_gtsamCal3_S2Stereo.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3_S2Stereo_constructor_450(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::Cal3_S2Stereo(v));
  collector_gtsamCal3_S2Stereo.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3_S2Stereo_deconstructor_451(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("delete_gtsamCal3_S2Stereo",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCal3_S2Stereo::iterator item;
  item = collector_gtsamCal3_S2Stereo.find(self);
  if(item != collector_gtsamCal3_S2Stereo.end()) {
    delete self;
    collector_gtsamCal3_S2Stereo.erase(item);
  }
}

void gtsamCal3_S2Stereo_baseline_452(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("baseline",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  out[0] = wrap< double >(obj->baseline());
}

void gtsamCal3_S2Stereo_equals_453(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  gtsam::Cal3_S2Stereo& K = *unwrap_shared_ptr< gtsam::Cal3_S2Stereo >(in[1], "ptr_gtsamCal3_S2Stereo");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(K,tol));
}

void gtsamCal3_S2Stereo_fx_454(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("fx",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  out[0] = wrap< double >(obj->fx());
}

void gtsamCal3_S2Stereo_fy_455(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("fy",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  out[0] = wrap< double >(obj->fy());
}

void gtsamCal3_S2Stereo_principalPoint_456(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("principalPoint",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->principalPoint())),"gtsam.Point2", false);
}

void gtsamCal3_S2Stereo_print_457(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCal3_S2Stereo_px_458(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("px",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  out[0] = wrap< double >(obj->px());
}

void gtsamCal3_S2Stereo_py_459(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("py",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  out[0] = wrap< double >(obj->py());
}

void gtsamCal3_S2Stereo_skew_460(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> Shared;
  checkArguments("skew",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3_S2Stereo>(in[0], "ptr_gtsamCal3_S2Stereo");
  out[0] = wrap< double >(obj->skew());
}

void gtsamCal3Bundler_collectorInsertAndMakeBase_461(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCal3Bundler.insert(self);
}

void gtsamCal3Bundler_constructor_462(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;

  Shared *self = new Shared(new gtsam::Cal3Bundler());
  collector_gtsamCal3Bundler.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3Bundler_constructor_463(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;

  double fx = unwrap< double >(in[0]);
  double k1 = unwrap< double >(in[1]);
  double k2 = unwrap< double >(in[2]);
  double u0 = unwrap< double >(in[3]);
  double v0 = unwrap< double >(in[4]);
  Shared *self = new Shared(new gtsam::Cal3Bundler(fx,k1,k2,u0,v0));
  collector_gtsamCal3Bundler.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCal3Bundler_deconstructor_464(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("delete_gtsamCal3Bundler",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCal3Bundler::iterator item;
  item = collector_gtsamCal3Bundler.find(self);
  if(item != collector_gtsamCal3Bundler.end()) {
    delete self;
    collector_gtsamCal3Bundler.erase(item);
  }
}

void gtsamCal3Bundler_calibrate_465(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("calibrate",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->calibrate(p,tol))),"gtsam.Point2", false);
}

void gtsamCal3Bundler_dim_466(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamCal3Bundler_equals_467(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  gtsam::Cal3Bundler& rhs = *unwrap_shared_ptr< gtsam::Cal3Bundler >(in[1], "ptr_gtsamCal3Bundler");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(rhs,tol));
}

void gtsamCal3Bundler_fx_468(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("fx",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< double >(obj->fx());
}

void gtsamCal3Bundler_fy_469(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("fy",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< double >(obj->fy());
}

void gtsamCal3Bundler_k_470(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("k",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< Vector >(obj->k());
}

void gtsamCal3Bundler_k1_471(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("k1",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< double >(obj->k1());
}

void gtsamCal3Bundler_k2_472(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("k2",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< double >(obj->k2());
}

void gtsamCal3Bundler_localCoordinates_473(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  gtsam::Cal3Bundler& c = *unwrap_shared_ptr< gtsam::Cal3Bundler >(in[1], "ptr_gtsamCal3Bundler");
  out[0] = wrap< Vector >(obj->localCoordinates(c));
}

void gtsamCal3Bundler_print_474(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCal3Bundler_retract_475(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> SharedCal3Bundler;
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedCal3Bundler(new gtsam::Cal3Bundler(obj->retract(v))),"gtsam.Cal3Bundler", false);
}

void gtsamCal3Bundler_u0_476(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("u0",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< double >(obj->u0());
}

void gtsamCal3Bundler_uncalibrate_477(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("uncalibrate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->uncalibrate(p))),"gtsam.Point2", false);
}

void gtsamCal3Bundler_v0_478(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("v0",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< double >(obj->v0());
}

void gtsamCal3Bundler_vector_479(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamCal3Bundler_string_serialize_480(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Cal3Bundler>(in[0], "ptr_gtsamCal3Bundler");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamCal3Bundler_Dim_481(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("gtsamCal3Bundler.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::Cal3Bundler::Dim());
}

void gtsamCal3Bundler_string_deserialize_482(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> Shared;
  checkArguments("gtsamCal3Bundler.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Cal3Bundler());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Cal3Bundler", false);
}
void gtsamCalibratedCamera_collectorInsertAndMakeBase_483(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCalibratedCamera.insert(self);
}

void gtsamCalibratedCamera_constructor_484(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;

  Shared *self = new Shared(new gtsam::CalibratedCamera());
  collector_gtsamCalibratedCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCalibratedCamera_constructor_485(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;

  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::CalibratedCamera(pose));
  collector_gtsamCalibratedCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCalibratedCamera_constructor_486(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;

  Vector v = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::CalibratedCamera(v));
  collector_gtsamCalibratedCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamCalibratedCamera_deconstructor_487(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("delete_gtsamCalibratedCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCalibratedCamera::iterator item;
  item = collector_gtsamCalibratedCamera.find(self);
  if(item != collector_gtsamCalibratedCamera.end()) {
    delete self;
    collector_gtsamCalibratedCamera.erase(item);
  }
}

void gtsamCalibratedCamera_dim_488(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamCalibratedCamera_equals_489(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  gtsam::CalibratedCamera& camera = *unwrap_shared_ptr< gtsam::CalibratedCamera >(in[1], "ptr_gtsamCalibratedCamera");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(camera,tol));
}

void gtsamCalibratedCamera_localCoordinates_490(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  gtsam::CalibratedCamera& T2 = *unwrap_shared_ptr< gtsam::CalibratedCamera >(in[1], "ptr_gtsamCalibratedCamera");
  out[0] = wrap< Vector >(obj->localCoordinates(T2));
}

void gtsamCalibratedCamera_pose_491(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("pose",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->pose())),"gtsam.Pose3", false);
}

void gtsamCalibratedCamera_print_492(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCalibratedCamera_project_493(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("project",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->project(point))),"gtsam.Point2", false);
}

void gtsamCalibratedCamera_range_494(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  gtsam::Point3& p = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap< double >(obj->range(p));
}

void gtsamCalibratedCamera_retract_495(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> SharedCalibratedCamera;
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  Vector d = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedCalibratedCamera(new gtsam::CalibratedCamera(obj->retract(d))),"gtsam.CalibratedCamera", false);
}

void gtsamCalibratedCamera_string_serialize_496(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CalibratedCamera>(in[0], "ptr_gtsamCalibratedCamera");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamCalibratedCamera_Dim_497(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("gtsamCalibratedCamera.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::CalibratedCamera::Dim());
}

void gtsamCalibratedCamera_Level_498(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> SharedCalibratedCamera;
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("gtsamCalibratedCamera.Level",nargout,nargin,2);
  gtsam::Pose2& pose2 = *unwrap_shared_ptr< gtsam::Pose2 >(in[0], "ptr_gtsamPose2");
  double height = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(SharedCalibratedCamera(new gtsam::CalibratedCamera(gtsam::CalibratedCamera::Level(pose2,height))),"gtsam.CalibratedCamera", false);
}

void gtsamCalibratedCamera_Project_499(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("gtsamCalibratedCamera.Project",nargout,nargin,1);
  gtsam::Point3& cameraPoint = *unwrap_shared_ptr< gtsam::Point3 >(in[0], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(gtsam::CalibratedCamera::Project(cameraPoint))),"gtsam.Point2", false);
}

void gtsamCalibratedCamera_string_deserialize_500(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> Shared;
  checkArguments("gtsamCalibratedCamera.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::CalibratedCamera());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.CalibratedCamera", false);
}
void gtsamSimpleCamera_collectorInsertAndMakeBase_501(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSimpleCamera.insert(self);
}

void gtsamSimpleCamera_upcastFromVoid_502(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::SimpleCamera>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamSimpleCamera_constructor_503(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;

  Shared *self = new Shared(new gtsam::SimpleCamera());
  collector_gtsamSimpleCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSimpleCamera_constructor_504(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;

  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::SimpleCamera(pose));
  collector_gtsamSimpleCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSimpleCamera_constructor_505(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;

  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  gtsam::Cal3_S2& K = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  Shared *self = new Shared(new gtsam::SimpleCamera(pose,K));
  collector_gtsamSimpleCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSimpleCamera_deconstructor_506(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("delete_gtsamSimpleCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSimpleCamera::iterator item;
  item = collector_gtsamSimpleCamera.find(self);
  if(item != collector_gtsamSimpleCamera.end()) {
    delete self;
    collector_gtsamSimpleCamera.erase(item);
  }
}

void gtsamSimpleCamera_backproject_507(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("backproject",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double depth = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->backproject(p,depth))),"gtsam.Point3", false);
}

void gtsamSimpleCamera_calibration_508(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> SharedCal3_S2;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("calibration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  out[0] = wrap_shared_ptr(SharedCal3_S2(new gtsam::Cal3_S2(obj->calibration())),"gtsam.Cal3_S2", false);
}

void gtsamSimpleCamera_dim_509(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamSimpleCamera_equals_510(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  gtsam::SimpleCamera& camera = *unwrap_shared_ptr< gtsam::SimpleCamera >(in[1], "ptr_gtsamSimpleCamera");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(camera,tol));
}

void gtsamSimpleCamera_localCoordinates_511(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  gtsam::SimpleCamera& T2 = *unwrap_shared_ptr< gtsam::SimpleCamera >(in[1], "ptr_gtsamSimpleCamera");
  out[0] = wrap< Vector >(obj->localCoordinates(T2));
}

void gtsamSimpleCamera_pose_512(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("pose",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->pose())),"gtsam.Pose3", false);
}

void gtsamSimpleCamera_print_513(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamSimpleCamera_project_514(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("project",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->project(point))),"gtsam.Point2", false);
}

void gtsamSimpleCamera_projectSafe_515(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("projectSafe",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  gtsam::Point3& pw = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  pair< gtsam::Point2, bool > pairResult = obj->projectSafe(pw);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(pairResult.first)),"gtsam.Point2", false);
  out[1] = wrap< bool >(pairResult.second);
}

void gtsamSimpleCamera_range_516(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap< double >(obj->range(point));
}
void gtsamSimpleCamera_range_517(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  out[0] = wrap< double >(obj->range(pose));
}

void gtsamSimpleCamera_retract_518(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> SharedSimpleCamera;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  Vector d = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(obj->retract(d).clone(),"gtsam.SimpleCamera", true);
}

void gtsamSimpleCamera_string_serialize_519(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SimpleCamera>(in[0], "ptr_gtsamSimpleCamera");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamSimpleCamera_Dim_520(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("gtsamSimpleCamera.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::SimpleCamera::Dim());
}

void gtsamSimpleCamera_Level_521(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> SharedSimpleCamera;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("gtsamSimpleCamera.Level",nargout,nargin,3);
  gtsam::Cal3_S2& K = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[0], "ptr_gtsamCal3_S2");
  gtsam::Pose2& pose = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  double height = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(gtsam::SimpleCamera::Level(K,pose,height).clone(),"gtsam.SimpleCamera", true);
}
void gtsamSimpleCamera_Level_522(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> SharedSimpleCamera;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("gtsamSimpleCamera.Level",nargout,nargin,2);
  gtsam::Pose2& pose = *unwrap_shared_ptr< gtsam::Pose2 >(in[0], "ptr_gtsamPose2");
  double height = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::SimpleCamera::Level(pose,height).clone(),"gtsam.SimpleCamera", true);
}

void gtsamSimpleCamera_Lookat_523(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> SharedSimpleCamera;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("gtsamSimpleCamera.Lookat",nargout,nargin,4);
  gtsam::Point3& eye = *unwrap_shared_ptr< gtsam::Point3 >(in[0], "ptr_gtsamPoint3");
  gtsam::Point3& target = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  gtsam::Point3& upVector = *unwrap_shared_ptr< gtsam::Point3 >(in[2], "ptr_gtsamPoint3");
  gtsam::Cal3_S2& K = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[3], "ptr_gtsamCal3_S2");
  out[0] = wrap_shared_ptr(gtsam::SimpleCamera::Lookat(eye,target,upVector,K).clone(),"gtsam.SimpleCamera", true);
}

void gtsamSimpleCamera_Project_524(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("gtsamSimpleCamera.Project",nargout,nargin,1);
  gtsam::Point3& cameraPoint = *unwrap_shared_ptr< gtsam::Point3 >(in[0], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(gtsam::SimpleCamera::Project(cameraPoint))),"gtsam.Point2", false);
}

void gtsamSimpleCamera_string_deserialize_525(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> Shared;
  checkArguments("gtsamSimpleCamera.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::SimpleCamera());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.SimpleCamera", false);
}
void gtsamStereoCamera_collectorInsertAndMakeBase_526(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamStereoCamera.insert(self);
}

void gtsamStereoCamera_constructor_527(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;

  Shared *self = new Shared(new gtsam::StereoCamera());
  collector_gtsamStereoCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamStereoCamera_constructor_528(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;

  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  boost::shared_ptr<gtsam::Cal3_S2Stereo> K = unwrap_shared_ptr< gtsam::Cal3_S2Stereo >(in[1], "ptr_gtsamCal3_S2Stereo");
  Shared *self = new Shared(new gtsam::StereoCamera(pose,K));
  collector_gtsamStereoCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamStereoCamera_deconstructor_529(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("delete_gtsamStereoCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamStereoCamera::iterator item;
  item = collector_gtsamStereoCamera.find(self);
  if(item != collector_gtsamStereoCamera.end()) {
    delete self;
    collector_gtsamStereoCamera.erase(item);
  }
}

void gtsamStereoCamera_backproject_530(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("backproject",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  gtsam::StereoPoint2& p = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->backproject(p))),"gtsam.Point3", false);
}

void gtsamStereoCamera_baseline_531(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("baseline",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  out[0] = wrap< double >(obj->baseline());
}

void gtsamStereoCamera_calibration_532(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> SharedCal3_S2Stereo;
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("calibration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  out[0] = wrap_shared_ptr(SharedCal3_S2Stereo(new gtsam::Cal3_S2Stereo(obj->calibration())),"gtsam.Cal3_S2Stereo", false);
}

void gtsamStereoCamera_dim_533(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamStereoCamera_equals_534(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  gtsam::StereoCamera& camera = *unwrap_shared_ptr< gtsam::StereoCamera >(in[1], "ptr_gtsamStereoCamera");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(camera,tol));
}

void gtsamStereoCamera_localCoordinates_535(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  gtsam::StereoCamera& T2 = *unwrap_shared_ptr< gtsam::StereoCamera >(in[1], "ptr_gtsamStereoCamera");
  out[0] = wrap< Vector >(obj->localCoordinates(T2));
}

void gtsamStereoCamera_pose_536(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("pose",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->pose())),"gtsam.Pose3", false);
}

void gtsamStereoCamera_print_537(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamStereoCamera_project_538(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("project",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(obj->project(point))),"gtsam.StereoPoint2", false);
}

void gtsamStereoCamera_retract_539(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> SharedStereoCamera;
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  Vector d = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedStereoCamera(new gtsam::StereoCamera(obj->retract(d))),"gtsam.StereoCamera", false);
}

void gtsamStereoCamera_string_serialize_540(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::StereoCamera>(in[0], "ptr_gtsamStereoCamera");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamStereoCamera_Dim_541(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("gtsamStereoCamera.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::StereoCamera::Dim());
}

void gtsamStereoCamera_string_deserialize_542(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoCamera> Shared;
  checkArguments("gtsamStereoCamera.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::StereoCamera());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.StereoCamera", false);
}
void gtsamSymbolicFactor_collectorInsertAndMakeBase_543(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSymbolicFactor.insert(self);
}

void gtsamSymbolicFactor_upcastFromVoid_544(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::SymbolicFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_545(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  gtsam::SymbolicFactor& f = *unwrap_shared_ptr< gtsam::SymbolicFactor >(in[0], "ptr_gtsamSymbolicFactor");
  Shared *self = new Shared(new gtsam::SymbolicFactor(f));
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_546(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  Shared *self = new Shared(new gtsam::SymbolicFactor());
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_547(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  size_t j = unwrap< size_t >(in[0]);
  Shared *self = new Shared(new gtsam::SymbolicFactor(j));
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_548(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  size_t j1 = unwrap< size_t >(in[0]);
  size_t j2 = unwrap< size_t >(in[1]);
  Shared *self = new Shared(new gtsam::SymbolicFactor(j1,j2));
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_549(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  size_t j1 = unwrap< size_t >(in[0]);
  size_t j2 = unwrap< size_t >(in[1]);
  size_t j3 = unwrap< size_t >(in[2]);
  Shared *self = new Shared(new gtsam::SymbolicFactor(j1,j2,j3));
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_550(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  size_t j1 = unwrap< size_t >(in[0]);
  size_t j2 = unwrap< size_t >(in[1]);
  size_t j3 = unwrap< size_t >(in[2]);
  size_t j4 = unwrap< size_t >(in[3]);
  Shared *self = new Shared(new gtsam::SymbolicFactor(j1,j2,j3,j4));
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_551(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  size_t j1 = unwrap< size_t >(in[0]);
  size_t j2 = unwrap< size_t >(in[1]);
  size_t j3 = unwrap< size_t >(in[2]);
  size_t j4 = unwrap< size_t >(in[3]);
  size_t j5 = unwrap< size_t >(in[4]);
  Shared *self = new Shared(new gtsam::SymbolicFactor(j1,j2,j3,j4,j5));
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_constructor_552(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;

  size_t j1 = unwrap< size_t >(in[0]);
  size_t j2 = unwrap< size_t >(in[1]);
  size_t j3 = unwrap< size_t >(in[2]);
  size_t j4 = unwrap< size_t >(in[3]);
  size_t j5 = unwrap< size_t >(in[4]);
  size_t j6 = unwrap< size_t >(in[5]);
  Shared *self = new Shared(new gtsam::SymbolicFactor(j1,j2,j3,j4,j5,j6));
  collector_gtsamSymbolicFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactor_deconstructor_553(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;
  checkArguments("delete_gtsamSymbolicFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSymbolicFactor::iterator item;
  item = collector_gtsamSymbolicFactor.find(self);
  if(item != collector_gtsamSymbolicFactor.end()) {
    delete self;
    collector_gtsamSymbolicFactor.erase(item);
  }
}

void gtsamSymbolicFactor_equals_554(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactor>(in[0], "ptr_gtsamSymbolicFactor");
  gtsam::SymbolicFactor& other = *unwrap_shared_ptr< gtsam::SymbolicFactor >(in[1], "ptr_gtsamSymbolicFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamSymbolicFactor_keys_555(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactor>(in[0], "ptr_gtsamSymbolicFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamSymbolicFactor_print_556(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactor>(in[0], "ptr_gtsamSymbolicFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamSymbolicFactor_size_557(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactor>(in[0], "ptr_gtsamSymbolicFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamSymbolicFactor_FromKeys_558(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedSymbolicFactor;
  typedef boost::shared_ptr<gtsam::SymbolicFactor> Shared;
  checkArguments("gtsamSymbolicFactor.FromKeys",nargout,nargin,1);
  gtsam::KeyVector& js = *unwrap_shared_ptr< gtsam::KeyVector >(in[0], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(gtsam::SymbolicFactor::FromKeys(js).clone(),"gtsam.SymbolicFactor", true);
}

void gtsamSymbolicFactorGraph_collectorInsertAndMakeBase_559(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSymbolicFactorGraph.insert(self);
}

void gtsamSymbolicFactorGraph_upcastFromVoid_560(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::SymbolicFactorGraph>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamSymbolicFactorGraph_constructor_561(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;

  Shared *self = new Shared(new gtsam::SymbolicFactorGraph());
  collector_gtsamSymbolicFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactorGraph_constructor_562(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;

  gtsam::SymbolicBayesNet& bayesNet = *unwrap_shared_ptr< gtsam::SymbolicBayesNet >(in[0], "ptr_gtsamSymbolicBayesNet");
  Shared *self = new Shared(new gtsam::SymbolicFactorGraph(bayesNet));
  collector_gtsamSymbolicFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactorGraph_constructor_563(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;

  gtsam::SymbolicBayesTree& bayesTree = *unwrap_shared_ptr< gtsam::SymbolicBayesTree >(in[0], "ptr_gtsamSymbolicBayesTree");
  Shared *self = new Shared(new gtsam::SymbolicFactorGraph(bayesTree));
  collector_gtsamSymbolicFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicFactorGraph_deconstructor_564(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("delete_gtsamSymbolicFactorGraph",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSymbolicFactorGraph::iterator item;
  item = collector_gtsamSymbolicFactorGraph.find(self);
  if(item != collector_gtsamSymbolicFactorGraph.end()) {
    delete self;
    collector_gtsamSymbolicFactorGraph.erase(item);
  }
}

void gtsamSymbolicFactorGraph_eliminateMultifrontal_565(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> SharedSymbolicBayesTree;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminateMultifrontal",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  out[0] = wrap_shared_ptr(obj->eliminateMultifrontal(),"gtsam.SymbolicBayesTree", false);
}
void gtsamSymbolicFactorGraph_eliminateMultifrontal_566(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> SharedSymbolicBayesTree;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminateMultifrontal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->eliminateMultifrontal(ordering),"gtsam.SymbolicBayesTree", false);
}

void gtsamSymbolicFactorGraph_eliminatePartialMultifrontal_567(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> SharedSymbolicBayesTree;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> SharedSymbolicFactorGraph;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminatePartialMultifrontal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  pair< SharedSymbolicBayesTree, SharedSymbolicFactorGraph > pairResult = obj->eliminatePartialMultifrontal(ordering);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.SymbolicBayesTree", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.SymbolicFactorGraph", true);
}
void gtsamSymbolicFactorGraph_eliminatePartialMultifrontal_568(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> SharedSymbolicBayesTree;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> SharedSymbolicFactorGraph;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminatePartialMultifrontal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  pair< SharedSymbolicBayesTree, SharedSymbolicFactorGraph > pairResult = obj->eliminatePartialMultifrontal(keys);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.SymbolicBayesTree", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.SymbolicFactorGraph", true);
}

void gtsamSymbolicFactorGraph_eliminatePartialSequential_569(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> SharedSymbolicFactorGraph;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminatePartialSequential",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  pair< SharedSymbolicBayesNet, SharedSymbolicFactorGraph > pairResult = obj->eliminatePartialSequential(ordering);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.SymbolicBayesNet", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.SymbolicFactorGraph", true);
}
void gtsamSymbolicFactorGraph_eliminatePartialSequential_570(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> SharedSymbolicFactorGraph;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminatePartialSequential",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  pair< SharedSymbolicBayesNet, SharedSymbolicFactorGraph > pairResult = obj->eliminatePartialSequential(keys);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.SymbolicBayesNet", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.SymbolicFactorGraph", true);
}

void gtsamSymbolicFactorGraph_eliminateSequential_571(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminateSequential",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  out[0] = wrap_shared_ptr(obj->eliminateSequential(),"gtsam.SymbolicBayesNet", false);
}
void gtsamSymbolicFactorGraph_eliminateSequential_572(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("eliminateSequential",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->eliminateSequential(ordering),"gtsam.SymbolicBayesNet", false);
}

void gtsamSymbolicFactorGraph_equals_573(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::SymbolicFactorGraph& rhs = *unwrap_shared_ptr< gtsam::SymbolicFactorGraph >(in[1], "ptr_gtsamSymbolicFactorGraph");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(rhs,tol));
}

void gtsamSymbolicFactorGraph_exists_574(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("exists",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->exists(idx));
}

void gtsamSymbolicFactorGraph_keys_575(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> SharedKeySet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  out[0] = wrap_shared_ptr(SharedKeySet(new gtsam::KeySet(obj->keys())),"gtsam.KeySet", false);
}

void gtsamSymbolicFactorGraph_marginal_576(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> SharedSymbolicFactorGraph;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("marginal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::KeyVector& key_vector = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(obj->marginal(key_vector),"gtsam.SymbolicFactorGraph", true);
}

void gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_577(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(ordering),"gtsam.SymbolicBayesNet", false);
}
void gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_578(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::KeyVector& key_vector = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(key_vector),"gtsam.SymbolicBayesNet", false);
}
void gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_579(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  gtsam::Ordering& marginalizedVariableOrdering = *unwrap_shared_ptr< gtsam::Ordering >(in[2], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(ordering,marginalizedVariableOrdering),"gtsam.SymbolicBayesNet", false);
}
void gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_580(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::KeyVector& key_vector = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  gtsam::Ordering& marginalizedVariableOrdering = *unwrap_shared_ptr< gtsam::Ordering >(in[2], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(key_vector,marginalizedVariableOrdering),"gtsam.SymbolicBayesNet", false);
}

void gtsamSymbolicFactorGraph_print_581(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamSymbolicFactorGraph_push_back_582(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  boost::shared_ptr<gtsam::SymbolicFactor> factor = unwrap_shared_ptr< gtsam::SymbolicFactor >(in[1], "ptr_gtsamSymbolicFactor");
  obj->push_back(factor);
}
void gtsamSymbolicFactorGraph_push_back_583(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::SymbolicFactorGraph& graph = *unwrap_shared_ptr< gtsam::SymbolicFactorGraph >(in[1], "ptr_gtsamSymbolicFactorGraph");
  obj->push_back(graph);
}
void gtsamSymbolicFactorGraph_push_back_584(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::SymbolicBayesNet& bayesNet = *unwrap_shared_ptr< gtsam::SymbolicBayesNet >(in[1], "ptr_gtsamSymbolicBayesNet");
  obj->push_back(bayesNet);
}
void gtsamSymbolicFactorGraph_push_back_585(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  gtsam::SymbolicBayesTree& bayesTree = *unwrap_shared_ptr< gtsam::SymbolicBayesTree >(in[1], "ptr_gtsamSymbolicBayesTree");
  obj->push_back(bayesTree);
}

void gtsamSymbolicFactorGraph_push_factor_586(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_factor",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  size_t key = unwrap< size_t >(in[1]);
  obj->push_factor(key);
}
void gtsamSymbolicFactorGraph_push_factor_587(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_factor",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  size_t key1 = unwrap< size_t >(in[1]);
  size_t key2 = unwrap< size_t >(in[2]);
  obj->push_factor(key1,key2);
}
void gtsamSymbolicFactorGraph_push_factor_588(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_factor",nargout,nargin-1,3);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  size_t key1 = unwrap< size_t >(in[1]);
  size_t key2 = unwrap< size_t >(in[2]);
  size_t key3 = unwrap< size_t >(in[3]);
  obj->push_factor(key1,key2,key3);
}
void gtsamSymbolicFactorGraph_push_factor_589(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("push_factor",nargout,nargin-1,4);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  size_t key1 = unwrap< size_t >(in[1]);
  size_t key2 = unwrap< size_t >(in[2]);
  size_t key3 = unwrap< size_t >(in[3]);
  size_t key4 = unwrap< size_t >(in[4]);
  obj->push_factor(key1,key2,key3,key4);
}

void gtsamSymbolicFactorGraph_size_590(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicFactorGraph>(in[0], "ptr_gtsamSymbolicFactorGraph");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamSymbolicConditional_collectorInsertAndMakeBase_591(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSymbolicConditional.insert(self);

  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamSymbolicConditional_upcastFromVoid_592(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::SymbolicConditional>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamSymbolicConditional_constructor_593(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;

  Shared *self = new Shared(new gtsam::SymbolicConditional());
  collector_gtsamSymbolicConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSymbolicConditional_constructor_594(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;

  gtsam::SymbolicConditional& other = *unwrap_shared_ptr< gtsam::SymbolicConditional >(in[0], "ptr_gtsamSymbolicConditional");
  Shared *self = new Shared(new gtsam::SymbolicConditional(other));
  collector_gtsamSymbolicConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSymbolicConditional_constructor_595(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Shared *self = new Shared(new gtsam::SymbolicConditional(key));
  collector_gtsamSymbolicConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSymbolicConditional_constructor_596(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  size_t parent = unwrap< size_t >(in[1]);
  Shared *self = new Shared(new gtsam::SymbolicConditional(key,parent));
  collector_gtsamSymbolicConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSymbolicConditional_constructor_597(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  size_t parent1 = unwrap< size_t >(in[1]);
  size_t parent2 = unwrap< size_t >(in[2]);
  Shared *self = new Shared(new gtsam::SymbolicConditional(key,parent1,parent2));
  collector_gtsamSymbolicConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSymbolicConditional_constructor_598(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  size_t parent1 = unwrap< size_t >(in[1]);
  size_t parent2 = unwrap< size_t >(in[2]);
  size_t parent3 = unwrap< size_t >(in[3]);
  Shared *self = new Shared(new gtsam::SymbolicConditional(key,parent1,parent2,parent3));
  collector_gtsamSymbolicConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::SymbolicFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSymbolicConditional_deconstructor_599(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("delete_gtsamSymbolicConditional",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSymbolicConditional::iterator item;
  item = collector_gtsamSymbolicConditional.find(self);
  if(item != collector_gtsamSymbolicConditional.end()) {
    delete self;
    collector_gtsamSymbolicConditional.erase(item);
  }
}

void gtsamSymbolicConditional_equals_600(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicConditional>(in[0], "ptr_gtsamSymbolicConditional");
  gtsam::SymbolicConditional& other = *unwrap_shared_ptr< gtsam::SymbolicConditional >(in[1], "ptr_gtsamSymbolicConditional");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamSymbolicConditional_keys_601(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicConditional>(in[0], "ptr_gtsamSymbolicConditional");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamSymbolicConditional_nrFrontals_602(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("nrFrontals",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicConditional>(in[0], "ptr_gtsamSymbolicConditional");
  out[0] = wrap< size_t >(obj->nrFrontals());
}

void gtsamSymbolicConditional_nrParents_603(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("nrParents",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicConditional>(in[0], "ptr_gtsamSymbolicConditional");
  out[0] = wrap< size_t >(obj->nrParents());
}

void gtsamSymbolicConditional_print_604(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicConditional>(in[0], "ptr_gtsamSymbolicConditional");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamSymbolicConditional_size_605(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicConditional>(in[0], "ptr_gtsamSymbolicConditional");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamSymbolicConditional_FromKeys_606(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> SharedSymbolicConditional;
  typedef boost::shared_ptr<gtsam::SymbolicConditional> Shared;
  checkArguments("gtsamSymbolicConditional.FromKeys",nargout,nargin,2);
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[0], "ptr_gtsamKeyVector");
  size_t nrFrontals = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::SymbolicConditional::FromKeys(keys,nrFrontals).clone(),"gtsam.SymbolicConditional", true);
}

void gtsamSymbolicBayesNet_collectorInsertAndMakeBase_607(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSymbolicBayesNet.insert(self);
}

void gtsamSymbolicBayesNet_constructor_608(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;

  Shared *self = new Shared(new gtsam::SymbolicBayesNet());
  collector_gtsamSymbolicBayesNet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicBayesNet_constructor_609(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;

  gtsam::SymbolicBayesNet& other = *unwrap_shared_ptr< gtsam::SymbolicBayesNet >(in[0], "ptr_gtsamSymbolicBayesNet");
  Shared *self = new Shared(new gtsam::SymbolicBayesNet(other));
  collector_gtsamSymbolicBayesNet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicBayesNet_deconstructor_610(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("delete_gtsamSymbolicBayesNet",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSymbolicBayesNet::iterator item;
  item = collector_gtsamSymbolicBayesNet.find(self);
  if(item != collector_gtsamSymbolicBayesNet.end()) {
    delete self;
    collector_gtsamSymbolicBayesNet.erase(item);
  }
}

void gtsamSymbolicBayesNet_at_611(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> SharedSymbolicConditional;
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->at(idx),"gtsam.SymbolicConditional", true);
}

void gtsamSymbolicBayesNet_back_612(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> SharedSymbolicConditional;
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("back",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  out[0] = wrap_shared_ptr(obj->back(),"gtsam.SymbolicConditional", true);
}

void gtsamSymbolicBayesNet_equals_613(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  gtsam::SymbolicBayesNet& other = *unwrap_shared_ptr< gtsam::SymbolicBayesNet >(in[1], "ptr_gtsamSymbolicBayesNet");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamSymbolicBayesNet_front_614(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> SharedSymbolicConditional;
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("front",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  out[0] = wrap_shared_ptr(obj->front(),"gtsam.SymbolicConditional", true);
}

void gtsamSymbolicBayesNet_print_615(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamSymbolicBayesNet_push_back_616(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  boost::shared_ptr<gtsam::SymbolicConditional> conditional = unwrap_shared_ptr< gtsam::SymbolicConditional >(in[1], "ptr_gtsamSymbolicConditional");
  obj->push_back(conditional);
}
void gtsamSymbolicBayesNet_push_back_617(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  gtsam::SymbolicBayesNet& bayesNet = *unwrap_shared_ptr< gtsam::SymbolicBayesNet >(in[1], "ptr_gtsamSymbolicBayesNet");
  obj->push_back(bayesNet);
}

void gtsamSymbolicBayesNet_saveGraph_618(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("saveGraph",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  string s = unwrap< string >(in[1]);
  obj->saveGraph(s);
}

void gtsamSymbolicBayesNet_size_619(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesNet>(in[0], "ptr_gtsamSymbolicBayesNet");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamSymbolicBayesTree_collectorInsertAndMakeBase_620(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSymbolicBayesTree.insert(self);
}

void gtsamSymbolicBayesTree_constructor_621(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;

  Shared *self = new Shared(new gtsam::SymbolicBayesTree());
  collector_gtsamSymbolicBayesTree.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicBayesTree_constructor_622(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;

  gtsam::SymbolicBayesTree& other = *unwrap_shared_ptr< gtsam::SymbolicBayesTree >(in[0], "ptr_gtsamSymbolicBayesTree");
  Shared *self = new Shared(new gtsam::SymbolicBayesTree(other));
  collector_gtsamSymbolicBayesTree.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSymbolicBayesTree_deconstructor_623(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("delete_gtsamSymbolicBayesTree",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSymbolicBayesTree::iterator item;
  item = collector_gtsamSymbolicBayesTree.find(self);
  if(item != collector_gtsamSymbolicBayesTree.end()) {
    delete self;
    collector_gtsamSymbolicBayesTree.erase(item);
  }
}

void gtsamSymbolicBayesTree_clear_624(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  obj->clear();
}

void gtsamSymbolicBayesTree_deleteCachedShortcuts_625(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("deleteCachedShortcuts",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  obj->deleteCachedShortcuts();
}

void gtsamSymbolicBayesTree_equals_626(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  gtsam::SymbolicBayesTree& other = *unwrap_shared_ptr< gtsam::SymbolicBayesTree >(in[1], "ptr_gtsamSymbolicBayesTree");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamSymbolicBayesTree_joint_627(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicFactorGraph> SharedSymbolicFactorGraph;
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("joint",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  size_t key1 = unwrap< size_t >(in[1]);
  size_t key2 = unwrap< size_t >(in[2]);
  out[0] = wrap_shared_ptr(obj->joint(key1,key2),"gtsam.SymbolicFactorGraph", true);
}

void gtsamSymbolicBayesTree_jointBayesNet_628(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesNet> SharedSymbolicBayesNet;
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("jointBayesNet",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  size_t key1 = unwrap< size_t >(in[1]);
  size_t key2 = unwrap< size_t >(in[2]);
  out[0] = wrap_shared_ptr(obj->jointBayesNet(key1,key2),"gtsam.SymbolicBayesNet", false);
}

void gtsamSymbolicBayesTree_marginalFactor_629(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicConditional> SharedSymbolicConditional;
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("marginalFactor",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->marginalFactor(key),"gtsam.SymbolicConditional", true);
}

void gtsamSymbolicBayesTree_numCachedSeparatorMarginals_630(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("numCachedSeparatorMarginals",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  out[0] = wrap< size_t >(obj->numCachedSeparatorMarginals());
}

void gtsamSymbolicBayesTree_print_631(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamSymbolicBayesTree_saveGraph_632(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("saveGraph",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  string s = unwrap< string >(in[1]);
  obj->saveGraph(s);
}

void gtsamSymbolicBayesTree_size_633(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SymbolicBayesTree> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SymbolicBayesTree>(in[0], "ptr_gtsamSymbolicBayesTree");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamVariableIndex_collectorInsertAndMakeBase_634(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamVariableIndex.insert(self);
}

void gtsamVariableIndex_constructor_635(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;

  Shared *self = new Shared(new gtsam::VariableIndex());
  collector_gtsamVariableIndex.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamVariableIndex_constructor_636(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;

  gtsam::SymbolicFactorGraph& sfg = *unwrap_shared_ptr< gtsam::SymbolicFactorGraph >(in[0], "ptr_gtsamSymbolicFactorGraph");
  Shared *self = new Shared(new gtsam::VariableIndex(sfg));
  collector_gtsamVariableIndex.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamVariableIndex_constructor_637(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;

  gtsam::GaussianFactorGraph& gfg = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[0], "ptr_gtsamGaussianFactorGraph");
  Shared *self = new Shared(new gtsam::VariableIndex(gfg));
  collector_gtsamVariableIndex.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamVariableIndex_constructor_638(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;

  gtsam::NonlinearFactorGraph& fg = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  Shared *self = new Shared(new gtsam::VariableIndex(fg));
  collector_gtsamVariableIndex.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamVariableIndex_constructor_639(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;

  gtsam::VariableIndex& other = *unwrap_shared_ptr< gtsam::VariableIndex >(in[0], "ptr_gtsamVariableIndex");
  Shared *self = new Shared(new gtsam::VariableIndex(other));
  collector_gtsamVariableIndex.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamVariableIndex_deconstructor_640(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;
  checkArguments("delete_gtsamVariableIndex",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamVariableIndex::iterator item;
  item = collector_gtsamVariableIndex.find(self);
  if(item != collector_gtsamVariableIndex.end()) {
    delete self;
    collector_gtsamVariableIndex.erase(item);
  }
}

void gtsamVariableIndex_equals_641(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::VariableIndex>(in[0], "ptr_gtsamVariableIndex");
  gtsam::VariableIndex& other = *unwrap_shared_ptr< gtsam::VariableIndex >(in[1], "ptr_gtsamVariableIndex");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamVariableIndex_nEntries_642(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;
  checkArguments("nEntries",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VariableIndex>(in[0], "ptr_gtsamVariableIndex");
  out[0] = wrap< size_t >(obj->nEntries());
}

void gtsamVariableIndex_nFactors_643(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;
  checkArguments("nFactors",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VariableIndex>(in[0], "ptr_gtsamVariableIndex");
  out[0] = wrap< size_t >(obj->nFactors());
}

void gtsamVariableIndex_print_644(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VariableIndex>(in[0], "ptr_gtsamVariableIndex");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamVariableIndex_size_645(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VariableIndex> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VariableIndex>(in[0], "ptr_gtsamVariableIndex");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamnoiseModelBase_collectorInsertAndMakeBase_646(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Base> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelBase.insert(self);
}

void gtsamnoiseModelBase_upcastFromVoid_647(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Base> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::Base>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelBase_deconstructor_648(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> Shared;
  checkArguments("delete_gtsamnoiseModelBase",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelBase::iterator item;
  item = collector_gtsamnoiseModelBase.find(self);
  if(item != collector_gtsamnoiseModelBase.end()) {
    delete self;
    collector_gtsamnoiseModelBase.erase(item);
  }
}

void gtsamnoiseModelGaussian_collectorInsertAndMakeBase_649(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelGaussian.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelGaussian_upcastFromVoid_650(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::Gaussian>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelGaussian_deconstructor_651(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;
  checkArguments("delete_gtsamnoiseModelGaussian",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelGaussian::iterator item;
  item = collector_gtsamnoiseModelGaussian.find(self);
  if(item != collector_gtsamnoiseModelGaussian.end()) {
    delete self;
    collector_gtsamnoiseModelGaussian.erase(item);
  }
}

void gtsamnoiseModelGaussian_R_652(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;
  checkArguments("R",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Gaussian>(in[0], "ptr_gtsamnoiseModelGaussian");
  out[0] = wrap< Matrix >(obj->R());
}

void gtsamnoiseModelGaussian_equals_653(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Gaussian>(in[0], "ptr_gtsamnoiseModelGaussian");
  gtsam::noiseModel::Base& expected = *unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamnoiseModelGaussian_print_654(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Gaussian>(in[0], "ptr_gtsamnoiseModelGaussian");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelGaussian_Covariance_655(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> SharedGaussian;
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;
  checkArguments("gtsamnoiseModelGaussian.Covariance",nargout,nargin,1);
  Matrix R = unwrap< Matrix >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Gaussian::Covariance(R),"gtsam.noiseModel.Gaussian", true);
}

void gtsamnoiseModelGaussian_SqrtInformation_656(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> SharedGaussian;
  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> Shared;
  checkArguments("gtsamnoiseModelGaussian.SqrtInformation",nargout,nargin,1);
  Matrix R = unwrap< Matrix >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Gaussian::SqrtInformation(R),"gtsam.noiseModel.Gaussian", true);
}

void gtsamnoiseModelDiagonal_collectorInsertAndMakeBase_657(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelDiagonal.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::Gaussian> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelDiagonal_upcastFromVoid_658(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::Diagonal>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelDiagonal_deconstructor_659(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  checkArguments("delete_gtsamnoiseModelDiagonal",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelDiagonal::iterator item;
  item = collector_gtsamnoiseModelDiagonal.find(self);
  if(item != collector_gtsamnoiseModelDiagonal.end()) {
    delete self;
    collector_gtsamnoiseModelDiagonal.erase(item);
  }
}

void gtsamnoiseModelDiagonal_R_660(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  checkArguments("R",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Diagonal>(in[0], "ptr_gtsamnoiseModelDiagonal");
  out[0] = wrap< Matrix >(obj->R());
}

void gtsamnoiseModelDiagonal_equals_661(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Diagonal>(in[0], "ptr_gtsamnoiseModelDiagonal");
  gtsam::noiseModel::Base& expected = *unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamnoiseModelDiagonal_print_662(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Diagonal>(in[0], "ptr_gtsamnoiseModelDiagonal");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelDiagonal_Precisions_663(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> SharedDiagonal;
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  checkArguments("gtsamnoiseModelDiagonal.Precisions",nargout,nargin,1);
  Vector precisions = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Diagonal::Precisions(precisions),"gtsam.noiseModel.Diagonal", true);
}

void gtsamnoiseModelDiagonal_Sigmas_664(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> SharedDiagonal;
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  checkArguments("gtsamnoiseModelDiagonal.Sigmas",nargout,nargin,1);
  Vector sigmas = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Diagonal::Sigmas(sigmas),"gtsam.noiseModel.Diagonal", true);
}

void gtsamnoiseModelDiagonal_Variances_665(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> SharedDiagonal;
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> Shared;
  checkArguments("gtsamnoiseModelDiagonal.Variances",nargout,nargin,1);
  Vector variances = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Diagonal::Variances(variances),"gtsam.noiseModel.Diagonal", true);
}

void gtsamnoiseModelConstrained_collectorInsertAndMakeBase_666(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelConstrained.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelConstrained_upcastFromVoid_667(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::Constrained>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelConstrained_deconstructor_668(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("delete_gtsamnoiseModelConstrained",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelConstrained::iterator item;
  item = collector_gtsamnoiseModelConstrained.find(self);
  if(item != collector_gtsamnoiseModelConstrained.end()) {
    delete self;
    collector_gtsamnoiseModelConstrained.erase(item);
  }
}

void gtsamnoiseModelConstrained_R_669(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("R",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Constrained>(in[0], "ptr_gtsamnoiseModelConstrained");
  out[0] = wrap< Matrix >(obj->R());
}

void gtsamnoiseModelConstrained_equals_670(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Constrained>(in[0], "ptr_gtsamnoiseModelConstrained");
  gtsam::noiseModel::Base& expected = *unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamnoiseModelConstrained_print_671(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Constrained>(in[0], "ptr_gtsamnoiseModelConstrained");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelConstrained_unit_672(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("unit",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Constrained>(in[0], "ptr_gtsamnoiseModelConstrained");
  out[0] = wrap_shared_ptr(obj->unit(),"gtsam.noiseModel.Constrained", true);
}

void gtsamnoiseModelConstrained_All_673(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.All",nargout,nargin,1);
  size_t dim = unwrap< size_t >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::All(dim),"gtsam.noiseModel.Constrained", true);
}
void gtsamnoiseModelConstrained_All_674(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.All",nargout,nargin,2);
  size_t dim = unwrap< size_t >(in[0]);
  double mu = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::All(dim,mu),"gtsam.noiseModel.Constrained", true);
}

void gtsamnoiseModelConstrained_MixedPrecisions_675(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.MixedPrecisions",nargout,nargin,2);
  Vector mu = unwrap< Vector >(in[0]);
  Vector precisions = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::MixedPrecisions(mu,precisions),"gtsam.noiseModel.Constrained", true);
}
void gtsamnoiseModelConstrained_MixedPrecisions_676(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.MixedPrecisions",nargout,nargin,1);
  Vector precisions = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::MixedPrecisions(precisions),"gtsam.noiseModel.Constrained", true);
}

void gtsamnoiseModelConstrained_MixedSigmas_677(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.MixedSigmas",nargout,nargin,2);
  Vector mu = unwrap< Vector >(in[0]);
  Vector sigmas = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::MixedSigmas(mu,sigmas),"gtsam.noiseModel.Constrained", true);
}
void gtsamnoiseModelConstrained_MixedSigmas_678(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.MixedSigmas",nargout,nargin,2);
  double m = unwrap< double >(in[0]);
  Vector sigmas = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::MixedSigmas(m,sigmas),"gtsam.noiseModel.Constrained", true);
}

void gtsamnoiseModelConstrained_MixedVariances_679(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.MixedVariances",nargout,nargin,2);
  Vector mu = unwrap< Vector >(in[0]);
  Vector variances = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::MixedVariances(mu,variances),"gtsam.noiseModel.Constrained", true);
}
void gtsamnoiseModelConstrained_MixedVariances_680(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> SharedConstrained;
  typedef boost::shared_ptr<gtsam::noiseModel::Constrained> Shared;
  checkArguments("gtsamnoiseModelConstrained.MixedVariances",nargout,nargin,1);
  Vector variances = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Constrained::MixedVariances(variances),"gtsam.noiseModel.Constrained", true);
}

void gtsamnoiseModelIsotropic_collectorInsertAndMakeBase_681(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelIsotropic.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelIsotropic_upcastFromVoid_682(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::Isotropic>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelIsotropic_deconstructor_683(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  checkArguments("delete_gtsamnoiseModelIsotropic",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelIsotropic::iterator item;
  item = collector_gtsamnoiseModelIsotropic.find(self);
  if(item != collector_gtsamnoiseModelIsotropic.end()) {
    delete self;
    collector_gtsamnoiseModelIsotropic.erase(item);
  }
}

void gtsamnoiseModelIsotropic_R_684(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  checkArguments("R",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Isotropic>(in[0], "ptr_gtsamnoiseModelIsotropic");
  out[0] = wrap< Matrix >(obj->R());
}

void gtsamnoiseModelIsotropic_equals_685(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Isotropic>(in[0], "ptr_gtsamnoiseModelIsotropic");
  gtsam::noiseModel::Base& expected = *unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamnoiseModelIsotropic_print_686(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Isotropic>(in[0], "ptr_gtsamnoiseModelIsotropic");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelIsotropic_Precision_687(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> SharedIsotropic;
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  checkArguments("gtsamnoiseModelIsotropic.Precision",nargout,nargin,2);
  size_t dim = unwrap< size_t >(in[0]);
  double precision = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Isotropic::Precision(dim,precision),"gtsam.noiseModel.Isotropic", true);
}

void gtsamnoiseModelIsotropic_Sigma_688(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> SharedIsotropic;
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  checkArguments("gtsamnoiseModelIsotropic.Sigma",nargout,nargin,2);
  size_t dim = unwrap< size_t >(in[0]);
  double sigma = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Isotropic::Sigma(dim,sigma),"gtsam.noiseModel.Isotropic", true);
}

void gtsamnoiseModelIsotropic_Variance_689(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> SharedIsotropic;
  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> Shared;
  checkArguments("gtsamnoiseModelIsotropic.Variance",nargout,nargin,2);
  size_t dim = unwrap< size_t >(in[0]);
  double varianace = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Isotropic::Variance(dim,varianace),"gtsam.noiseModel.Isotropic", true);
}

void gtsamnoiseModelUnit_collectorInsertAndMakeBase_690(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelUnit.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::Isotropic> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelUnit_upcastFromVoid_691(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::Unit>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelUnit_deconstructor_692(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> Shared;
  checkArguments("delete_gtsamnoiseModelUnit",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelUnit::iterator item;
  item = collector_gtsamnoiseModelUnit.find(self);
  if(item != collector_gtsamnoiseModelUnit.end()) {
    delete self;
    collector_gtsamnoiseModelUnit.erase(item);
  }
}

void gtsamnoiseModelUnit_R_693(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> Shared;
  checkArguments("R",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Unit>(in[0], "ptr_gtsamnoiseModelUnit");
  out[0] = wrap< Matrix >(obj->R());
}

void gtsamnoiseModelUnit_equals_694(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Unit>(in[0], "ptr_gtsamnoiseModelUnit");
  gtsam::noiseModel::Base& expected = *unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamnoiseModelUnit_print_695(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Unit>(in[0], "ptr_gtsamnoiseModelUnit");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelUnit_Create_696(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> SharedUnit;
  typedef boost::shared_ptr<gtsam::noiseModel::Unit> Shared;
  checkArguments("gtsamnoiseModelUnit.Create",nargout,nargin,1);
  size_t dim = unwrap< size_t >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Unit::Create(dim),"gtsam.noiseModel.Unit", true);
}

void gtsamnoiseModelmEstimatorBase_collectorInsertAndMakeBase_697(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelmEstimatorBase.insert(self);
}

void gtsamnoiseModelmEstimatorBase_upcastFromVoid_698(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::mEstimator::Base>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelmEstimatorBase_deconstructor_699(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> Shared;
  checkArguments("delete_gtsamnoiseModelmEstimatorBase",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelmEstimatorBase::iterator item;
  item = collector_gtsamnoiseModelmEstimatorBase.find(self);
  if(item != collector_gtsamnoiseModelmEstimatorBase.end()) {
    delete self;
    collector_gtsamnoiseModelmEstimatorBase.erase(item);
  }
}

void gtsamnoiseModelmEstimatorNull_collectorInsertAndMakeBase_700(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Null> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelmEstimatorNull.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorNull_upcastFromVoid_701(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Null> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::mEstimator::Null>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelmEstimatorNull_constructor_702(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Null> Shared;

  Shared *self = new Shared(new gtsam::noiseModel::mEstimator::Null());
  collector_gtsamnoiseModelmEstimatorNull.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorNull_deconstructor_703(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Null> Shared;
  checkArguments("delete_gtsamnoiseModelmEstimatorNull",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelmEstimatorNull::iterator item;
  item = collector_gtsamnoiseModelmEstimatorNull.find(self);
  if(item != collector_gtsamnoiseModelmEstimatorNull.end()) {
    delete self;
    collector_gtsamnoiseModelmEstimatorNull.erase(item);
  }
}

void gtsamnoiseModelmEstimatorNull_print_704(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Null> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::mEstimator::Null>(in[0], "ptr_gtsamnoiseModelmEstimatorNull");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelmEstimatorNull_Create_705(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Null> SharedNull;
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Null> Shared;
  checkArguments("gtsamnoiseModelmEstimatorNull.Create",nargout,nargin,0);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::mEstimator::Null::Create(),"gtsam.noiseModel.mEstimator.Null", true);
}

void gtsamnoiseModelmEstimatorFair_collectorInsertAndMakeBase_706(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelmEstimatorFair.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorFair_upcastFromVoid_707(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::mEstimator::Fair>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelmEstimatorFair_constructor_708(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair> Shared;

  double c = unwrap< double >(in[0]);
  Shared *self = new Shared(new gtsam::noiseModel::mEstimator::Fair(c));
  collector_gtsamnoiseModelmEstimatorFair.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorFair_deconstructor_709(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair> Shared;
  checkArguments("delete_gtsamnoiseModelmEstimatorFair",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelmEstimatorFair::iterator item;
  item = collector_gtsamnoiseModelmEstimatorFair.find(self);
  if(item != collector_gtsamnoiseModelmEstimatorFair.end()) {
    delete self;
    collector_gtsamnoiseModelmEstimatorFair.erase(item);
  }
}

void gtsamnoiseModelmEstimatorFair_print_710(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::mEstimator::Fair>(in[0], "ptr_gtsamnoiseModelmEstimatorFair");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelmEstimatorFair_Create_711(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair> SharedFair;
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Fair> Shared;
  checkArguments("gtsamnoiseModelmEstimatorFair.Create",nargout,nargin,1);
  double c = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::mEstimator::Fair::Create(c),"gtsam.noiseModel.mEstimator.Fair", true);
}

void gtsamnoiseModelmEstimatorHuber_collectorInsertAndMakeBase_712(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelmEstimatorHuber.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorHuber_upcastFromVoid_713(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::mEstimator::Huber>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelmEstimatorHuber_constructor_714(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber> Shared;

  double k = unwrap< double >(in[0]);
  Shared *self = new Shared(new gtsam::noiseModel::mEstimator::Huber(k));
  collector_gtsamnoiseModelmEstimatorHuber.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorHuber_deconstructor_715(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber> Shared;
  checkArguments("delete_gtsamnoiseModelmEstimatorHuber",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelmEstimatorHuber::iterator item;
  item = collector_gtsamnoiseModelmEstimatorHuber.find(self);
  if(item != collector_gtsamnoiseModelmEstimatorHuber.end()) {
    delete self;
    collector_gtsamnoiseModelmEstimatorHuber.erase(item);
  }
}

void gtsamnoiseModelmEstimatorHuber_print_716(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::mEstimator::Huber>(in[0], "ptr_gtsamnoiseModelmEstimatorHuber");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelmEstimatorHuber_Create_717(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber> SharedHuber;
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Huber> Shared;
  checkArguments("gtsamnoiseModelmEstimatorHuber.Create",nargout,nargin,1);
  double k = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::mEstimator::Huber::Create(k),"gtsam.noiseModel.mEstimator.Huber", true);
}

void gtsamnoiseModelmEstimatorTukey_collectorInsertAndMakeBase_718(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelmEstimatorTukey.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorTukey_upcastFromVoid_719(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::mEstimator::Tukey>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelmEstimatorTukey_constructor_720(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey> Shared;

  double k = unwrap< double >(in[0]);
  Shared *self = new Shared(new gtsam::noiseModel::mEstimator::Tukey(k));
  collector_gtsamnoiseModelmEstimatorTukey.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamnoiseModelmEstimatorTukey_deconstructor_721(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey> Shared;
  checkArguments("delete_gtsamnoiseModelmEstimatorTukey",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelmEstimatorTukey::iterator item;
  item = collector_gtsamnoiseModelmEstimatorTukey.find(self);
  if(item != collector_gtsamnoiseModelmEstimatorTukey.end()) {
    delete self;
    collector_gtsamnoiseModelmEstimatorTukey.erase(item);
  }
}

void gtsamnoiseModelmEstimatorTukey_print_722(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::mEstimator::Tukey>(in[0], "ptr_gtsamnoiseModelmEstimatorTukey");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelmEstimatorTukey_Create_723(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey> SharedTukey;
  typedef boost::shared_ptr<gtsam::noiseModel::mEstimator::Tukey> Shared;
  checkArguments("gtsamnoiseModelmEstimatorTukey.Create",nargout,nargin,1);
  double k = unwrap< double >(in[0]);
  out[0] = wrap_shared_ptr(gtsam::noiseModel::mEstimator::Tukey::Create(k),"gtsam.noiseModel.mEstimator.Tukey", true);
}

void gtsamnoiseModelRobust_collectorInsertAndMakeBase_724(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Robust> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamnoiseModelRobust.insert(self);

  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamnoiseModelRobust_upcastFromVoid_725(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Robust> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::noiseModel::Robust>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamnoiseModelRobust_constructor_726(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::noiseModel::Robust> Shared;

  boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> robust = unwrap_shared_ptr< gtsam::noiseModel::mEstimator::Base >(in[0], "ptr_gtsamnoiseModelmEstimatorBase");
  boost::shared_ptr<gtsam::noiseModel::Base> noise = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::noiseModel::Robust(robust,noise));
  collector_gtsamnoiseModelRobust.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamnoiseModelRobust_deconstructor_727(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Robust> Shared;
  checkArguments("delete_gtsamnoiseModelRobust",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamnoiseModelRobust::iterator item;
  item = collector_gtsamnoiseModelRobust.find(self);
  if(item != collector_gtsamnoiseModelRobust.end()) {
    delete self;
    collector_gtsamnoiseModelRobust.erase(item);
  }
}

void gtsamnoiseModelRobust_print_728(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Robust> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::noiseModel::Robust>(in[0], "ptr_gtsamnoiseModelRobust");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamnoiseModelRobust_Create_729(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Robust> SharedRobust;
  typedef boost::shared_ptr<gtsam::noiseModel::Robust> Shared;
  checkArguments("gtsamnoiseModelRobust.Create",nargout,nargin,2);
  boost::shared_ptr<gtsam::noiseModel::mEstimator::Base> robust = unwrap_shared_ptr< gtsam::noiseModel::mEstimator::Base >(in[0], "ptr_gtsamnoiseModelmEstimatorBase");
  boost::shared_ptr<gtsam::noiseModel::Base> noise = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  out[0] = wrap_shared_ptr(gtsam::noiseModel::Robust::Create(robust,noise),"gtsam.noiseModel.Robust", true);
}

void gtsamSampler_collectorInsertAndMakeBase_730(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Sampler> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSampler.insert(self);
}

void gtsamSampler_constructor_731(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Sampler> Shared;

  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[0], "ptr_gtsamnoiseModelDiagonal");
  int seed = unwrap< int >(in[1]);
  Shared *self = new Shared(new gtsam::Sampler(model,seed));
  collector_gtsamSampler.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSampler_constructor_732(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Sampler> Shared;

  Vector sigmas = unwrap< Vector >(in[0]);
  int seed = unwrap< int >(in[1]);
  Shared *self = new Shared(new gtsam::Sampler(sigmas,seed));
  collector_gtsamSampler.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSampler_constructor_733(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Sampler> Shared;

  int seed = unwrap< int >(in[0]);
  Shared *self = new Shared(new gtsam::Sampler(seed));
  collector_gtsamSampler.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSampler_deconstructor_734(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Sampler> Shared;
  checkArguments("delete_gtsamSampler",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSampler::iterator item;
  item = collector_gtsamSampler.find(self);
  if(item != collector_gtsamSampler.end()) {
    delete self;
    collector_gtsamSampler.erase(item);
  }
}

void gtsamSampler_dim_735(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Sampler> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Sampler>(in[0], "ptr_gtsamSampler");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamSampler_model_736(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> SharedDiagonal;
  typedef boost::shared_ptr<gtsam::Sampler> Shared;
  checkArguments("model",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Sampler>(in[0], "ptr_gtsamSampler");
  out[0] = wrap_shared_ptr(obj->model(),"gtsam.noiseModel.Diagonal", true);
}

void gtsamSampler_sample_737(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Sampler> Shared;
  checkArguments("sample",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Sampler>(in[0], "ptr_gtsamSampler");
  out[0] = wrap< Vector >(obj->sample());
}

void gtsamSampler_sampleNewModel_738(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Sampler> Shared;
  checkArguments("sampleNewModel",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Sampler>(in[0], "ptr_gtsamSampler");
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[1], "ptr_gtsamnoiseModelDiagonal");
  out[0] = wrap< Vector >(obj->sampleNewModel(model));
}

void gtsamSampler_sigmas_739(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Sampler> Shared;
  checkArguments("sigmas",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Sampler>(in[0], "ptr_gtsamSampler");
  out[0] = wrap< Vector >(obj->sigmas());
}

void gtsamVectorValues_collectorInsertAndMakeBase_740(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamVectorValues.insert(self);
}

void gtsamVectorValues_constructor_741(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;

  Shared *self = new Shared(new gtsam::VectorValues());
  collector_gtsamVectorValues.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamVectorValues_constructor_742(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;

  gtsam::VectorValues& other = *unwrap_shared_ptr< gtsam::VectorValues >(in[0], "ptr_gtsamVectorValues");
  Shared *self = new Shared(new gtsam::VectorValues(other));
  collector_gtsamVectorValues.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamVectorValues_deconstructor_743(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("delete_gtsamVectorValues",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamVectorValues::iterator item;
  item = collector_gtsamVectorValues.find(self);
  if(item != collector_gtsamVectorValues.end()) {
    delete self;
    collector_gtsamVectorValues.erase(item);
  }
}

void gtsamVectorValues_add_744(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("add",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->add(c))),"gtsam.VectorValues", false);
}

void gtsamVectorValues_addInPlace_745(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("addInPlace",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  obj->addInPlace(c);
}

void gtsamVectorValues_at_746(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap< Vector >(obj->at(j));
}

void gtsamVectorValues_dim_747(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("dim",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap< size_t >(obj->dim(j));
}

void gtsamVectorValues_dot_748(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("dot",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  gtsam::VectorValues& V = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->dot(V));
}

void gtsamVectorValues_equals_749(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  gtsam::VectorValues& expected = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamVectorValues_exists_750(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("exists",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->exists(j));
}

void gtsamVectorValues_hasSameStructure_751(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("hasSameStructure",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  gtsam::VectorValues& other = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< bool >(obj->hasSameStructure(other));
}

void gtsamVectorValues_insert_752(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  size_t j = unwrap< size_t >(in[1]);
  Vector value = unwrap< Vector >(in[2]);
  obj->insert(j,value);
}

void gtsamVectorValues_norm_753(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("norm",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->norm());
}

void gtsamVectorValues_print_754(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamVectorValues_scale_755(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("scale",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  double a = unwrap< double >(in[1]);
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->scale(a))),"gtsam.VectorValues", false);
}

void gtsamVectorValues_scaleInPlace_756(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("scaleInPlace",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  double a = unwrap< double >(in[1]);
  obj->scaleInPlace(a);
}

void gtsamVectorValues_setZero_757(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("setZero",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  obj->setZero();
}

void gtsamVectorValues_size_758(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamVectorValues_squaredNorm_759(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("squaredNorm",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->squaredNorm());
}

void gtsamVectorValues_subtract_760(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("subtract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->subtract(c))),"gtsam.VectorValues", false);
}

void gtsamVectorValues_update_761(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("update",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  gtsam::VectorValues& values = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  obj->update(values);
}

void gtsamVectorValues_vector_762(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamVectorValues_string_serialize_763(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::VectorValues>(in[0], "ptr_gtsamVectorValues");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamVectorValues_Zero_764(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("gtsamVectorValues.Zero",nargout,nargin,1);
  gtsam::VectorValues& model = *unwrap_shared_ptr< gtsam::VectorValues >(in[0], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(gtsam::VectorValues::Zero(model))),"gtsam.VectorValues", false);
}

void gtsamVectorValues_string_deserialize_765(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> Shared;
  checkArguments("gtsamVectorValues.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::VectorValues());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.VectorValues", false);
}
void gtsamGaussianFactor_collectorInsertAndMakeBase_766(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussianFactor.insert(self);
}

void gtsamGaussianFactor_upcastFromVoid_767(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GaussianFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGaussianFactor_deconstructor_768(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("delete_gtsamGaussianFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussianFactor::iterator item;
  item = collector_gtsamGaussianFactor.find(self);
  if(item != collector_gtsamGaussianFactor.end()) {
    delete self;
    collector_gtsamGaussianFactor.erase(item);
  }
}

void gtsamGaussianFactor_augmentedInformation_769(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("augmentedInformation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap< Matrix >(obj->augmentedInformation());
}

void gtsamGaussianFactor_augmentedJacobian_770(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("augmentedJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap< Matrix >(obj->augmentedJacobian());
}

void gtsamGaussianFactor_clone_771(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.GaussianFactor", true);
}

void gtsamGaussianFactor_empty_772(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamGaussianFactor_equals_773(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  gtsam::GaussianFactor& lf = *unwrap_shared_ptr< gtsam::GaussianFactor >(in[1], "ptr_gtsamGaussianFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(lf,tol));
}

void gtsamGaussianFactor_error_774(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGaussianFactor_information_775(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("information",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap< Matrix >(obj->information());
}

void gtsamGaussianFactor_jacobian_776(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("jacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  pair< Matrix, Vector > pairResult = obj->jacobian();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamGaussianFactor_keys_777(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGaussianFactor_negate_778(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("negate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap_shared_ptr(obj->negate(),"gtsam.GaussianFactor", true);
}

void gtsamGaussianFactor_print_779(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussianFactor_size_780(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactor>(in[0], "ptr_gtsamGaussianFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamJacobianFactor_collectorInsertAndMakeBase_781(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamJacobianFactor.insert(self);

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamJacobianFactor_upcastFromVoid_782(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::JacobianFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamJacobianFactor_constructor_783(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  Shared *self = new Shared(new gtsam::JacobianFactor());
  collector_gtsamJacobianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamJacobianFactor_constructor_784(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  gtsam::GaussianFactor& factor = *unwrap_shared_ptr< gtsam::GaussianFactor >(in[0], "ptr_gtsamGaussianFactor");
  Shared *self = new Shared(new gtsam::JacobianFactor(factor));
  collector_gtsamJacobianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamJacobianFactor_constructor_785(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  Vector b_in = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::JacobianFactor(b_in));
  collector_gtsamJacobianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamJacobianFactor_constructor_786(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  size_t i1 = unwrap< size_t >(in[0]);
  Matrix A1 = unwrap< Matrix >(in[1]);
  Vector b = unwrap< Vector >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[3], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::JacobianFactor(i1,A1,b,model));
  collector_gtsamJacobianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamJacobianFactor_constructor_787(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  size_t i1 = unwrap< size_t >(in[0]);
  Matrix A1 = unwrap< Matrix >(in[1]);
  size_t i2 = unwrap< size_t >(in[2]);
  Matrix A2 = unwrap< Matrix >(in[3]);
  Vector b = unwrap< Vector >(in[4]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[5], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::JacobianFactor(i1,A1,i2,A2,b,model));
  collector_gtsamJacobianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamJacobianFactor_constructor_788(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  size_t i1 = unwrap< size_t >(in[0]);
  Matrix A1 = unwrap< Matrix >(in[1]);
  size_t i2 = unwrap< size_t >(in[2]);
  Matrix A2 = unwrap< Matrix >(in[3]);
  size_t i3 = unwrap< size_t >(in[4]);
  Matrix A3 = unwrap< Matrix >(in[5]);
  Vector b = unwrap< Vector >(in[6]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[7], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::JacobianFactor(i1,A1,i2,A2,i3,A3,b,model));
  collector_gtsamJacobianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamJacobianFactor_constructor_789(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;

  gtsam::GaussianFactorGraph& graph = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[0], "ptr_gtsamGaussianFactorGraph");
  Shared *self = new Shared(new gtsam::JacobianFactor(graph));
  collector_gtsamJacobianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamJacobianFactor_deconstructor_790(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("delete_gtsamJacobianFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamJacobianFactor::iterator item;
  item = collector_gtsamJacobianFactor.find(self);
  if(item != collector_gtsamJacobianFactor.end()) {
    delete self;
    collector_gtsamJacobianFactor.erase(item);
  }
}

void gtsamJacobianFactor_augmentedInformation_791(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("augmentedInformation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< Matrix >(obj->augmentedInformation());
}

void gtsamJacobianFactor_augmentedJacobian_792(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("augmentedJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< Matrix >(obj->augmentedJacobian());
}

void gtsamJacobianFactor_augmentedJacobianUnweighted_793(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("augmentedJacobianUnweighted",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< Matrix >(obj->augmentedJacobianUnweighted());
}

void gtsamJacobianFactor_clone_794(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.GaussianFactor", true);
}

void gtsamJacobianFactor_cols_795(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("cols",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< size_t >(obj->cols());
}

void gtsamJacobianFactor_eliminate_796(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> SharedGaussianConditional;
  typedef boost::shared_ptr<gtsam::JacobianFactor> SharedJacobianFactor;
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("eliminate",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  gtsam::Ordering& keys = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  pair< SharedGaussianConditional, SharedJacobianFactor > pairResult = obj->eliminate(keys);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.GaussianConditional", true);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.JacobianFactor", true);
}

void gtsamJacobianFactor_empty_797(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamJacobianFactor_equals_798(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  gtsam::GaussianFactor& lf = *unwrap_shared_ptr< gtsam::GaussianFactor >(in[1], "ptr_gtsamGaussianFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(lf,tol));
}

void gtsamJacobianFactor_error_799(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamJacobianFactor_error_vector_800(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("error_vector",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< Vector >(obj->error_vector(c));
}

void gtsamJacobianFactor_getA_801(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("getA",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< Matrix >(obj->getA());
}

void gtsamJacobianFactor_get_model_802(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Diagonal> SharedDiagonal;
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("get_model",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap_shared_ptr(obj->get_model(),"gtsam.noiseModel.Diagonal", true);
}

void gtsamJacobianFactor_getb_803(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("getb",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< Vector >(obj->getb());
}

void gtsamJacobianFactor_information_804(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("information",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< Matrix >(obj->information());
}

void gtsamJacobianFactor_isConstrained_805(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("isConstrained",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< bool >(obj->isConstrained());
}

void gtsamJacobianFactor_jacobian_806(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("jacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  pair< Matrix, Vector > pairResult = obj->jacobian();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamJacobianFactor_jacobianUnweighted_807(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("jacobianUnweighted",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  pair< Matrix, Vector > pairResult = obj->jacobianUnweighted();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamJacobianFactor_keys_808(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamJacobianFactor_negate_809(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("negate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap_shared_ptr(obj->negate(),"gtsam.GaussianFactor", true);
}

void gtsamJacobianFactor_print_810(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamJacobianFactor_printKeys_811(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamJacobianFactor_rows_812(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("rows",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< size_t >(obj->rows());
}

void gtsamJacobianFactor_setModel_813(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("setModel",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  bool anyConstrained = unwrap< bool >(in[1]);
  Vector sigmas = unwrap< Vector >(in[2]);
  obj->setModel(anyConstrained,sigmas);
}

void gtsamJacobianFactor_size_814(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamJacobianFactor_transposeMultiplyAdd_815(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("transposeMultiplyAdd",nargout,nargin-1,3);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  double alpha = unwrap< double >(in[1]);
  Vector e = unwrap< Vector >(in[2]);
  gtsam::VectorValues& x = *unwrap_shared_ptr< gtsam::VectorValues >(in[3], "ptr_gtsamVectorValues");
  obj->transposeMultiplyAdd(alpha,e,x);
}

void gtsamJacobianFactor_unweighted_error_816(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("unweighted_error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< Vector >(obj->unweighted_error(c));
}

void gtsamJacobianFactor_whiten_817(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> SharedJacobianFactor;
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("whiten",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  out[0] = wrap_shared_ptr(obj->whiten().clone(),"gtsam.JacobianFactor", true);
}

void gtsamJacobianFactor_string_serialize_818(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JacobianFactor>(in[0], "ptr_gtsamJacobianFactor");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamJacobianFactor_string_deserialize_819(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> Shared;
  checkArguments("gtsamJacobianFactor.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::JacobianFactor());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.JacobianFactor", false);
}
void gtsamHessianFactor_collectorInsertAndMakeBase_820(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamHessianFactor.insert(self);

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamHessianFactor_upcastFromVoid_821(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::HessianFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamHessianFactor_constructor_822(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  Shared *self = new Shared(new gtsam::HessianFactor());
  collector_gtsamHessianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamHessianFactor_constructor_823(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  gtsam::GaussianFactor& factor = *unwrap_shared_ptr< gtsam::GaussianFactor >(in[0], "ptr_gtsamGaussianFactor");
  Shared *self = new Shared(new gtsam::HessianFactor(factor));
  collector_gtsamHessianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamHessianFactor_constructor_824(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  size_t j = unwrap< size_t >(in[0]);
  Matrix G = unwrap< Matrix >(in[1]);
  Vector g = unwrap< Vector >(in[2]);
  double f = unwrap< double >(in[3]);
  Shared *self = new Shared(new gtsam::HessianFactor(j,G,g,f));
  collector_gtsamHessianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamHessianFactor_constructor_825(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  size_t j = unwrap< size_t >(in[0]);
  Vector mu = unwrap< Vector >(in[1]);
  Matrix Sigma = unwrap< Matrix >(in[2]);
  Shared *self = new Shared(new gtsam::HessianFactor(j,mu,Sigma));
  collector_gtsamHessianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamHessianFactor_constructor_826(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  size_t j1 = unwrap< size_t >(in[0]);
  size_t j2 = unwrap< size_t >(in[1]);
  Matrix G11 = unwrap< Matrix >(in[2]);
  Matrix G12 = unwrap< Matrix >(in[3]);
  Vector g1 = unwrap< Vector >(in[4]);
  Matrix G22 = unwrap< Matrix >(in[5]);
  Vector g2 = unwrap< Vector >(in[6]);
  double f = unwrap< double >(in[7]);
  Shared *self = new Shared(new gtsam::HessianFactor(j1,j2,G11,G12,g1,G22,g2,f));
  collector_gtsamHessianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamHessianFactor_constructor_827(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  size_t j1 = unwrap< size_t >(in[0]);
  size_t j2 = unwrap< size_t >(in[1]);
  size_t j3 = unwrap< size_t >(in[2]);
  Matrix G11 = unwrap< Matrix >(in[3]);
  Matrix G12 = unwrap< Matrix >(in[4]);
  Matrix G13 = unwrap< Matrix >(in[5]);
  Vector g1 = unwrap< Vector >(in[6]);
  Matrix G22 = unwrap< Matrix >(in[7]);
  Matrix G23 = unwrap< Matrix >(in[8]);
  Vector g2 = unwrap< Vector >(in[9]);
  Matrix G33 = unwrap< Matrix >(in[10]);
  Vector g3 = unwrap< Vector >(in[11]);
  double f = unwrap< double >(in[12]);
  Shared *self = new Shared(new gtsam::HessianFactor(j1,j2,j3,G11,G12,G13,g1,G22,G23,g2,G33,g3,f));
  collector_gtsamHessianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamHessianFactor_constructor_828(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;

  gtsam::GaussianFactorGraph& factors = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[0], "ptr_gtsamGaussianFactorGraph");
  Shared *self = new Shared(new gtsam::HessianFactor(factors));
  collector_gtsamHessianFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamHessianFactor_deconstructor_829(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("delete_gtsamHessianFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamHessianFactor::iterator item;
  item = collector_gtsamHessianFactor.find(self);
  if(item != collector_gtsamHessianFactor.end()) {
    delete self;
    collector_gtsamHessianFactor.erase(item);
  }
}

void gtsamHessianFactor_augmentedInformation_830(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("augmentedInformation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< Matrix >(obj->augmentedInformation());
}

void gtsamHessianFactor_augmentedJacobian_831(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("augmentedJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< Matrix >(obj->augmentedJacobian());
}

void gtsamHessianFactor_clone_832(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.GaussianFactor", true);
}

void gtsamHessianFactor_constantTerm_833(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("constantTerm",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< double >(obj->constantTerm());
}

void gtsamHessianFactor_empty_834(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamHessianFactor_equals_835(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  gtsam::GaussianFactor& lf = *unwrap_shared_ptr< gtsam::GaussianFactor >(in[1], "ptr_gtsamGaussianFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(lf,tol));
}

void gtsamHessianFactor_error_836(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamHessianFactor_information_837(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("information",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< Matrix >(obj->information());
}

void gtsamHessianFactor_jacobian_838(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("jacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  pair< Matrix, Vector > pairResult = obj->jacobian();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamHessianFactor_keys_839(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamHessianFactor_linearTerm_840(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("linearTerm",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< Vector >(obj->linearTerm());
}

void gtsamHessianFactor_negate_841(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("negate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap_shared_ptr(obj->negate(),"gtsam.GaussianFactor", true);
}

void gtsamHessianFactor_print_842(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamHessianFactor_printKeys_843(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamHessianFactor_rows_844(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("rows",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< size_t >(obj->rows());
}

void gtsamHessianFactor_size_845(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamHessianFactor_string_serialize_846(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::HessianFactor>(in[0], "ptr_gtsamHessianFactor");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamHessianFactor_string_deserialize_847(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> Shared;
  checkArguments("gtsamHessianFactor.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::HessianFactor());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.HessianFactor", false);
}
void gtsamGaussianFactorGraph_collectorInsertAndMakeBase_848(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussianFactorGraph.insert(self);
}

void gtsamGaussianFactorGraph_constructor_849(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;

  Shared *self = new Shared(new gtsam::GaussianFactorGraph());
  collector_gtsamGaussianFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianFactorGraph_constructor_850(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;

  gtsam::GaussianBayesNet& bayesNet = *unwrap_shared_ptr< gtsam::GaussianBayesNet >(in[0], "ptr_gtsamGaussianBayesNet");
  Shared *self = new Shared(new gtsam::GaussianFactorGraph(bayesNet));
  collector_gtsamGaussianFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianFactorGraph_constructor_851(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;

  gtsam::GaussianBayesTree& bayesTree = *unwrap_shared_ptr< gtsam::GaussianBayesTree >(in[0], "ptr_gtsamGaussianBayesTree");
  Shared *self = new Shared(new gtsam::GaussianFactorGraph(bayesTree));
  collector_gtsamGaussianFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianFactorGraph_deconstructor_852(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("delete_gtsamGaussianFactorGraph",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussianFactorGraph::iterator item;
  item = collector_gtsamGaussianFactorGraph.find(self);
  if(item != collector_gtsamGaussianFactorGraph.end()) {
    delete self;
    collector_gtsamGaussianFactorGraph.erase(item);
  }
}

void gtsamGaussianFactorGraph_add_853(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("add",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::GaussianFactor& factor = *unwrap_shared_ptr< gtsam::GaussianFactor >(in[1], "ptr_gtsamGaussianFactor");
  obj->add(factor);
}
void gtsamGaussianFactorGraph_add_854(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("add",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  Vector b = unwrap< Vector >(in[1]);
  obj->add(b);
}
void gtsamGaussianFactorGraph_add_855(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("add",nargout,nargin-1,4);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  size_t key1 = unwrap< size_t >(in[1]);
  Matrix A1 = unwrap< Matrix >(in[2]);
  Vector b = unwrap< Vector >(in[3]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[4], "ptr_gtsamnoiseModelDiagonal");
  obj->add(key1,A1,b,model);
}
void gtsamGaussianFactorGraph_add_856(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("add",nargout,nargin-1,6);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  size_t key1 = unwrap< size_t >(in[1]);
  Matrix A1 = unwrap< Matrix >(in[2]);
  size_t key2 = unwrap< size_t >(in[3]);
  Matrix A2 = unwrap< Matrix >(in[4]);
  Vector b = unwrap< Vector >(in[5]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[6], "ptr_gtsamnoiseModelDiagonal");
  obj->add(key1,A1,key2,A2,b,model);
}
void gtsamGaussianFactorGraph_add_857(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("add",nargout,nargin-1,8);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  size_t key1 = unwrap< size_t >(in[1]);
  Matrix A1 = unwrap< Matrix >(in[2]);
  size_t key2 = unwrap< size_t >(in[3]);
  Matrix A2 = unwrap< Matrix >(in[4]);
  size_t key3 = unwrap< size_t >(in[5]);
  Matrix A3 = unwrap< Matrix >(in[6]);
  Vector b = unwrap< Vector >(in[7]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[8], "ptr_gtsamnoiseModelDiagonal");
  obj->add(key1,A1,key2,A2,key3,A3,b,model);
}

void gtsamGaussianFactorGraph_at_858(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->at(idx),"gtsam.GaussianFactor", true);
}

void gtsamGaussianFactorGraph_augmentedHessian_859(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("augmentedHessian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap< Matrix >(obj->augmentedHessian());
}
void gtsamGaussianFactorGraph_augmentedHessian_860(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("augmentedHessian",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap< Matrix >(obj->augmentedHessian(ordering));
}

void gtsamGaussianFactorGraph_augmentedJacobian_861(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("augmentedJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap< Matrix >(obj->augmentedJacobian());
}
void gtsamGaussianFactorGraph_augmentedJacobian_862(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("augmentedJacobian",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap< Matrix >(obj->augmentedJacobian(ordering));
}

void gtsamGaussianFactorGraph_clone_863(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedGaussianFactorGraph(new gtsam::GaussianFactorGraph(obj->clone())),"gtsam.GaussianFactorGraph", false);
}

void gtsamGaussianFactorGraph_eliminateMultifrontal_864(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> SharedGaussianBayesTree;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminateMultifrontal",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(obj->eliminateMultifrontal(),"gtsam.GaussianBayesTree", true);
}
void gtsamGaussianFactorGraph_eliminateMultifrontal_865(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> SharedGaussianBayesTree;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminateMultifrontal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->eliminateMultifrontal(ordering),"gtsam.GaussianBayesTree", true);
}

void gtsamGaussianFactorGraph_eliminatePartialMultifrontal_866(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> SharedGaussianBayesTree;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminatePartialMultifrontal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  pair< SharedGaussianBayesTree, SharedGaussianFactorGraph > pairResult = obj->eliminatePartialMultifrontal(ordering);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.GaussianBayesTree", true);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.GaussianFactorGraph", false);
}
void gtsamGaussianFactorGraph_eliminatePartialMultifrontal_867(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> SharedGaussianBayesTree;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminatePartialMultifrontal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  pair< SharedGaussianBayesTree, SharedGaussianFactorGraph > pairResult = obj->eliminatePartialMultifrontal(keys);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.GaussianBayesTree", true);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.GaussianFactorGraph", false);
}

void gtsamGaussianFactorGraph_eliminatePartialSequential_868(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminatePartialSequential",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  pair< SharedGaussianBayesNet, SharedGaussianFactorGraph > pairResult = obj->eliminatePartialSequential(ordering);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.GaussianBayesNet", true);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.GaussianFactorGraph", false);
}
void gtsamGaussianFactorGraph_eliminatePartialSequential_869(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminatePartialSequential",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  pair< SharedGaussianBayesNet, SharedGaussianFactorGraph > pairResult = obj->eliminatePartialSequential(keys);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.GaussianBayesNet", true);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.GaussianFactorGraph", false);
}

void gtsamGaussianFactorGraph_eliminateSequential_870(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminateSequential",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(obj->eliminateSequential(),"gtsam.GaussianBayesNet", true);
}
void gtsamGaussianFactorGraph_eliminateSequential_871(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("eliminateSequential",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->eliminateSequential(ordering),"gtsam.GaussianBayesNet", true);
}

void gtsamGaussianFactorGraph_equals_872(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::GaussianFactorGraph& lfgraph = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[1], "ptr_gtsamGaussianFactorGraph");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(lfgraph,tol));
}

void gtsamGaussianFactorGraph_error_873(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGaussianFactorGraph_exists_874(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("exists",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->exists(idx));
}

void gtsamGaussianFactorGraph_gradient_875(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("gradient",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::VectorValues& x0 = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->gradient(x0))),"gtsam.VectorValues", false);
}

void gtsamGaussianFactorGraph_gradientAtZero_876(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("gradientAtZero",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->gradientAtZero())),"gtsam.VectorValues", false);
}

void gtsamGaussianFactorGraph_hessian_877(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("hessian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  pair< Matrix, Vector > pairResult = obj->hessian();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}
void gtsamGaussianFactorGraph_hessian_878(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("hessian",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  pair< Matrix, Vector > pairResult = obj->hessian(ordering);
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamGaussianFactorGraph_jacobian_879(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("jacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  pair< Matrix, Vector > pairResult = obj->jacobian();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}
void gtsamGaussianFactorGraph_jacobian_880(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("jacobian",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  pair< Matrix, Vector > pairResult = obj->jacobian(ordering);
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamGaussianFactorGraph_keyVector_881(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("keyVector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keyVector())),"gtsam.KeyVector", false);
}

void gtsamGaussianFactorGraph_keys_882(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> SharedKeySet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedKeySet(new gtsam::KeySet(obj->keys())),"gtsam.KeySet", false);
}

void gtsamGaussianFactorGraph_marginal_883(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("marginal",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::KeyVector& key_vector = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(obj->marginal(key_vector),"gtsam.GaussianFactorGraph", false);
}

void gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_884(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(ordering),"gtsam.GaussianBayesNet", true);
}
void gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_885(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::KeyVector& key_vector = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(key_vector),"gtsam.GaussianBayesNet", true);
}
void gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_886(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  gtsam::Ordering& marginalizedVariableOrdering = *unwrap_shared_ptr< gtsam::Ordering >(in[2], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(ordering,marginalizedVariableOrdering),"gtsam.GaussianBayesNet", true);
}
void gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_887(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("marginalMultifrontalBayesNet",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::KeyVector& key_vector = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  gtsam::Ordering& marginalizedVariableOrdering = *unwrap_shared_ptr< gtsam::Ordering >(in[2], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(obj->marginalMultifrontalBayesNet(key_vector,marginalizedVariableOrdering),"gtsam.GaussianBayesNet", true);
}

void gtsamGaussianFactorGraph_negate_888(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("negate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedGaussianFactorGraph(new gtsam::GaussianFactorGraph(obj->negate())),"gtsam.GaussianFactorGraph", false);
}

void gtsamGaussianFactorGraph_optimize_889(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimize())),"gtsam.VectorValues", false);
}
void gtsamGaussianFactorGraph_optimize_890(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("optimize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimize(ordering))),"gtsam.VectorValues", false);
}

void gtsamGaussianFactorGraph_optimizeGradientSearch_891(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("optimizeGradientSearch",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimizeGradientSearch())),"gtsam.VectorValues", false);
}

void gtsamGaussianFactorGraph_print_892(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussianFactorGraph_probPrime_893(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("probPrime",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->probPrime(c));
}

void gtsamGaussianFactorGraph_push_back_894(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  boost::shared_ptr<gtsam::GaussianFactor> factor = unwrap_shared_ptr< gtsam::GaussianFactor >(in[1], "ptr_gtsamGaussianFactor");
  obj->push_back(factor);
}
void gtsamGaussianFactorGraph_push_back_895(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  boost::shared_ptr<gtsam::GaussianConditional> conditional = unwrap_shared_ptr< gtsam::GaussianConditional >(in[1], "ptr_gtsamGaussianConditional");
  obj->push_back(conditional);
}
void gtsamGaussianFactorGraph_push_back_896(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::GaussianFactorGraph& graph = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[1], "ptr_gtsamGaussianFactorGraph");
  obj->push_back(graph);
}
void gtsamGaussianFactorGraph_push_back_897(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::GaussianBayesNet& bayesNet = *unwrap_shared_ptr< gtsam::GaussianBayesNet >(in[1], "ptr_gtsamGaussianBayesNet");
  obj->push_back(bayesNet);
}
void gtsamGaussianFactorGraph_push_back_898(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::GaussianBayesTree& bayesTree = *unwrap_shared_ptr< gtsam::GaussianBayesTree >(in[1], "ptr_gtsamGaussianBayesTree");
  obj->push_back(bayesTree);
}

void gtsamGaussianFactorGraph_size_899(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGaussianFactorGraph_sparseJacobian__900(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("sparseJacobian_",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap< Matrix >(obj->sparseJacobian_());
}

void gtsamGaussianFactorGraph_string_serialize_901(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianFactorGraph>(in[0], "ptr_gtsamGaussianFactorGraph");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamGaussianFactorGraph_string_deserialize_902(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> Shared;
  checkArguments("gtsamGaussianFactorGraph.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::GaussianFactorGraph());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.GaussianFactorGraph", false);
}
void gtsamGaussianConditional_collectorInsertAndMakeBase_903(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussianConditional.insert(self);

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGaussianConditional_upcastFromVoid_904(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GaussianConditional>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGaussianConditional_constructor_905(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector d = unwrap< Vector >(in[1]);
  Matrix R = unwrap< Matrix >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> sigmas = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[3], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::GaussianConditional(key,d,R,sigmas));
  collector_gtsamGaussianConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussianConditional_constructor_906(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector d = unwrap< Vector >(in[1]);
  Matrix R = unwrap< Matrix >(in[2]);
  size_t name1 = unwrap< size_t >(in[3]);
  Matrix S = unwrap< Matrix >(in[4]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> sigmas = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[5], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::GaussianConditional(key,d,R,name1,S,sigmas));
  collector_gtsamGaussianConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussianConditional_constructor_907(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector d = unwrap< Vector >(in[1]);
  Matrix R = unwrap< Matrix >(in[2]);
  size_t name1 = unwrap< size_t >(in[3]);
  Matrix S = unwrap< Matrix >(in[4]);
  size_t name2 = unwrap< size_t >(in[5]);
  Matrix T = unwrap< Matrix >(in[6]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> sigmas = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[7], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::GaussianConditional(key,d,R,name1,S,name2,T,sigmas));
  collector_gtsamGaussianConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussianConditional_constructor_908(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector d = unwrap< Vector >(in[1]);
  Matrix R = unwrap< Matrix >(in[2]);
  Shared *self = new Shared(new gtsam::GaussianConditional(key,d,R));
  collector_gtsamGaussianConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussianConditional_constructor_909(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector d = unwrap< Vector >(in[1]);
  Matrix R = unwrap< Matrix >(in[2]);
  size_t name1 = unwrap< size_t >(in[3]);
  Matrix S = unwrap< Matrix >(in[4]);
  Shared *self = new Shared(new gtsam::GaussianConditional(key,d,R,name1,S));
  collector_gtsamGaussianConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussianConditional_constructor_910(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector d = unwrap< Vector >(in[1]);
  Matrix R = unwrap< Matrix >(in[2]);
  size_t name1 = unwrap< size_t >(in[3]);
  Matrix S = unwrap< Matrix >(in[4]);
  size_t name2 = unwrap< size_t >(in[5]);
  Matrix T = unwrap< Matrix >(in[6]);
  Shared *self = new Shared(new gtsam::GaussianConditional(key,d,R,name1,S,name2,T));
  collector_gtsamGaussianConditional.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussianConditional_deconstructor_911(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("delete_gtsamGaussianConditional",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussianConditional::iterator item;
  item = collector_gtsamGaussianConditional.find(self);
  if(item != collector_gtsamGaussianConditional.end()) {
    delete self;
    collector_gtsamGaussianConditional.erase(item);
  }
}

void gtsamGaussianConditional_augmentedInformation_912(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("augmentedInformation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap< Matrix >(obj->augmentedInformation());
}

void gtsamGaussianConditional_augmentedJacobian_913(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("augmentedJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap< Matrix >(obj->augmentedJacobian());
}

void gtsamGaussianConditional_clone_914(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.GaussianFactor", true);
}

void gtsamGaussianConditional_empty_915(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamGaussianConditional_equals_916(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  gtsam::GaussianConditional& cg = *unwrap_shared_ptr< gtsam::GaussianConditional >(in[1], "ptr_gtsamGaussianConditional");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(cg,tol));
}

void gtsamGaussianConditional_error_917(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGaussianConditional_information_918(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("information",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap< Matrix >(obj->information());
}

void gtsamGaussianConditional_jacobian_919(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("jacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  pair< Matrix, Vector > pairResult = obj->jacobian();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamGaussianConditional_keys_920(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGaussianConditional_negate_921(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("negate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap_shared_ptr(obj->negate(),"gtsam.GaussianFactor", true);
}

void gtsamGaussianConditional_print_922(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussianConditional_scaleFrontalsBySigma_923(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("scaleFrontalsBySigma",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  gtsam::VectorValues& gy = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  obj->scaleFrontalsBySigma(gy);
}

void gtsamGaussianConditional_size_924(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGaussianConditional_solve_925(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("solve",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  gtsam::VectorValues& parents = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->solve(parents))),"gtsam.VectorValues", false);
}

void gtsamGaussianConditional_solveOtherRHS_926(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("solveOtherRHS",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  gtsam::VectorValues& parents = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  gtsam::VectorValues& rhs = *unwrap_shared_ptr< gtsam::VectorValues >(in[2], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->solveOtherRHS(parents,rhs))),"gtsam.VectorValues", false);
}

void gtsamGaussianConditional_solveTransposeInPlace_927(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("solveTransposeInPlace",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  gtsam::VectorValues& gy = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  obj->solveTransposeInPlace(gy);
}

void gtsamGaussianConditional_string_serialize_928(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianConditional>(in[0], "ptr_gtsamGaussianConditional");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamGaussianConditional_string_deserialize_929(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> Shared;
  checkArguments("gtsamGaussianConditional.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::GaussianConditional());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.GaussianConditional", false);
}
void gtsamGaussianDensity_collectorInsertAndMakeBase_930(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussianDensity.insert(self);

  typedef boost::shared_ptr<gtsam::GaussianConditional> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGaussianDensity_upcastFromVoid_931(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GaussianDensity>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGaussianDensity_constructor_932(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector d = unwrap< Vector >(in[1]);
  Matrix R = unwrap< Matrix >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> sigmas = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[3], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::GaussianDensity(key,d,R,sigmas));
  collector_gtsamGaussianDensity.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::GaussianConditional> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussianDensity_deconstructor_933(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("delete_gtsamGaussianDensity",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussianDensity::iterator item;
  item = collector_gtsamGaussianDensity.find(self);
  if(item != collector_gtsamGaussianDensity.end()) {
    delete self;
    collector_gtsamGaussianDensity.erase(item);
  }
}

void gtsamGaussianDensity_augmentedInformation_934(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("augmentedInformation",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< Matrix >(obj->augmentedInformation());
}

void gtsamGaussianDensity_augmentedJacobian_935(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("augmentedJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< Matrix >(obj->augmentedJacobian());
}

void gtsamGaussianDensity_clone_936(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.GaussianFactor", true);
}

void gtsamGaussianDensity_covariance_937(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("covariance",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< Matrix >(obj->covariance());
}

void gtsamGaussianDensity_empty_938(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamGaussianDensity_equals_939(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  gtsam::GaussianDensity& cg = *unwrap_shared_ptr< gtsam::GaussianDensity >(in[1], "ptr_gtsamGaussianDensity");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(cg,tol));
}

void gtsamGaussianDensity_error_940(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  gtsam::VectorValues& c = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGaussianDensity_information_941(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("information",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< Matrix >(obj->information());
}

void gtsamGaussianDensity_jacobian_942(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("jacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  pair< Matrix, Vector > pairResult = obj->jacobian();
  out[0] = wrap< Matrix >(pairResult.first);
  out[1] = wrap< Vector >(pairResult.second);
}

void gtsamGaussianDensity_keys_943(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGaussianDensity_mean_944(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("mean",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< Vector >(obj->mean());
}

void gtsamGaussianDensity_negate_945(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("negate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap_shared_ptr(obj->negate(),"gtsam.GaussianFactor", true);
}

void gtsamGaussianDensity_print_946(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussianDensity_scaleFrontalsBySigma_947(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("scaleFrontalsBySigma",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  gtsam::VectorValues& gy = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  obj->scaleFrontalsBySigma(gy);
}

void gtsamGaussianDensity_size_948(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGaussianDensity_solve_949(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("solve",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  gtsam::VectorValues& parents = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->solve(parents))),"gtsam.VectorValues", false);
}

void gtsamGaussianDensity_solveOtherRHS_950(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("solveOtherRHS",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  gtsam::VectorValues& parents = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  gtsam::VectorValues& rhs = *unwrap_shared_ptr< gtsam::VectorValues >(in[2], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->solveOtherRHS(parents,rhs))),"gtsam.VectorValues", false);
}

void gtsamGaussianDensity_solveTransposeInPlace_951(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> Shared;
  checkArguments("solveTransposeInPlace",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianDensity>(in[0], "ptr_gtsamGaussianDensity");
  gtsam::VectorValues& gy = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  obj->solveTransposeInPlace(gy);
}

void gtsamGaussianBayesNet_collectorInsertAndMakeBase_952(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussianBayesNet.insert(self);
}

void gtsamGaussianBayesNet_upcastFromVoid_953(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GaussianBayesNet>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGaussianBayesNet_constructor_954(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;

  Shared *self = new Shared(new gtsam::GaussianBayesNet());
  collector_gtsamGaussianBayesNet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianBayesNet_constructor_955(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;

  boost::shared_ptr<gtsam::GaussianConditional> conditional = unwrap_shared_ptr< gtsam::GaussianConditional >(in[0], "ptr_gtsamGaussianConditional");
  Shared *self = new Shared(new gtsam::GaussianBayesNet(conditional));
  collector_gtsamGaussianBayesNet.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianBayesNet_deconstructor_956(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("delete_gtsamGaussianBayesNet",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussianBayesNet::iterator item;
  item = collector_gtsamGaussianBayesNet.find(self);
  if(item != collector_gtsamGaussianBayesNet.end()) {
    delete self;
    collector_gtsamGaussianBayesNet.erase(item);
  }
}

void gtsamGaussianBayesNet_at_957(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> SharedGaussianConditional;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->at(idx),"gtsam.GaussianConditional", true);
}

void gtsamGaussianBayesNet_back_958(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> SharedGaussianConditional;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("back",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap_shared_ptr(obj->back(),"gtsam.GaussianConditional", true);
}

void gtsamGaussianBayesNet_backSubstitute_959(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("backSubstitute",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  gtsam::VectorValues& gx = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->backSubstitute(gx))),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesNet_backSubstituteTranspose_960(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("backSubstituteTranspose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  gtsam::VectorValues& gx = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->backSubstituteTranspose(gx))),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesNet_determinant_961(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("determinant",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap< double >(obj->determinant());
}

void gtsamGaussianBayesNet_equals_962(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  gtsam::GaussianBayesNet& other = *unwrap_shared_ptr< gtsam::GaussianBayesNet >(in[1], "ptr_gtsamGaussianBayesNet");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamGaussianBayesNet_error_963(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  gtsam::VectorValues& x = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(x));
}

void gtsamGaussianBayesNet_exists_964(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("exists",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->exists(idx));
}

void gtsamGaussianBayesNet_front_965(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> SharedGaussianConditional;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("front",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap_shared_ptr(obj->front(),"gtsam.GaussianConditional", true);
}

void gtsamGaussianBayesNet_gradient_966(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("gradient",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  gtsam::VectorValues& x0 = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->gradient(x0))),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesNet_gradientAtZero_967(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("gradientAtZero",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->gradientAtZero())),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesNet_keys_968(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> SharedKeySet;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap_shared_ptr(SharedKeySet(new gtsam::KeySet(obj->keys())),"gtsam.KeySet", false);
}

void gtsamGaussianBayesNet_logDeterminant_969(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("logDeterminant",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap< double >(obj->logDeterminant());
}

void gtsamGaussianBayesNet_optimize_970(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimize())),"gtsam.VectorValues", false);
}
void gtsamGaussianBayesNet_optimize_971(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("optimize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  gtsam::VectorValues& solutionForMissing = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimize(solutionForMissing))),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesNet_optimizeGradientSearch_972(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("optimizeGradientSearch",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimizeGradientSearch())),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesNet_print_973(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussianBayesNet_push_back_974(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  boost::shared_ptr<gtsam::GaussianConditional> conditional = unwrap_shared_ptr< gtsam::GaussianConditional >(in[1], "ptr_gtsamGaussianConditional");
  obj->push_back(conditional);
}
void gtsamGaussianBayesNet_push_back_975(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  gtsam::GaussianBayesNet& bayesNet = *unwrap_shared_ptr< gtsam::GaussianBayesNet >(in[1], "ptr_gtsamGaussianBayesNet");
  obj->push_back(bayesNet);
}

void gtsamGaussianBayesNet_size_976(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesNet>(in[0], "ptr_gtsamGaussianBayesNet");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGaussianBayesTree_collectorInsertAndMakeBase_977(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussianBayesTree.insert(self);
}

void gtsamGaussianBayesTree_upcastFromVoid_978(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GaussianBayesTree>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGaussianBayesTree_constructor_979(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;

  Shared *self = new Shared(new gtsam::GaussianBayesTree());
  collector_gtsamGaussianBayesTree.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianBayesTree_constructor_980(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;

  gtsam::GaussianBayesTree& other = *unwrap_shared_ptr< gtsam::GaussianBayesTree >(in[0], "ptr_gtsamGaussianBayesTree");
  Shared *self = new Shared(new gtsam::GaussianBayesTree(other));
  collector_gtsamGaussianBayesTree.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianBayesTree_deconstructor_981(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("delete_gtsamGaussianBayesTree",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussianBayesTree::iterator item;
  item = collector_gtsamGaussianBayesTree.find(self);
  if(item != collector_gtsamGaussianBayesTree.end()) {
    delete self;
    collector_gtsamGaussianBayesTree.erase(item);
  }
}

void gtsamGaussianBayesTree_determinant_982(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("determinant",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap< double >(obj->determinant());
}

void gtsamGaussianBayesTree_empty_983(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamGaussianBayesTree_equals_984(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  gtsam::GaussianBayesTree& other = *unwrap_shared_ptr< gtsam::GaussianBayesTree >(in[1], "ptr_gtsamGaussianBayesTree");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamGaussianBayesTree_error_985(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  gtsam::VectorValues& x = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap< double >(obj->error(x));
}

void gtsamGaussianBayesTree_gradient_986(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("gradient",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  gtsam::VectorValues& x0 = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->gradient(x0))),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesTree_gradientAtZero_987(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("gradientAtZero",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->gradientAtZero())),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesTree_joint_988(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("joint",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  size_t key1 = unwrap< size_t >(in[1]);
  size_t key2 = unwrap< size_t >(in[2]);
  out[0] = wrap_shared_ptr(obj->joint(key1,key2),"gtsam.GaussianFactorGraph", false);
}

void gtsamGaussianBayesTree_jointBayesNet_989(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesNet> SharedGaussianBayesNet;
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("jointBayesNet",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  size_t key1 = unwrap< size_t >(in[1]);
  size_t key2 = unwrap< size_t >(in[2]);
  out[0] = wrap_shared_ptr(obj->jointBayesNet(key1,key2),"gtsam.GaussianBayesNet", true);
}

void gtsamGaussianBayesTree_logDeterminant_990(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("logDeterminant",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap< double >(obj->logDeterminant());
}

void gtsamGaussianBayesTree_marginalCovariance_991(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("marginalCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< Matrix >(obj->marginalCovariance(key));
}

void gtsamGaussianBayesTree_marginalFactor_992(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianConditional> SharedGaussianConditional;
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("marginalFactor",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->marginalFactor(key),"gtsam.GaussianConditional", true);
}

void gtsamGaussianBayesTree_numCachedSeparatorMarginals_993(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("numCachedSeparatorMarginals",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap< size_t >(obj->numCachedSeparatorMarginals());
}

void gtsamGaussianBayesTree_optimize_994(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimize())),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesTree_optimizeGradientSearch_995(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("optimizeGradientSearch",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimizeGradientSearch())),"gtsam.VectorValues", false);
}

void gtsamGaussianBayesTree_print_996(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussianBayesTree_saveGraph_997(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("saveGraph",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  string s = unwrap< string >(in[1]);
  obj->saveGraph(s);
}

void gtsamGaussianBayesTree_size_998(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianBayesTree> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianBayesTree>(in[0], "ptr_gtsamGaussianBayesTree");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamErrors_collectorInsertAndMakeBase_999(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Errors> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamErrors.insert(self);
}

void gtsamErrors_constructor_1000(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Errors> Shared;

  Shared *self = new Shared(new gtsam::Errors());
  collector_gtsamErrors.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamErrors_constructor_1001(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Errors> Shared;

  gtsam::VectorValues& V = *unwrap_shared_ptr< gtsam::VectorValues >(in[0], "ptr_gtsamVectorValues");
  Shared *self = new Shared(new gtsam::Errors(V));
  collector_gtsamErrors.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamErrors_deconstructor_1002(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Errors> Shared;
  checkArguments("delete_gtsamErrors",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamErrors::iterator item;
  item = collector_gtsamErrors.find(self);
  if(item != collector_gtsamErrors.end()) {
    delete self;
    collector_gtsamErrors.erase(item);
  }
}

void gtsamErrors_equals_1003(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Errors> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Errors>(in[0], "ptr_gtsamErrors");
  gtsam::Errors& expected = *unwrap_shared_ptr< gtsam::Errors >(in[1], "ptr_gtsamErrors");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamErrors_print_1004(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Errors> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Errors>(in[0], "ptr_gtsamErrors");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussianISAM_collectorInsertAndMakeBase_1005(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianISAM> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussianISAM.insert(self);
}

void gtsamGaussianISAM_constructor_1006(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussianISAM> Shared;

  Shared *self = new Shared(new gtsam::GaussianISAM());
  collector_gtsamGaussianISAM.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamGaussianISAM_deconstructor_1007(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianISAM> Shared;
  checkArguments("delete_gtsamGaussianISAM",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussianISAM::iterator item;
  item = collector_gtsamGaussianISAM.find(self);
  if(item != collector_gtsamGaussianISAM.end()) {
    delete self;
    collector_gtsamGaussianISAM.erase(item);
  }
}

void gtsamGaussianISAM_clear_1008(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianISAM> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianISAM>(in[0], "ptr_gtsamGaussianISAM");
  obj->clear();
}

void gtsamGaussianISAM_saveGraph_1009(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianISAM> Shared;
  checkArguments("saveGraph",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianISAM>(in[0], "ptr_gtsamGaussianISAM");
  string s = unwrap< string >(in[1]);
  obj->saveGraph(s);
}

void gtsamGaussianISAM_update_1010(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianISAM> Shared;
  checkArguments("update",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussianISAM>(in[0], "ptr_gtsamGaussianISAM");
  gtsam::GaussianFactorGraph& newFactors = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[1], "ptr_gtsamGaussianFactorGraph");
  obj->update(newFactors);
}

void gtsamIterativeOptimizationParameters_collectorInsertAndMakeBase_1011(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamIterativeOptimizationParameters.insert(self);
}

void gtsamIterativeOptimizationParameters_upcastFromVoid_1012(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::IterativeOptimizationParameters>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamIterativeOptimizationParameters_deconstructor_1013(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> Shared;
  checkArguments("delete_gtsamIterativeOptimizationParameters",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamIterativeOptimizationParameters::iterator item;
  item = collector_gtsamIterativeOptimizationParameters.find(self);
  if(item != collector_gtsamIterativeOptimizationParameters.end()) {
    delete self;
    collector_gtsamIterativeOptimizationParameters.erase(item);
  }
}

void gtsamIterativeOptimizationParameters_getVerbosity_1014(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> Shared;
  checkArguments("getVerbosity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::IterativeOptimizationParameters>(in[0], "ptr_gtsamIterativeOptimizationParameters");
  out[0] = wrap< string >(obj->getVerbosity());
}

void gtsamIterativeOptimizationParameters_print_1015(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> Shared;
  checkArguments("print",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::IterativeOptimizationParameters>(in[0], "ptr_gtsamIterativeOptimizationParameters");
  obj->print();
}

void gtsamIterativeOptimizationParameters_setVerbosity_1016(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> Shared;
  checkArguments("setVerbosity",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::IterativeOptimizationParameters>(in[0], "ptr_gtsamIterativeOptimizationParameters");
  string s = unwrap< string >(in[1]);
  obj->setVerbosity(s);
}

void gtsamConjugateGradientParameters_collectorInsertAndMakeBase_1017(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamConjugateGradientParameters.insert(self);

  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamConjugateGradientParameters_upcastFromVoid_1018(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::ConjugateGradientParameters>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamConjugateGradientParameters_constructor_1019(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;

  Shared *self = new Shared(new gtsam::ConjugateGradientParameters());
  collector_gtsamConjugateGradientParameters.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::IterativeOptimizationParameters> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamConjugateGradientParameters_deconstructor_1020(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("delete_gtsamConjugateGradientParameters",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamConjugateGradientParameters::iterator item;
  item = collector_gtsamConjugateGradientParameters.find(self);
  if(item != collector_gtsamConjugateGradientParameters.end()) {
    delete self;
    collector_gtsamConjugateGradientParameters.erase(item);
  }
}

void gtsamConjugateGradientParameters_getEpsilon_abs_1021(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("getEpsilon_abs",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  out[0] = wrap< double >(obj->getEpsilon_abs());
}

void gtsamConjugateGradientParameters_getEpsilon_rel_1022(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("getEpsilon_rel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  out[0] = wrap< double >(obj->getEpsilon_rel());
}

void gtsamConjugateGradientParameters_getMaxIterations_1023(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("getMaxIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  out[0] = wrap< int >(obj->getMaxIterations());
}

void gtsamConjugateGradientParameters_getMinIterations_1024(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("getMinIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  out[0] = wrap< int >(obj->getMinIterations());
}

void gtsamConjugateGradientParameters_getReset_1025(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("getReset",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  out[0] = wrap< int >(obj->getReset());
}

void gtsamConjugateGradientParameters_getVerbosity_1026(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("getVerbosity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  out[0] = wrap< string >(obj->getVerbosity());
}

void gtsamConjugateGradientParameters_print_1027(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("print",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  obj->print();
}

void gtsamConjugateGradientParameters_setEpsilon_abs_1028(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("setEpsilon_abs",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  double value = unwrap< double >(in[1]);
  obj->setEpsilon_abs(value);
}

void gtsamConjugateGradientParameters_setEpsilon_rel_1029(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("setEpsilon_rel",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  double value = unwrap< double >(in[1]);
  obj->setEpsilon_rel(value);
}

void gtsamConjugateGradientParameters_setMaxIterations_1030(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("setMaxIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  int value = unwrap< int >(in[1]);
  obj->setMaxIterations(value);
}

void gtsamConjugateGradientParameters_setMinIterations_1031(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("setMinIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  int value = unwrap< int >(in[1]);
  obj->setMinIterations(value);
}

void gtsamConjugateGradientParameters_setReset_1032(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("setReset",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  int value = unwrap< int >(in[1]);
  obj->setReset(value);
}

void gtsamConjugateGradientParameters_setVerbosity_1033(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> Shared;
  checkArguments("setVerbosity",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ConjugateGradientParameters>(in[0], "ptr_gtsamConjugateGradientParameters");
  string s = unwrap< string >(in[1]);
  obj->setVerbosity(s);
}

void gtsamSubgraphSolverParameters_collectorInsertAndMakeBase_1034(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSubgraphSolverParameters.insert(self);

  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamSubgraphSolverParameters_upcastFromVoid_1035(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::SubgraphSolverParameters>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamSubgraphSolverParameters_constructor_1036(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;

  Shared *self = new Shared(new gtsam::SubgraphSolverParameters());
  collector_gtsamSubgraphSolverParameters.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::ConjugateGradientParameters> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSubgraphSolverParameters_deconstructor_1037(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("delete_gtsamSubgraphSolverParameters",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSubgraphSolverParameters::iterator item;
  item = collector_gtsamSubgraphSolverParameters.find(self);
  if(item != collector_gtsamSubgraphSolverParameters.end()) {
    delete self;
    collector_gtsamSubgraphSolverParameters.erase(item);
  }
}

void gtsamSubgraphSolverParameters_getEpsilon_abs_1038(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("getEpsilon_abs",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  out[0] = wrap< double >(obj->getEpsilon_abs());
}

void gtsamSubgraphSolverParameters_getEpsilon_rel_1039(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("getEpsilon_rel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  out[0] = wrap< double >(obj->getEpsilon_rel());
}

void gtsamSubgraphSolverParameters_getMaxIterations_1040(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("getMaxIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  out[0] = wrap< int >(obj->getMaxIterations());
}

void gtsamSubgraphSolverParameters_getMinIterations_1041(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("getMinIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  out[0] = wrap< int >(obj->getMinIterations());
}

void gtsamSubgraphSolverParameters_getReset_1042(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("getReset",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  out[0] = wrap< int >(obj->getReset());
}

void gtsamSubgraphSolverParameters_getVerbosity_1043(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("getVerbosity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  out[0] = wrap< string >(obj->getVerbosity());
}

void gtsamSubgraphSolverParameters_print_1044(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("print",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  obj->print();
}

void gtsamSubgraphSolverParameters_setEpsilon_abs_1045(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("setEpsilon_abs",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  double value = unwrap< double >(in[1]);
  obj->setEpsilon_abs(value);
}

void gtsamSubgraphSolverParameters_setEpsilon_rel_1046(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("setEpsilon_rel",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  double value = unwrap< double >(in[1]);
  obj->setEpsilon_rel(value);
}

void gtsamSubgraphSolverParameters_setMaxIterations_1047(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("setMaxIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  int value = unwrap< int >(in[1]);
  obj->setMaxIterations(value);
}

void gtsamSubgraphSolverParameters_setMinIterations_1048(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("setMinIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  int value = unwrap< int >(in[1]);
  obj->setMinIterations(value);
}

void gtsamSubgraphSolverParameters_setReset_1049(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("setReset",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  int value = unwrap< int >(in[1]);
  obj->setReset(value);
}

void gtsamSubgraphSolverParameters_setVerbosity_1050(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolverParameters> Shared;
  checkArguments("setVerbosity",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolverParameters>(in[0], "ptr_gtsamSubgraphSolverParameters");
  string s = unwrap< string >(in[1]);
  obj->setVerbosity(s);
}

void gtsamSubgraphSolver_collectorInsertAndMakeBase_1051(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SubgraphSolver> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSubgraphSolver.insert(self);
}

void gtsamSubgraphSolver_upcastFromVoid_1052(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SubgraphSolver> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::SubgraphSolver>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamSubgraphSolver_constructor_1053(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SubgraphSolver> Shared;

  gtsam::GaussianFactorGraph& A = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::SubgraphSolverParameters& parameters = *unwrap_shared_ptr< gtsam::SubgraphSolverParameters >(in[1], "ptr_gtsamSubgraphSolverParameters");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[2], "ptr_gtsamOrdering");
  Shared *self = new Shared(new gtsam::SubgraphSolver(A,parameters,ordering));
  collector_gtsamSubgraphSolver.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSubgraphSolver_constructor_1054(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SubgraphSolver> Shared;

  gtsam::GaussianFactorGraph& Ab1 = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::GaussianFactorGraph& Ab2 = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[1], "ptr_gtsamGaussianFactorGraph");
  gtsam::SubgraphSolverParameters& parameters = *unwrap_shared_ptr< gtsam::SubgraphSolverParameters >(in[2], "ptr_gtsamSubgraphSolverParameters");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[3], "ptr_gtsamOrdering");
  Shared *self = new Shared(new gtsam::SubgraphSolver(Ab1,Ab2,parameters,ordering));
  collector_gtsamSubgraphSolver.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSubgraphSolver_deconstructor_1055(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SubgraphSolver> Shared;
  checkArguments("delete_gtsamSubgraphSolver",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSubgraphSolver::iterator item;
  item = collector_gtsamSubgraphSolver.find(self);
  if(item != collector_gtsamSubgraphSolver.end()) {
    delete self;
    collector_gtsamSubgraphSolver.erase(item);
  }
}

void gtsamSubgraphSolver_optimize_1056(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::SubgraphSolver> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SubgraphSolver>(in[0], "ptr_gtsamSubgraphSolver");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->optimize())),"gtsam.VectorValues", false);
}

void gtsamKalmanFilter_collectorInsertAndMakeBase_1057(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamKalmanFilter.insert(self);
}

void gtsamKalmanFilter_constructor_1058(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;

  size_t n = unwrap< size_t >(in[0]);
  Shared *self = new Shared(new gtsam::KalmanFilter(n));
  collector_gtsamKalmanFilter.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamKalmanFilter_deconstructor_1059(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("delete_gtsamKalmanFilter",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamKalmanFilter::iterator item;
  item = collector_gtsamKalmanFilter.find(self);
  if(item != collector_gtsamKalmanFilter.end()) {
    delete self;
    collector_gtsamKalmanFilter.erase(item);
  }
}

void gtsamKalmanFilter_init_1060(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> SharedGaussianDensity;
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("init",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::KalmanFilter>(in[0], "ptr_gtsamKalmanFilter");
  Vector x0 = unwrap< Vector >(in[1]);
  Matrix P0 = unwrap< Matrix >(in[2]);
  out[0] = wrap_shared_ptr(obj->init(x0,P0),"gtsam.GaussianDensity", true);
}

void gtsamKalmanFilter_predict_1061(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> SharedGaussianDensity;
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("predict",nargout,nargin-1,5);
  Shared obj = unwrap_shared_ptr<gtsam::KalmanFilter>(in[0], "ptr_gtsamKalmanFilter");
  boost::shared_ptr<gtsam::GaussianDensity> p = unwrap_shared_ptr< gtsam::GaussianDensity >(in[1], "ptr_gtsamGaussianDensity");
  Matrix F = unwrap< Matrix >(in[2]);
  Matrix B = unwrap< Matrix >(in[3]);
  Vector u = unwrap< Vector >(in[4]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> modelQ = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[5], "ptr_gtsamnoiseModelDiagonal");
  out[0] = wrap_shared_ptr(obj->predict(p,F,B,u,modelQ),"gtsam.GaussianDensity", true);
}

void gtsamKalmanFilter_predict2_1062(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> SharedGaussianDensity;
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("predict2",nargout,nargin-1,5);
  Shared obj = unwrap_shared_ptr<gtsam::KalmanFilter>(in[0], "ptr_gtsamKalmanFilter");
  boost::shared_ptr<gtsam::GaussianDensity> p = unwrap_shared_ptr< gtsam::GaussianDensity >(in[1], "ptr_gtsamGaussianDensity");
  Matrix A0 = unwrap< Matrix >(in[2]);
  Matrix A1 = unwrap< Matrix >(in[3]);
  Vector b = unwrap< Vector >(in[4]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[5], "ptr_gtsamnoiseModelDiagonal");
  out[0] = wrap_shared_ptr(obj->predict2(p,A0,A1,b,model),"gtsam.GaussianDensity", true);
}

void gtsamKalmanFilter_predictQ_1063(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> SharedGaussianDensity;
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("predictQ",nargout,nargin-1,5);
  Shared obj = unwrap_shared_ptr<gtsam::KalmanFilter>(in[0], "ptr_gtsamKalmanFilter");
  boost::shared_ptr<gtsam::GaussianDensity> p = unwrap_shared_ptr< gtsam::GaussianDensity >(in[1], "ptr_gtsamGaussianDensity");
  Matrix F = unwrap< Matrix >(in[2]);
  Matrix B = unwrap< Matrix >(in[3]);
  Vector u = unwrap< Vector >(in[4]);
  Matrix Q = unwrap< Matrix >(in[5]);
  out[0] = wrap_shared_ptr(obj->predictQ(p,F,B,u,Q),"gtsam.GaussianDensity", true);
}

void gtsamKalmanFilter_print_1064(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::KalmanFilter>(in[0], "ptr_gtsamKalmanFilter");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamKalmanFilter_update_1065(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> SharedGaussianDensity;
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("update",nargout,nargin-1,4);
  Shared obj = unwrap_shared_ptr<gtsam::KalmanFilter>(in[0], "ptr_gtsamKalmanFilter");
  boost::shared_ptr<gtsam::GaussianDensity> p = unwrap_shared_ptr< gtsam::GaussianDensity >(in[1], "ptr_gtsamGaussianDensity");
  Matrix H = unwrap< Matrix >(in[2]);
  Vector z = unwrap< Vector >(in[3]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[4], "ptr_gtsamnoiseModelDiagonal");
  out[0] = wrap_shared_ptr(obj->update(p,H,z,model),"gtsam.GaussianDensity", true);
}

void gtsamKalmanFilter_updateQ_1066(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianDensity> SharedGaussianDensity;
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("updateQ",nargout,nargin-1,4);
  Shared obj = unwrap_shared_ptr<gtsam::KalmanFilter>(in[0], "ptr_gtsamKalmanFilter");
  boost::shared_ptr<gtsam::GaussianDensity> p = unwrap_shared_ptr< gtsam::GaussianDensity >(in[1], "ptr_gtsamGaussianDensity");
  Matrix H = unwrap< Matrix >(in[2]);
  Vector z = unwrap< Vector >(in[3]);
  Matrix Q = unwrap< Matrix >(in[4]);
  out[0] = wrap_shared_ptr(obj->updateQ(p,H,z,Q),"gtsam.GaussianDensity", true);
}

void gtsamKalmanFilter_step_1067(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KalmanFilter> Shared;
  checkArguments("gtsamKalmanFilter.step",nargout,nargin,1);
  boost::shared_ptr<gtsam::GaussianDensity> p = unwrap_shared_ptr< gtsam::GaussianDensity >(in[0], "ptr_gtsamGaussianDensity");
  out[0] = wrap< size_t >(gtsam::KalmanFilter::step(p));
}

void gtsamLabeledSymbol_collectorInsertAndMakeBase_1068(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamLabeledSymbol.insert(self);
}

void gtsamLabeledSymbol_constructor_1069(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;

  size_t full_key = unwrap< size_t >(in[0]);
  Shared *self = new Shared(new gtsam::LabeledSymbol(full_key));
  collector_gtsamLabeledSymbol.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLabeledSymbol_constructor_1070(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;

  gtsam::LabeledSymbol& key = *unwrap_shared_ptr< gtsam::LabeledSymbol >(in[0], "ptr_gtsamLabeledSymbol");
  Shared *self = new Shared(new gtsam::LabeledSymbol(key));
  collector_gtsamLabeledSymbol.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLabeledSymbol_constructor_1071(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;

  unsigned char valType = unwrap< unsigned char >(in[0]);
  unsigned char label = unwrap< unsigned char >(in[1]);
  size_t j = unwrap< size_t >(in[2]);
  Shared *self = new Shared(new gtsam::LabeledSymbol(valType,label,j));
  collector_gtsamLabeledSymbol.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamLabeledSymbol_deconstructor_1072(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("delete_gtsamLabeledSymbol",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamLabeledSymbol::iterator item;
  item = collector_gtsamLabeledSymbol.find(self);
  if(item != collector_gtsamLabeledSymbol.end()) {
    delete self;
    collector_gtsamLabeledSymbol.erase(item);
  }
}

void gtsamLabeledSymbol_chr_1073(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("chr",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  out[0] = wrap< unsigned char >(obj->chr());
}

void gtsamLabeledSymbol_index_1074(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("index",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  out[0] = wrap< size_t >(obj->index());
}

void gtsamLabeledSymbol_key_1075(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("key",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  out[0] = wrap< size_t >(obj->key());
}

void gtsamLabeledSymbol_label_1076(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("label",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  out[0] = wrap< unsigned char >(obj->label());
}

void gtsamLabeledSymbol_lower_1077(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> SharedLabeledSymbol;
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("lower",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  out[0] = wrap_shared_ptr(SharedLabeledSymbol(new gtsam::LabeledSymbol(obj->lower())),"gtsam.LabeledSymbol", false);
}

void gtsamLabeledSymbol_newChr_1078(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> SharedLabeledSymbol;
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("newChr",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  unsigned char c = unwrap< unsigned char >(in[1]);
  out[0] = wrap_shared_ptr(SharedLabeledSymbol(new gtsam::LabeledSymbol(obj->newChr(c))),"gtsam.LabeledSymbol", false);
}

void gtsamLabeledSymbol_newLabel_1079(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> SharedLabeledSymbol;
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("newLabel",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  unsigned char label = unwrap< unsigned char >(in[1]);
  out[0] = wrap_shared_ptr(SharedLabeledSymbol(new gtsam::LabeledSymbol(obj->newLabel(label))),"gtsam.LabeledSymbol", false);
}

void gtsamLabeledSymbol_print_1080(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamLabeledSymbol_upper_1081(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LabeledSymbol> SharedLabeledSymbol;
  typedef boost::shared_ptr<gtsam::LabeledSymbol> Shared;
  checkArguments("upper",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LabeledSymbol>(in[0], "ptr_gtsamLabeledSymbol");
  out[0] = wrap_shared_ptr(SharedLabeledSymbol(new gtsam::LabeledSymbol(obj->upper())),"gtsam.LabeledSymbol", false);
}

void gtsamOrdering_collectorInsertAndMakeBase_1082(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Ordering> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamOrdering.insert(self);
}

void gtsamOrdering_constructor_1083(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Ordering> Shared;

  Shared *self = new Shared(new gtsam::Ordering());
  collector_gtsamOrdering.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamOrdering_constructor_1084(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Ordering> Shared;

  gtsam::Ordering& other = *unwrap_shared_ptr< gtsam::Ordering >(in[0], "ptr_gtsamOrdering");
  Shared *self = new Shared(new gtsam::Ordering(other));
  collector_gtsamOrdering.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamOrdering_deconstructor_1085(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("delete_gtsamOrdering",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamOrdering::iterator item;
  item = collector_gtsamOrdering.find(self);
  if(item != collector_gtsamOrdering.end()) {
    delete self;
    collector_gtsamOrdering.erase(item);
  }
}

void gtsamOrdering_at_1086(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Ordering>(in[0], "ptr_gtsamOrdering");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< size_t >(obj->at(key));
}

void gtsamOrdering_equals_1087(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Ordering>(in[0], "ptr_gtsamOrdering");
  gtsam::Ordering& ord = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(ord,tol));
}

void gtsamOrdering_print_1088(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Ordering>(in[0], "ptr_gtsamOrdering");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamOrdering_push_back_1089(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Ordering>(in[0], "ptr_gtsamOrdering");
  size_t key = unwrap< size_t >(in[1]);
  obj->push_back(key);
}

void gtsamOrdering_size_1090(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Ordering>(in[0], "ptr_gtsamOrdering");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamOrdering_string_serialize_1091(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Ordering>(in[0], "ptr_gtsamOrdering");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamOrdering_string_deserialize_1092(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> Shared;
  checkArguments("gtsamOrdering.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Ordering());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Ordering", false);
}
void gtsamNonlinearFactorGraph_collectorInsertAndMakeBase_1093(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearFactorGraph.insert(self);
}

void gtsamNonlinearFactorGraph_constructor_1094(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;

  Shared *self = new Shared(new gtsam::NonlinearFactorGraph());
  collector_gtsamNonlinearFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNonlinearFactorGraph_constructor_1095(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  Shared *self = new Shared(new gtsam::NonlinearFactorGraph(graph));
  collector_gtsamNonlinearFactorGraph.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNonlinearFactorGraph_deconstructor_1096(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("delete_gtsamNonlinearFactorGraph",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearFactorGraph::iterator item;
  item = collector_gtsamNonlinearFactorGraph.find(self);
  if(item != collector_gtsamNonlinearFactorGraph.end()) {
    delete self;
    collector_gtsamNonlinearFactorGraph.erase(item);
  }
}

void gtsamNonlinearFactorGraph_add_1097(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("add",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  boost::shared_ptr<gtsam::NonlinearFactor> factor = unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  obj->add(factor);
}

void gtsamNonlinearFactorGraph_at_1098(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("at",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->at(idx),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearFactorGraph_clone_1099(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  out[0] = wrap_shared_ptr(SharedNonlinearFactorGraph(new gtsam::NonlinearFactorGraph(obj->clone())),"gtsam.NonlinearFactorGraph", false);
}

void gtsamNonlinearFactorGraph_empty_1100(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamNonlinearFactorGraph_equals_1101(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::NonlinearFactorGraph& fg = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[1], "ptr_gtsamNonlinearFactorGraph");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(fg,tol));
}

void gtsamNonlinearFactorGraph_error_1102(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(values));
}

void gtsamNonlinearFactorGraph_exists_1103(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("exists",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  size_t idx = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->exists(idx));
}

void gtsamNonlinearFactorGraph_keyVector_1104(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("keyVector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keyVector())),"gtsam.KeyVector", false);
}

void gtsamNonlinearFactorGraph_keys_1105(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> SharedKeySet;
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  out[0] = wrap_shared_ptr(SharedKeySet(new gtsam::KeySet(obj->keys())),"gtsam.KeySet", false);
}

void gtsamNonlinearFactorGraph_linearize_1106(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactorGraph> SharedGaussianFactorGraph;
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(values),"gtsam.GaussianFactorGraph", false);
}

void gtsamNonlinearFactorGraph_nrFactors_1107(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("nrFactors",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  out[0] = wrap< size_t >(obj->nrFactors());
}

void gtsamNonlinearFactorGraph_orderingCOLAMD_1108(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Ordering> SharedOrdering;
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("orderingCOLAMD",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  out[0] = wrap_shared_ptr(SharedOrdering(new gtsam::Ordering(obj->orderingCOLAMD())),"gtsam.Ordering", false);
}

void gtsamNonlinearFactorGraph_print_1109(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearFactorGraph_probPrime_1110(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("probPrime",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->probPrime(values));
}

void gtsamNonlinearFactorGraph_push_back_1111(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::NonlinearFactorGraph& factors = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[1], "ptr_gtsamNonlinearFactorGraph");
  obj->push_back(factors);
}
void gtsamNonlinearFactorGraph_push_back_1112(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("push_back",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  boost::shared_ptr<gtsam::NonlinearFactor> factor = unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  obj->push_back(factor);
}

void gtsamNonlinearFactorGraph_remove_1113(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("remove",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  size_t i = unwrap< size_t >(in[1]);
  obj->remove(i);
}

void gtsamNonlinearFactorGraph_replace_1114(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("replace",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  size_t i = unwrap< size_t >(in[1]);
  boost::shared_ptr<gtsam::NonlinearFactor> factors = unwrap_shared_ptr< gtsam::NonlinearFactor >(in[2], "ptr_gtsamNonlinearFactor");
  obj->replace(i,factors);
}

void gtsamNonlinearFactorGraph_resize_1115(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("resize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  size_t size = unwrap< size_t >(in[1]);
  obj->resize(size);
}

void gtsamNonlinearFactorGraph_size_1116(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearFactorGraph_string_serialize_1117(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactorGraph>(in[0], "ptr_gtsamNonlinearFactorGraph");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearFactorGraph_string_deserialize_1118(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> Shared;
  checkArguments("gtsamNonlinearFactorGraph.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearFactorGraph());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearFactorGraph", false);
}
void gtsamNonlinearFactor_collectorInsertAndMakeBase_1119(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearFactor.insert(self);
}

void gtsamNonlinearFactor_upcastFromVoid_1120(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearFactor_deconstructor_1121(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("delete_gtsamNonlinearFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearFactor::iterator item;
  item = collector_gtsamNonlinearFactor.find(self);
  if(item != collector_gtsamNonlinearFactor.end()) {
    delete self;
    collector_gtsamNonlinearFactor.erase(item);
  }
}

void gtsamNonlinearFactor_active_1122(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearFactor_clone_1123(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearFactor_dim_1124(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearFactor_equals_1125(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  gtsam::NonlinearFactor& other = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearFactor_error_1126(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearFactor_keys_1127(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearFactor_linearize_1128(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearFactor_print_1129(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearFactor_printKeys_1130(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearFactor_size_1131(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearFactor>(in[0], "ptr_gtsamNonlinearFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNoiseModelFactor_collectorInsertAndMakeBase_1132(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNoiseModelFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNoiseModelFactor_upcastFromVoid_1133(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NoiseModelFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNoiseModelFactor_deconstructor_1134(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("delete_gtsamNoiseModelFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNoiseModelFactor::iterator item;
  item = collector_gtsamNoiseModelFactor.find(self);
  if(item != collector_gtsamNoiseModelFactor.end()) {
    delete self;
    collector_gtsamNoiseModelFactor.erase(item);
  }
}

void gtsamNoiseModelFactor_active_1135(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNoiseModelFactor_clone_1136(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNoiseModelFactor_dim_1137(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNoiseModelFactor_equals_1138(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNoiseModelFactor_error_1139(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNoiseModelFactor_get_noiseModel_1140(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNoiseModelFactor_keys_1141(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNoiseModelFactor_linearize_1142(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNoiseModelFactor_noiseModel_1143(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNoiseModelFactor_print_1144(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNoiseModelFactor_printKeys_1145(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNoiseModelFactor_size_1146(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNoiseModelFactor_unwhitenedError_1147(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNoiseModelFactor_whitenedError_1148(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NoiseModelFactor> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NoiseModelFactor>(in[0], "ptr_gtsamNoiseModelFactor");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamValues_collectorInsertAndMakeBase_1149(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Values> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamValues.insert(self);
}

void gtsamValues_constructor_1150(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Values> Shared;

  Shared *self = new Shared(new gtsam::Values());
  collector_gtsamValues.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamValues_constructor_1151(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Values> Shared;

  gtsam::Values& other = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  Shared *self = new Shared(new gtsam::Values(other));
  collector_gtsamValues.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamValues_deconstructor_1152(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("delete_gtsamValues",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamValues::iterator item;
  item = collector_gtsamValues.find(self);
  if(item != collector_gtsamValues.end()) {
    delete self;
    collector_gtsamValues.erase(item);
  }
}

void gtsamValues_at_1153(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> SharedCal3Bundler;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atCal3Bundler",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedCal3Bundler(new gtsam::Cal3Bundler(obj->at<gtsam::Cal3Bundler>(j))),"gtsam.Cal3Bundler", false);
}

void gtsamValues_at_1154(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> SharedCal3DS2;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atCal3DS2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->at<gtsam::Cal3DS2>(j).clone(),"gtsam.Cal3DS2", true);
}

void gtsamValues_at_1155(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> SharedCal3_S2;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atCal3_S2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedCal3_S2(new gtsam::Cal3_S2(obj->at<gtsam::Cal3_S2>(j))),"gtsam.Cal3_S2", false);
}

void gtsamValues_at_1156(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atConstantBias",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(obj->at<gtsam::imuBias::ConstantBias>(j))),"gtsam.imuBias.ConstantBias", false);
}

void gtsamValues_atDouble_1157(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atDouble",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap< double >(obj->atDouble(j));
}

void gtsamValues_at_1158(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> SharedEssentialMatrix;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atEssentialMatrix",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedEssentialMatrix(new gtsam::EssentialMatrix(obj->at<gtsam::EssentialMatrix>(j))),"gtsam.EssentialMatrix", false);
}

void gtsamValues_at_1159(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atMatrix",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap< Matrix >(obj->at<Matrix>(j));
}

void gtsamValues_at_1160(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atPoint2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->at<gtsam::Point2>(j))),"gtsam.Point2", false);
}

void gtsamValues_at_1161(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atPoint3",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->at<gtsam::Point3>(j))),"gtsam.Point3", false);
}

void gtsamValues_at_1162(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atPose2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->at<gtsam::Pose2>(j))),"gtsam.Pose2", false);
}

void gtsamValues_at_1163(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atPose3",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->at<gtsam::Pose3>(j))),"gtsam.Pose3", false);
}

void gtsamValues_at_1164(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atRot2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->at<gtsam::Rot2>(j))),"gtsam.Rot2", false);
}

void gtsamValues_at_1165(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atRot3",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->at<gtsam::Rot3>(j))),"gtsam.Rot3", false);
}

void gtsamValues_at_1166(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("atVector",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap< Vector >(obj->at<Vector>(j));
}

void gtsamValues_clear_1167(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  obj->clear();
}

void gtsamValues_dim_1168(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamValues_empty_1169(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamValues_equals_1170(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  gtsam::Values& other = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamValues_erase_1171(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("erase",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  obj->erase(j);
}

void gtsamValues_exists_1172(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("exists",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  out[0] = wrap< bool >(obj->exists(j));
}

void gtsamValues_insert_1173(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  obj->insert(values);
}
void gtsamValues_insert_1174(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Point2& point2 = *unwrap_shared_ptr< gtsam::Point2 >(in[2], "ptr_gtsamPoint2");
  obj->insert(j,point2);
}
void gtsamValues_insert_1175(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Point3& point3 = *unwrap_shared_ptr< gtsam::Point3 >(in[2], "ptr_gtsamPoint3");
  obj->insert(j,point3);
}
void gtsamValues_insert_1176(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Rot2& rot2 = *unwrap_shared_ptr< gtsam::Rot2 >(in[2], "ptr_gtsamRot2");
  obj->insert(j,rot2);
}
void gtsamValues_insert_1177(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Pose2& pose2 = *unwrap_shared_ptr< gtsam::Pose2 >(in[2], "ptr_gtsamPose2");
  obj->insert(j,pose2);
}
void gtsamValues_insert_1178(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Rot3& rot3 = *unwrap_shared_ptr< gtsam::Rot3 >(in[2], "ptr_gtsamRot3");
  obj->insert(j,rot3);
}
void gtsamValues_insert_1179(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Pose3& pose3 = *unwrap_shared_ptr< gtsam::Pose3 >(in[2], "ptr_gtsamPose3");
  obj->insert(j,pose3);
}
void gtsamValues_insert_1180(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Cal3_S2& cal3_s2 = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[2], "ptr_gtsamCal3_S2");
  obj->insert(j,cal3_s2);
}
void gtsamValues_insert_1181(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Cal3DS2& cal3ds2 = *unwrap_shared_ptr< gtsam::Cal3DS2 >(in[2], "ptr_gtsamCal3DS2");
  obj->insert(j,cal3ds2);
}
void gtsamValues_insert_1182(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Cal3Bundler& cal3bundler = *unwrap_shared_ptr< gtsam::Cal3Bundler >(in[2], "ptr_gtsamCal3Bundler");
  obj->insert(j,cal3bundler);
}
void gtsamValues_insert_1183(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::EssentialMatrix& essential_matrix = *unwrap_shared_ptr< gtsam::EssentialMatrix >(in[2], "ptr_gtsamEssentialMatrix");
  obj->insert(j,essential_matrix);
}
void gtsamValues_insert_1184(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::SimpleCamera& simpel_camera = *unwrap_shared_ptr< gtsam::SimpleCamera >(in[2], "ptr_gtsamSimpleCamera");
  obj->insert(j,simpel_camera);
}
void gtsamValues_insert_1185(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::imuBias::ConstantBias& constant_bias = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[2], "ptr_gtsamimuBiasConstantBias");
  obj->insert(j,constant_bias);
}
void gtsamValues_insert_1186(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  Vector vector = unwrap< Vector >(in[2]);
  obj->insert(j,vector);
}
void gtsamValues_insert_1187(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insert",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  Matrix matrix = unwrap< Matrix >(in[2]);
  obj->insert(j,matrix);
}

void gtsamValues_insertDouble_1188(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("insertDouble",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  double c = unwrap< double >(in[2]);
  obj->insertDouble(j,c);
}

void gtsamValues_keys_1189(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamValues_localCoordinates_1190(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  gtsam::Values& cp = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->localCoordinates(cp))),"gtsam.VectorValues", false);
}

void gtsamValues_print_1191(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamValues_retract_1192(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  gtsam::VectorValues& delta = *unwrap_shared_ptr< gtsam::VectorValues >(in[1], "ptr_gtsamVectorValues");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->retract(delta))),"gtsam.Values", false);
}

void gtsamValues_size_1193(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamValues_swap_1194(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("swap",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  obj->swap(values);
}

void gtsamValues_update_1195(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  obj->update(values);
}
void gtsamValues_update_1196(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Point2& point2 = *unwrap_shared_ptr< gtsam::Point2 >(in[2], "ptr_gtsamPoint2");
  obj->update(j,point2);
}
void gtsamValues_update_1197(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Point3& point3 = *unwrap_shared_ptr< gtsam::Point3 >(in[2], "ptr_gtsamPoint3");
  obj->update(j,point3);
}
void gtsamValues_update_1198(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Rot2& rot2 = *unwrap_shared_ptr< gtsam::Rot2 >(in[2], "ptr_gtsamRot2");
  obj->update(j,rot2);
}
void gtsamValues_update_1199(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Pose2& pose2 = *unwrap_shared_ptr< gtsam::Pose2 >(in[2], "ptr_gtsamPose2");
  obj->update(j,pose2);
}
void gtsamValues_update_1200(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Rot3& rot3 = *unwrap_shared_ptr< gtsam::Rot3 >(in[2], "ptr_gtsamRot3");
  obj->update(j,rot3);
}
void gtsamValues_update_1201(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Pose3& pose3 = *unwrap_shared_ptr< gtsam::Pose3 >(in[2], "ptr_gtsamPose3");
  obj->update(j,pose3);
}
void gtsamValues_update_1202(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Cal3_S2& cal3_s2 = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[2], "ptr_gtsamCal3_S2");
  obj->update(j,cal3_s2);
}
void gtsamValues_update_1203(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Cal3DS2& cal3ds2 = *unwrap_shared_ptr< gtsam::Cal3DS2 >(in[2], "ptr_gtsamCal3DS2");
  obj->update(j,cal3ds2);
}
void gtsamValues_update_1204(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::Cal3Bundler& cal3bundler = *unwrap_shared_ptr< gtsam::Cal3Bundler >(in[2], "ptr_gtsamCal3Bundler");
  obj->update(j,cal3bundler);
}
void gtsamValues_update_1205(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::EssentialMatrix& essential_matrix = *unwrap_shared_ptr< gtsam::EssentialMatrix >(in[2], "ptr_gtsamEssentialMatrix");
  obj->update(j,essential_matrix);
}
void gtsamValues_update_1206(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  gtsam::imuBias::ConstantBias& constant_bias = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[2], "ptr_gtsamimuBiasConstantBias");
  obj->update(j,constant_bias);
}
void gtsamValues_update_1207(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  Vector vector = unwrap< Vector >(in[2]);
  obj->update(j,vector);
}
void gtsamValues_update_1208(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  size_t j = unwrap< size_t >(in[1]);
  Matrix matrix = unwrap< Matrix >(in[2]);
  obj->update(j,matrix);
}

void gtsamValues_zeroVectors_1209(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("zeroVectors",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->zeroVectors())),"gtsam.VectorValues", false);
}

void gtsamValues_string_serialize_1210(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Values>(in[0], "ptr_gtsamValues");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamValues_string_deserialize_1211(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> Shared;
  checkArguments("gtsamValues.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::Values());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.Values", false);
}
void gtsamMarginals_collectorInsertAndMakeBase_1212(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Marginals> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamMarginals.insert(self);
}

void gtsamMarginals_constructor_1213(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Marginals> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& solution = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  Shared *self = new Shared(new gtsam::Marginals(graph,solution));
  collector_gtsamMarginals.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamMarginals_deconstructor_1214(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Marginals> Shared;
  checkArguments("delete_gtsamMarginals",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamMarginals::iterator item;
  item = collector_gtsamMarginals.find(self);
  if(item != collector_gtsamMarginals.end()) {
    delete self;
    collector_gtsamMarginals.erase(item);
  }
}

void gtsamMarginals_jointMarginalCovariance_1215(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JointMarginal> SharedJointMarginal;
  typedef boost::shared_ptr<gtsam::Marginals> Shared;
  checkArguments("jointMarginalCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Marginals>(in[0], "ptr_gtsamMarginals");
  gtsam::KeyVector& variables = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(SharedJointMarginal(new gtsam::JointMarginal(obj->jointMarginalCovariance(variables))),"gtsam.JointMarginal", false);
}

void gtsamMarginals_jointMarginalInformation_1216(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JointMarginal> SharedJointMarginal;
  typedef boost::shared_ptr<gtsam::Marginals> Shared;
  checkArguments("jointMarginalInformation",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Marginals>(in[0], "ptr_gtsamMarginals");
  gtsam::KeyVector& variables = *unwrap_shared_ptr< gtsam::KeyVector >(in[1], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(SharedJointMarginal(new gtsam::JointMarginal(obj->jointMarginalInformation(variables))),"gtsam.JointMarginal", false);
}

void gtsamMarginals_marginalCovariance_1217(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Marginals> Shared;
  checkArguments("marginalCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Marginals>(in[0], "ptr_gtsamMarginals");
  size_t variable = unwrap< size_t >(in[1]);
  out[0] = wrap< Matrix >(obj->marginalCovariance(variable));
}

void gtsamMarginals_marginalInformation_1218(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Marginals> Shared;
  checkArguments("marginalInformation",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Marginals>(in[0], "ptr_gtsamMarginals");
  size_t variable = unwrap< size_t >(in[1]);
  out[0] = wrap< Matrix >(obj->marginalInformation(variable));
}

void gtsamMarginals_print_1219(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Marginals> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Marginals>(in[0], "ptr_gtsamMarginals");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamJointMarginal_collectorInsertAndMakeBase_1220(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::JointMarginal> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamJointMarginal.insert(self);
}

void gtsamJointMarginal_deconstructor_1221(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JointMarginal> Shared;
  checkArguments("delete_gtsamJointMarginal",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamJointMarginal::iterator item;
  item = collector_gtsamJointMarginal.find(self);
  if(item != collector_gtsamJointMarginal.end()) {
    delete self;
    collector_gtsamJointMarginal.erase(item);
  }
}

void gtsamJointMarginal_at_1222(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JointMarginal> Shared;
  checkArguments("at",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::JointMarginal>(in[0], "ptr_gtsamJointMarginal");
  size_t iVariable = unwrap< size_t >(in[1]);
  size_t jVariable = unwrap< size_t >(in[2]);
  out[0] = wrap< Matrix >(obj->at(iVariable,jVariable));
}

void gtsamJointMarginal_fullMatrix_1223(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JointMarginal> Shared;
  checkArguments("fullMatrix",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JointMarginal>(in[0], "ptr_gtsamJointMarginal");
  out[0] = wrap< Matrix >(obj->fullMatrix());
}

void gtsamJointMarginal_print_1224(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JointMarginal> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::JointMarginal>(in[0], "ptr_gtsamJointMarginal");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}
void gtsamJointMarginal_print_1225(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JointMarginal> Shared;
  checkArguments("print",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::JointMarginal>(in[0], "ptr_gtsamJointMarginal");
  obj->print();
}

void gtsamLinearContainerFactor_collectorInsertAndMakeBase_1226(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamLinearContainerFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamLinearContainerFactor_upcastFromVoid_1227(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::LinearContainerFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamLinearContainerFactor_constructor_1228(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;

  boost::shared_ptr<gtsam::GaussianFactor> factor = unwrap_shared_ptr< gtsam::GaussianFactor >(in[0], "ptr_gtsamGaussianFactor");
  gtsam::Values& linearizationPoint = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  Shared *self = new Shared(new gtsam::LinearContainerFactor(factor,linearizationPoint));
  collector_gtsamLinearContainerFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamLinearContainerFactor_constructor_1229(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;

  boost::shared_ptr<gtsam::GaussianFactor> factor = unwrap_shared_ptr< gtsam::GaussianFactor >(in[0], "ptr_gtsamGaussianFactor");
  Shared *self = new Shared(new gtsam::LinearContainerFactor(factor));
  collector_gtsamLinearContainerFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamLinearContainerFactor_deconstructor_1230(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("delete_gtsamLinearContainerFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamLinearContainerFactor::iterator item;
  item = collector_gtsamLinearContainerFactor.find(self);
  if(item != collector_gtsamLinearContainerFactor.end()) {
    delete self;
    collector_gtsamLinearContainerFactor.erase(item);
  }
}

void gtsamLinearContainerFactor_active_1231(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamLinearContainerFactor_clone_1232(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamLinearContainerFactor_dim_1233(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamLinearContainerFactor_equals_1234(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  gtsam::NonlinearFactor& other = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamLinearContainerFactor_error_1235(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamLinearContainerFactor_factor_1236(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("factor",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap_shared_ptr(obj->factor(),"gtsam.GaussianFactor", true);
}

void gtsamLinearContainerFactor_isJacobian_1237(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("isJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap< bool >(obj->isJacobian());
}

void gtsamLinearContainerFactor_keys_1238(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamLinearContainerFactor_linearize_1239(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamLinearContainerFactor_print_1240(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamLinearContainerFactor_printKeys_1241(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamLinearContainerFactor_size_1242(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamLinearContainerFactor_toHessian_1243(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::HessianFactor> SharedHessianFactor;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("toHessian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap_shared_ptr(obj->toHessian(),"gtsam.HessianFactor", true);
}

void gtsamLinearContainerFactor_toJacobian_1244(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::JacobianFactor> SharedJacobianFactor;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("toJacobian",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LinearContainerFactor>(in[0], "ptr_gtsamLinearContainerFactor");
  out[0] = wrap_shared_ptr(obj->toJacobian(),"gtsam.JacobianFactor", true);
}

void gtsamLinearContainerFactor_ConvertLinearGraph_1245(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("gtsamLinearContainerFactor.ConvertLinearGraph",nargout,nargin,2);
  gtsam::GaussianFactorGraph& linear_graph = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[0], "ptr_gtsamGaussianFactorGraph");
  gtsam::Values& linearizationPoint = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(SharedNonlinearFactorGraph(new gtsam::NonlinearFactorGraph(gtsam::LinearContainerFactor::ConvertLinearGraph(linear_graph,linearizationPoint))),"gtsam.NonlinearFactorGraph", false);
}
void gtsamLinearContainerFactor_ConvertLinearGraph_1246(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::LinearContainerFactor> Shared;
  checkArguments("gtsamLinearContainerFactor.ConvertLinearGraph",nargout,nargin,1);
  gtsam::GaussianFactorGraph& linear_graph = *unwrap_shared_ptr< gtsam::GaussianFactorGraph >(in[0], "ptr_gtsamGaussianFactorGraph");
  out[0] = wrap_shared_ptr(SharedNonlinearFactorGraph(new gtsam::NonlinearFactorGraph(gtsam::LinearContainerFactor::ConvertLinearGraph(linear_graph))),"gtsam.NonlinearFactorGraph", false);
}

void gtsamNonlinearOptimizerParams_collectorInsertAndMakeBase_1247(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearOptimizerParams.insert(self);
}

void gtsamNonlinearOptimizerParams_upcastFromVoid_1248(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearOptimizerParams>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearOptimizerParams_constructor_1249(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;

  Shared *self = new Shared(new gtsam::NonlinearOptimizerParams());
  collector_gtsamNonlinearOptimizerParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNonlinearOptimizerParams_deconstructor_1250(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("delete_gtsamNonlinearOptimizerParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearOptimizerParams::iterator item;
  item = collector_gtsamNonlinearOptimizerParams.find(self);
  if(item != collector_gtsamNonlinearOptimizerParams.end()) {
    delete self;
    collector_gtsamNonlinearOptimizerParams.erase(item);
  }
}

void gtsamNonlinearOptimizerParams_getAbsoluteErrorTol_1251(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("getAbsoluteErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< double >(obj->getAbsoluteErrorTol());
}

void gtsamNonlinearOptimizerParams_getErrorTol_1252(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("getErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< double >(obj->getErrorTol());
}

void gtsamNonlinearOptimizerParams_getLinearSolverType_1253(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("getLinearSolverType",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< string >(obj->getLinearSolverType());
}

void gtsamNonlinearOptimizerParams_getMaxIterations_1254(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("getMaxIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< int >(obj->getMaxIterations());
}

void gtsamNonlinearOptimizerParams_getRelativeErrorTol_1255(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("getRelativeErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< double >(obj->getRelativeErrorTol());
}

void gtsamNonlinearOptimizerParams_getVerbosity_1256(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("getVerbosity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< string >(obj->getVerbosity());
}

void gtsamNonlinearOptimizerParams_isCholmod_1257(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("isCholmod",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< bool >(obj->isCholmod());
}

void gtsamNonlinearOptimizerParams_isIterative_1258(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("isIterative",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< bool >(obj->isIterative());
}

void gtsamNonlinearOptimizerParams_isMultifrontal_1259(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("isMultifrontal",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< bool >(obj->isMultifrontal());
}

void gtsamNonlinearOptimizerParams_isSequential_1260(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("isSequential",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  out[0] = wrap< bool >(obj->isSequential());
}

void gtsamNonlinearOptimizerParams_print_1261(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearOptimizerParams_setAbsoluteErrorTol_1262(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setAbsoluteErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  double value = unwrap< double >(in[1]);
  obj->setAbsoluteErrorTol(value);
}

void gtsamNonlinearOptimizerParams_setErrorTol_1263(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  double value = unwrap< double >(in[1]);
  obj->setErrorTol(value);
}

void gtsamNonlinearOptimizerParams_setIterativeParams_1264(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setIterativeParams",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  boost::shared_ptr<gtsam::IterativeOptimizationParameters> params = unwrap_shared_ptr< gtsam::IterativeOptimizationParameters >(in[1], "ptr_gtsamIterativeOptimizationParameters");
  obj->setIterativeParams(params);
}

void gtsamNonlinearOptimizerParams_setLinearSolverType_1265(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setLinearSolverType",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  string solver = unwrap< string >(in[1]);
  obj->setLinearSolverType(solver);
}

void gtsamNonlinearOptimizerParams_setMaxIterations_1266(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setMaxIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  int value = unwrap< int >(in[1]);
  obj->setMaxIterations(value);
}

void gtsamNonlinearOptimizerParams_setOrdering_1267(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setOrdering",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  obj->setOrdering(ordering);
}

void gtsamNonlinearOptimizerParams_setRelativeErrorTol_1268(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setRelativeErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  double value = unwrap< double >(in[1]);
  obj->setRelativeErrorTol(value);
}

void gtsamNonlinearOptimizerParams_setVerbosity_1269(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> Shared;
  checkArguments("setVerbosity",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizerParams>(in[0], "ptr_gtsamNonlinearOptimizerParams");
  string s = unwrap< string >(in[1]);
  obj->setVerbosity(s);
}

void gtsamGaussNewtonParams_collectorInsertAndMakeBase_1270(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussNewtonParams.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGaussNewtonParams_upcastFromVoid_1271(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GaussNewtonParams>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGaussNewtonParams_constructor_1272(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;

  Shared *self = new Shared(new gtsam::GaussNewtonParams());
  collector_gtsamGaussNewtonParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussNewtonParams_deconstructor_1273(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("delete_gtsamGaussNewtonParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussNewtonParams::iterator item;
  item = collector_gtsamGaussNewtonParams.find(self);
  if(item != collector_gtsamGaussNewtonParams.end()) {
    delete self;
    collector_gtsamGaussNewtonParams.erase(item);
  }
}

void gtsamGaussNewtonParams_getAbsoluteErrorTol_1274(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("getAbsoluteErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< double >(obj->getAbsoluteErrorTol());
}

void gtsamGaussNewtonParams_getErrorTol_1275(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("getErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< double >(obj->getErrorTol());
}

void gtsamGaussNewtonParams_getLinearSolverType_1276(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("getLinearSolverType",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< string >(obj->getLinearSolverType());
}

void gtsamGaussNewtonParams_getMaxIterations_1277(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("getMaxIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< int >(obj->getMaxIterations());
}

void gtsamGaussNewtonParams_getRelativeErrorTol_1278(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("getRelativeErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< double >(obj->getRelativeErrorTol());
}

void gtsamGaussNewtonParams_getVerbosity_1279(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("getVerbosity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< string >(obj->getVerbosity());
}

void gtsamGaussNewtonParams_isCholmod_1280(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("isCholmod",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< bool >(obj->isCholmod());
}

void gtsamGaussNewtonParams_isIterative_1281(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("isIterative",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< bool >(obj->isIterative());
}

void gtsamGaussNewtonParams_isMultifrontal_1282(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("isMultifrontal",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< bool >(obj->isMultifrontal());
}

void gtsamGaussNewtonParams_isSequential_1283(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("isSequential",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  out[0] = wrap< bool >(obj->isSequential());
}

void gtsamGaussNewtonParams_print_1284(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGaussNewtonParams_setAbsoluteErrorTol_1285(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setAbsoluteErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  double value = unwrap< double >(in[1]);
  obj->setAbsoluteErrorTol(value);
}

void gtsamGaussNewtonParams_setErrorTol_1286(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  double value = unwrap< double >(in[1]);
  obj->setErrorTol(value);
}

void gtsamGaussNewtonParams_setIterativeParams_1287(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setIterativeParams",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  boost::shared_ptr<gtsam::IterativeOptimizationParameters> params = unwrap_shared_ptr< gtsam::IterativeOptimizationParameters >(in[1], "ptr_gtsamIterativeOptimizationParameters");
  obj->setIterativeParams(params);
}

void gtsamGaussNewtonParams_setLinearSolverType_1288(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setLinearSolverType",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  string solver = unwrap< string >(in[1]);
  obj->setLinearSolverType(solver);
}

void gtsamGaussNewtonParams_setMaxIterations_1289(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setMaxIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  int value = unwrap< int >(in[1]);
  obj->setMaxIterations(value);
}

void gtsamGaussNewtonParams_setOrdering_1290(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setOrdering",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  obj->setOrdering(ordering);
}

void gtsamGaussNewtonParams_setRelativeErrorTol_1291(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setRelativeErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  double value = unwrap< double >(in[1]);
  obj->setRelativeErrorTol(value);
}

void gtsamGaussNewtonParams_setVerbosity_1292(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonParams> Shared;
  checkArguments("setVerbosity",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonParams>(in[0], "ptr_gtsamGaussNewtonParams");
  string s = unwrap< string >(in[1]);
  obj->setVerbosity(s);
}

void gtsamLevenbergMarquardtParams_collectorInsertAndMakeBase_1293(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamLevenbergMarquardtParams.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamLevenbergMarquardtParams_upcastFromVoid_1294(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::LevenbergMarquardtParams>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamLevenbergMarquardtParams_constructor_1295(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;

  Shared *self = new Shared(new gtsam::LevenbergMarquardtParams());
  collector_gtsamLevenbergMarquardtParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamLevenbergMarquardtParams_deconstructor_1296(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("delete_gtsamLevenbergMarquardtParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamLevenbergMarquardtParams::iterator item;
  item = collector_gtsamLevenbergMarquardtParams.find(self);
  if(item != collector_gtsamLevenbergMarquardtParams.end()) {
    delete self;
    collector_gtsamLevenbergMarquardtParams.erase(item);
  }
}

void gtsamLevenbergMarquardtParams_getAbsoluteErrorTol_1297(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getAbsoluteErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< double >(obj->getAbsoluteErrorTol());
}

void gtsamLevenbergMarquardtParams_getErrorTol_1298(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< double >(obj->getErrorTol());
}

void gtsamLevenbergMarquardtParams_getLinearSolverType_1299(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getLinearSolverType",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< string >(obj->getLinearSolverType());
}

void gtsamLevenbergMarquardtParams_getMaxIterations_1300(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getMaxIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< int >(obj->getMaxIterations());
}

void gtsamLevenbergMarquardtParams_getRelativeErrorTol_1301(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getRelativeErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< double >(obj->getRelativeErrorTol());
}

void gtsamLevenbergMarquardtParams_getVerbosity_1302(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getVerbosity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< string >(obj->getVerbosity());
}

void gtsamLevenbergMarquardtParams_getVerbosityLM_1303(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getVerbosityLM",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< string >(obj->getVerbosityLM());
}

void gtsamLevenbergMarquardtParams_getlambdaFactor_1304(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getlambdaFactor",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< double >(obj->getlambdaFactor());
}

void gtsamLevenbergMarquardtParams_getlambdaInitial_1305(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getlambdaInitial",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< double >(obj->getlambdaInitial());
}

void gtsamLevenbergMarquardtParams_getlambdaUpperBound_1306(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("getlambdaUpperBound",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< double >(obj->getlambdaUpperBound());
}

void gtsamLevenbergMarquardtParams_isCholmod_1307(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("isCholmod",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< bool >(obj->isCholmod());
}

void gtsamLevenbergMarquardtParams_isIterative_1308(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("isIterative",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< bool >(obj->isIterative());
}

void gtsamLevenbergMarquardtParams_isMultifrontal_1309(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("isMultifrontal",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< bool >(obj->isMultifrontal());
}

void gtsamLevenbergMarquardtParams_isSequential_1310(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("isSequential",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  out[0] = wrap< bool >(obj->isSequential());
}

void gtsamLevenbergMarquardtParams_print_1311(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamLevenbergMarquardtParams_setAbsoluteErrorTol_1312(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setAbsoluteErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  double value = unwrap< double >(in[1]);
  obj->setAbsoluteErrorTol(value);
}

void gtsamLevenbergMarquardtParams_setErrorTol_1313(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  double value = unwrap< double >(in[1]);
  obj->setErrorTol(value);
}

void gtsamLevenbergMarquardtParams_setIterativeParams_1314(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setIterativeParams",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  boost::shared_ptr<gtsam::IterativeOptimizationParameters> params = unwrap_shared_ptr< gtsam::IterativeOptimizationParameters >(in[1], "ptr_gtsamIterativeOptimizationParameters");
  obj->setIterativeParams(params);
}

void gtsamLevenbergMarquardtParams_setLinearSolverType_1315(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setLinearSolverType",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  string solver = unwrap< string >(in[1]);
  obj->setLinearSolverType(solver);
}

void gtsamLevenbergMarquardtParams_setMaxIterations_1316(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setMaxIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  int value = unwrap< int >(in[1]);
  obj->setMaxIterations(value);
}

void gtsamLevenbergMarquardtParams_setOrdering_1317(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setOrdering",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  obj->setOrdering(ordering);
}

void gtsamLevenbergMarquardtParams_setRelativeErrorTol_1318(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setRelativeErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  double value = unwrap< double >(in[1]);
  obj->setRelativeErrorTol(value);
}

void gtsamLevenbergMarquardtParams_setVerbosity_1319(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setVerbosity",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  string s = unwrap< string >(in[1]);
  obj->setVerbosity(s);
}

void gtsamLevenbergMarquardtParams_setVerbosityLM_1320(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setVerbosityLM",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  string s = unwrap< string >(in[1]);
  obj->setVerbosityLM(s);
}

void gtsamLevenbergMarquardtParams_setlambdaFactor_1321(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setlambdaFactor",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  double value = unwrap< double >(in[1]);
  obj->setlambdaFactor(value);
}

void gtsamLevenbergMarquardtParams_setlambdaInitial_1322(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setlambdaInitial",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  double value = unwrap< double >(in[1]);
  obj->setlambdaInitial(value);
}

void gtsamLevenbergMarquardtParams_setlambdaUpperBound_1323(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtParams> Shared;
  checkArguments("setlambdaUpperBound",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtParams>(in[0], "ptr_gtsamLevenbergMarquardtParams");
  double value = unwrap< double >(in[1]);
  obj->setlambdaUpperBound(value);
}

void gtsamDoglegParams_collectorInsertAndMakeBase_1324(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamDoglegParams.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamDoglegParams_upcastFromVoid_1325(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::DoglegParams>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamDoglegParams_constructor_1326(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;

  Shared *self = new Shared(new gtsam::DoglegParams());
  collector_gtsamDoglegParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizerParams> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamDoglegParams_deconstructor_1327(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("delete_gtsamDoglegParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamDoglegParams::iterator item;
  item = collector_gtsamDoglegParams.find(self);
  if(item != collector_gtsamDoglegParams.end()) {
    delete self;
    collector_gtsamDoglegParams.erase(item);
  }
}

void gtsamDoglegParams_getAbsoluteErrorTol_1328(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getAbsoluteErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< double >(obj->getAbsoluteErrorTol());
}

void gtsamDoglegParams_getDeltaInitial_1329(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getDeltaInitial",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< double >(obj->getDeltaInitial());
}

void gtsamDoglegParams_getErrorTol_1330(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< double >(obj->getErrorTol());
}

void gtsamDoglegParams_getLinearSolverType_1331(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getLinearSolverType",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< string >(obj->getLinearSolverType());
}

void gtsamDoglegParams_getMaxIterations_1332(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getMaxIterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< int >(obj->getMaxIterations());
}

void gtsamDoglegParams_getRelativeErrorTol_1333(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getRelativeErrorTol",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< double >(obj->getRelativeErrorTol());
}

void gtsamDoglegParams_getVerbosity_1334(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getVerbosity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< string >(obj->getVerbosity());
}

void gtsamDoglegParams_getVerbosityDL_1335(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("getVerbosityDL",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< string >(obj->getVerbosityDL());
}

void gtsamDoglegParams_isCholmod_1336(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("isCholmod",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< bool >(obj->isCholmod());
}

void gtsamDoglegParams_isIterative_1337(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("isIterative",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< bool >(obj->isIterative());
}

void gtsamDoglegParams_isMultifrontal_1338(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("isMultifrontal",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< bool >(obj->isMultifrontal());
}

void gtsamDoglegParams_isSequential_1339(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("isSequential",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  out[0] = wrap< bool >(obj->isSequential());
}

void gtsamDoglegParams_print_1340(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamDoglegParams_setAbsoluteErrorTol_1341(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setAbsoluteErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  double value = unwrap< double >(in[1]);
  obj->setAbsoluteErrorTol(value);
}

void gtsamDoglegParams_setDeltaInitial_1342(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setDeltaInitial",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  double deltaInitial = unwrap< double >(in[1]);
  obj->setDeltaInitial(deltaInitial);
}

void gtsamDoglegParams_setErrorTol_1343(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  double value = unwrap< double >(in[1]);
  obj->setErrorTol(value);
}

void gtsamDoglegParams_setIterativeParams_1344(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setIterativeParams",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  boost::shared_ptr<gtsam::IterativeOptimizationParameters> params = unwrap_shared_ptr< gtsam::IterativeOptimizationParameters >(in[1], "ptr_gtsamIterativeOptimizationParameters");
  obj->setIterativeParams(params);
}

void gtsamDoglegParams_setLinearSolverType_1345(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setLinearSolverType",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  string solver = unwrap< string >(in[1]);
  obj->setLinearSolverType(solver);
}

void gtsamDoglegParams_setMaxIterations_1346(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setMaxIterations",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  int value = unwrap< int >(in[1]);
  obj->setMaxIterations(value);
}

void gtsamDoglegParams_setOrdering_1347(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setOrdering",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  gtsam::Ordering& ordering = *unwrap_shared_ptr< gtsam::Ordering >(in[1], "ptr_gtsamOrdering");
  obj->setOrdering(ordering);
}

void gtsamDoglegParams_setRelativeErrorTol_1348(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setRelativeErrorTol",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  double value = unwrap< double >(in[1]);
  obj->setRelativeErrorTol(value);
}

void gtsamDoglegParams_setVerbosity_1349(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setVerbosity",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  string s = unwrap< string >(in[1]);
  obj->setVerbosity(s);
}

void gtsamDoglegParams_setVerbosityDL_1350(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegParams> Shared;
  checkArguments("setVerbosityDL",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegParams>(in[0], "ptr_gtsamDoglegParams");
  string verbosityDL = unwrap< string >(in[1]);
  obj->setVerbosityDL(verbosityDL);
}

void gtsamNonlinearOptimizer_collectorInsertAndMakeBase_1351(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearOptimizer.insert(self);
}

void gtsamNonlinearOptimizer_upcastFromVoid_1352(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearOptimizer>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearOptimizer_deconstructor_1353(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  checkArguments("delete_gtsamNonlinearOptimizer",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearOptimizer::iterator item;
  item = collector_gtsamNonlinearOptimizer.find(self);
  if(item != collector_gtsamNonlinearOptimizer.end()) {
    delete self;
    collector_gtsamNonlinearOptimizer.erase(item);
  }
}

void gtsamNonlinearOptimizer_error_1354(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  checkArguments("error",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizer>(in[0], "ptr_gtsamNonlinearOptimizer");
  out[0] = wrap< double >(obj->error());
}

void gtsamNonlinearOptimizer_iterate_1355(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  checkArguments("iterate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizer>(in[0], "ptr_gtsamNonlinearOptimizer");
  obj->iterate();
}

void gtsamNonlinearOptimizer_iterations_1356(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  checkArguments("iterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizer>(in[0], "ptr_gtsamNonlinearOptimizer");
  out[0] = wrap< int >(obj->iterations());
}

void gtsamNonlinearOptimizer_optimize_1357(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizer>(in[0], "ptr_gtsamNonlinearOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimize())),"gtsam.Values", false);
}

void gtsamNonlinearOptimizer_optimizeSafely_1358(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  checkArguments("optimizeSafely",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizer>(in[0], "ptr_gtsamNonlinearOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimizeSafely())),"gtsam.Values", false);
}

void gtsamNonlinearOptimizer_values_1359(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> Shared;
  checkArguments("values",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearOptimizer>(in[0], "ptr_gtsamNonlinearOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->values())),"gtsam.Values", false);
}

void gtsamGaussNewtonOptimizer_collectorInsertAndMakeBase_1360(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGaussNewtonOptimizer.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGaussNewtonOptimizer_upcastFromVoid_1361(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GaussNewtonOptimizer>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGaussNewtonOptimizer_constructor_1362(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& initialValues = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  Shared *self = new Shared(new gtsam::GaussNewtonOptimizer(graph,initialValues));
  collector_gtsamGaussNewtonOptimizer.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussNewtonOptimizer_constructor_1363(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& initialValues = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  gtsam::GaussNewtonParams& params = *unwrap_shared_ptr< gtsam::GaussNewtonParams >(in[2], "ptr_gtsamGaussNewtonParams");
  Shared *self = new Shared(new gtsam::GaussNewtonOptimizer(graph,initialValues,params));
  collector_gtsamGaussNewtonOptimizer.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGaussNewtonOptimizer_deconstructor_1364(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  checkArguments("delete_gtsamGaussNewtonOptimizer",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGaussNewtonOptimizer::iterator item;
  item = collector_gtsamGaussNewtonOptimizer.find(self);
  if(item != collector_gtsamGaussNewtonOptimizer.end()) {
    delete self;
    collector_gtsamGaussNewtonOptimizer.erase(item);
  }
}

void gtsamGaussNewtonOptimizer_error_1365(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  checkArguments("error",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonOptimizer>(in[0], "ptr_gtsamGaussNewtonOptimizer");
  out[0] = wrap< double >(obj->error());
}

void gtsamGaussNewtonOptimizer_iterate_1366(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  checkArguments("iterate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonOptimizer>(in[0], "ptr_gtsamGaussNewtonOptimizer");
  obj->iterate();
}

void gtsamGaussNewtonOptimizer_iterations_1367(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  checkArguments("iterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonOptimizer>(in[0], "ptr_gtsamGaussNewtonOptimizer");
  out[0] = wrap< int >(obj->iterations());
}

void gtsamGaussNewtonOptimizer_optimize_1368(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonOptimizer>(in[0], "ptr_gtsamGaussNewtonOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimize())),"gtsam.Values", false);
}

void gtsamGaussNewtonOptimizer_optimizeSafely_1369(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  checkArguments("optimizeSafely",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonOptimizer>(in[0], "ptr_gtsamGaussNewtonOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimizeSafely())),"gtsam.Values", false);
}

void gtsamGaussNewtonOptimizer_values_1370(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::GaussNewtonOptimizer> Shared;
  checkArguments("values",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GaussNewtonOptimizer>(in[0], "ptr_gtsamGaussNewtonOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->values())),"gtsam.Values", false);
}

void gtsamDoglegOptimizer_collectorInsertAndMakeBase_1371(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamDoglegOptimizer.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamDoglegOptimizer_upcastFromVoid_1372(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::DoglegOptimizer>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamDoglegOptimizer_constructor_1373(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& initialValues = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  Shared *self = new Shared(new gtsam::DoglegOptimizer(graph,initialValues));
  collector_gtsamDoglegOptimizer.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamDoglegOptimizer_constructor_1374(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& initialValues = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  gtsam::DoglegParams& params = *unwrap_shared_ptr< gtsam::DoglegParams >(in[2], "ptr_gtsamDoglegParams");
  Shared *self = new Shared(new gtsam::DoglegOptimizer(graph,initialValues,params));
  collector_gtsamDoglegOptimizer.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamDoglegOptimizer_deconstructor_1375(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("delete_gtsamDoglegOptimizer",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamDoglegOptimizer::iterator item;
  item = collector_gtsamDoglegOptimizer.find(self);
  if(item != collector_gtsamDoglegOptimizer.end()) {
    delete self;
    collector_gtsamDoglegOptimizer.erase(item);
  }
}

void gtsamDoglegOptimizer_error_1376(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("error",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegOptimizer>(in[0], "ptr_gtsamDoglegOptimizer");
  out[0] = wrap< double >(obj->error());
}

void gtsamDoglegOptimizer_getDelta_1377(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("getDelta",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegOptimizer>(in[0], "ptr_gtsamDoglegOptimizer");
  out[0] = wrap< double >(obj->getDelta());
}

void gtsamDoglegOptimizer_iterate_1378(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("iterate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegOptimizer>(in[0], "ptr_gtsamDoglegOptimizer");
  obj->iterate();
}

void gtsamDoglegOptimizer_iterations_1379(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("iterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegOptimizer>(in[0], "ptr_gtsamDoglegOptimizer");
  out[0] = wrap< int >(obj->iterations());
}

void gtsamDoglegOptimizer_optimize_1380(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegOptimizer>(in[0], "ptr_gtsamDoglegOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimize())),"gtsam.Values", false);
}

void gtsamDoglegOptimizer_optimizeSafely_1381(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("optimizeSafely",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegOptimizer>(in[0], "ptr_gtsamDoglegOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimizeSafely())),"gtsam.Values", false);
}

void gtsamDoglegOptimizer_values_1382(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::DoglegOptimizer> Shared;
  checkArguments("values",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::DoglegOptimizer>(in[0], "ptr_gtsamDoglegOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->values())),"gtsam.Values", false);
}

void gtsamLevenbergMarquardtOptimizer_collectorInsertAndMakeBase_1383(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamLevenbergMarquardtOptimizer.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamLevenbergMarquardtOptimizer_upcastFromVoid_1384(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::LevenbergMarquardtOptimizer>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamLevenbergMarquardtOptimizer_constructor_1385(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& initialValues = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  Shared *self = new Shared(new gtsam::LevenbergMarquardtOptimizer(graph,initialValues));
  collector_gtsamLevenbergMarquardtOptimizer.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamLevenbergMarquardtOptimizer_constructor_1386(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;

  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& initialValues = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  gtsam::LevenbergMarquardtParams& params = *unwrap_shared_ptr< gtsam::LevenbergMarquardtParams >(in[2], "ptr_gtsamLevenbergMarquardtParams");
  Shared *self = new Shared(new gtsam::LevenbergMarquardtOptimizer(graph,initialValues,params));
  collector_gtsamLevenbergMarquardtOptimizer.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearOptimizer> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamLevenbergMarquardtOptimizer_deconstructor_1387(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("delete_gtsamLevenbergMarquardtOptimizer",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamLevenbergMarquardtOptimizer::iterator item;
  item = collector_gtsamLevenbergMarquardtOptimizer.find(self);
  if(item != collector_gtsamLevenbergMarquardtOptimizer.end()) {
    delete self;
    collector_gtsamLevenbergMarquardtOptimizer.erase(item);
  }
}

void gtsamLevenbergMarquardtOptimizer_error_1388(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("error",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  out[0] = wrap< double >(obj->error());
}

void gtsamLevenbergMarquardtOptimizer_iterate_1389(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("iterate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  obj->iterate();
}

void gtsamLevenbergMarquardtOptimizer_iterations_1390(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("iterations",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  out[0] = wrap< int >(obj->iterations());
}

void gtsamLevenbergMarquardtOptimizer_lambda_1391(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("lambda",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  out[0] = wrap< double >(obj->lambda());
}

void gtsamLevenbergMarquardtOptimizer_optimize_1392(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("optimize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimize())),"gtsam.Values", false);
}

void gtsamLevenbergMarquardtOptimizer_optimizeSafely_1393(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("optimizeSafely",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->optimizeSafely())),"gtsam.Values", false);
}

void gtsamLevenbergMarquardtOptimizer_print_1394(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  string str = unwrap< string >(in[1]);
  obj->print(str);
}

void gtsamLevenbergMarquardtOptimizer_values_1395(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::LevenbergMarquardtOptimizer> Shared;
  checkArguments("values",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::LevenbergMarquardtOptimizer>(in[0], "ptr_gtsamLevenbergMarquardtOptimizer");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->values())),"gtsam.Values", false);
}

void gtsamISAM2GaussNewtonParams_collectorInsertAndMakeBase_1396(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2GaussNewtonParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2GaussNewtonParams.insert(self);
}

void gtsamISAM2GaussNewtonParams_constructor_1397(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2GaussNewtonParams> Shared;

  Shared *self = new Shared(new gtsam::ISAM2GaussNewtonParams());
  collector_gtsamISAM2GaussNewtonParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2GaussNewtonParams_deconstructor_1398(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2GaussNewtonParams> Shared;
  checkArguments("delete_gtsamISAM2GaussNewtonParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2GaussNewtonParams::iterator item;
  item = collector_gtsamISAM2GaussNewtonParams.find(self);
  if(item != collector_gtsamISAM2GaussNewtonParams.end()) {
    delete self;
    collector_gtsamISAM2GaussNewtonParams.erase(item);
  }
}

void gtsamISAM2GaussNewtonParams_getWildfireThreshold_1399(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2GaussNewtonParams> Shared;
  checkArguments("getWildfireThreshold",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2GaussNewtonParams>(in[0], "ptr_gtsamISAM2GaussNewtonParams");
  out[0] = wrap< double >(obj->getWildfireThreshold());
}

void gtsamISAM2GaussNewtonParams_print_1400(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2GaussNewtonParams> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2GaussNewtonParams>(in[0], "ptr_gtsamISAM2GaussNewtonParams");
  string str = unwrap< string >(in[1]);
  obj->print(str);
}

void gtsamISAM2GaussNewtonParams_setWildfireThreshold_1401(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2GaussNewtonParams> Shared;
  checkArguments("setWildfireThreshold",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2GaussNewtonParams>(in[0], "ptr_gtsamISAM2GaussNewtonParams");
  double wildfireThreshold = unwrap< double >(in[1]);
  obj->setWildfireThreshold(wildfireThreshold);
}

void gtsamISAM2DoglegParams_collectorInsertAndMakeBase_1402(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2DoglegParams.insert(self);
}

void gtsamISAM2DoglegParams_constructor_1403(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;

  Shared *self = new Shared(new gtsam::ISAM2DoglegParams());
  collector_gtsamISAM2DoglegParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2DoglegParams_deconstructor_1404(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("delete_gtsamISAM2DoglegParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2DoglegParams::iterator item;
  item = collector_gtsamISAM2DoglegParams.find(self);
  if(item != collector_gtsamISAM2DoglegParams.end()) {
    delete self;
    collector_gtsamISAM2DoglegParams.erase(item);
  }
}

void gtsamISAM2DoglegParams_getAdaptationMode_1405(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("getAdaptationMode",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  out[0] = wrap< string >(obj->getAdaptationMode());
}

void gtsamISAM2DoglegParams_getInitialDelta_1406(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("getInitialDelta",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  out[0] = wrap< double >(obj->getInitialDelta());
}

void gtsamISAM2DoglegParams_getWildfireThreshold_1407(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("getWildfireThreshold",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  out[0] = wrap< double >(obj->getWildfireThreshold());
}

void gtsamISAM2DoglegParams_isVerbose_1408(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("isVerbose",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  out[0] = wrap< bool >(obj->isVerbose());
}

void gtsamISAM2DoglegParams_print_1409(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  string str = unwrap< string >(in[1]);
  obj->print(str);
}

void gtsamISAM2DoglegParams_setAdaptationMode_1410(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("setAdaptationMode",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  string adaptationMode = unwrap< string >(in[1]);
  obj->setAdaptationMode(adaptationMode);
}

void gtsamISAM2DoglegParams_setInitialDelta_1411(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("setInitialDelta",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  double initialDelta = unwrap< double >(in[1]);
  obj->setInitialDelta(initialDelta);
}

void gtsamISAM2DoglegParams_setVerbose_1412(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("setVerbose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  bool verbose = unwrap< bool >(in[1]);
  obj->setVerbose(verbose);
}

void gtsamISAM2DoglegParams_setWildfireThreshold_1413(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2DoglegParams> Shared;
  checkArguments("setWildfireThreshold",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2DoglegParams>(in[0], "ptr_gtsamISAM2DoglegParams");
  double wildfireThreshold = unwrap< double >(in[1]);
  obj->setWildfireThreshold(wildfireThreshold);
}

void gtsamISAM2ThresholdMapValue_collectorInsertAndMakeBase_1414(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMapValue> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2ThresholdMapValue.insert(self);
}

void gtsamISAM2ThresholdMapValue_constructor_1415(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMapValue> Shared;

  char c = unwrap< char >(in[0]);
  Vector thresholds = unwrap< Vector >(in[1]);
  Shared *self = new Shared(new gtsam::ISAM2ThresholdMapValue(c,thresholds));
  collector_gtsamISAM2ThresholdMapValue.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2ThresholdMapValue_constructor_1416(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMapValue> Shared;

  gtsam::ISAM2ThresholdMapValue& other = *unwrap_shared_ptr< gtsam::ISAM2ThresholdMapValue >(in[0], "ptr_gtsamISAM2ThresholdMapValue");
  Shared *self = new Shared(new gtsam::ISAM2ThresholdMapValue(other));
  collector_gtsamISAM2ThresholdMapValue.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2ThresholdMapValue_deconstructor_1417(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMapValue> Shared;
  checkArguments("delete_gtsamISAM2ThresholdMapValue",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2ThresholdMapValue::iterator item;
  item = collector_gtsamISAM2ThresholdMapValue.find(self);
  if(item != collector_gtsamISAM2ThresholdMapValue.end()) {
    delete self;
    collector_gtsamISAM2ThresholdMapValue.erase(item);
  }
}

void gtsamISAM2ThresholdMap_collectorInsertAndMakeBase_1418(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2ThresholdMap.insert(self);
}

void gtsamISAM2ThresholdMap_constructor_1419(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;

  Shared *self = new Shared(new gtsam::ISAM2ThresholdMap());
  collector_gtsamISAM2ThresholdMap.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2ThresholdMap_constructor_1420(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;

  gtsam::ISAM2ThresholdMap& other = *unwrap_shared_ptr< gtsam::ISAM2ThresholdMap >(in[0], "ptr_gtsamISAM2ThresholdMap");
  Shared *self = new Shared(new gtsam::ISAM2ThresholdMap(other));
  collector_gtsamISAM2ThresholdMap.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2ThresholdMap_deconstructor_1421(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;
  checkArguments("delete_gtsamISAM2ThresholdMap",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2ThresholdMap::iterator item;
  item = collector_gtsamISAM2ThresholdMap.find(self);
  if(item != collector_gtsamISAM2ThresholdMap.end()) {
    delete self;
    collector_gtsamISAM2ThresholdMap.erase(item);
  }
}

void gtsamISAM2ThresholdMap_clear_1422(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;
  checkArguments("clear",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2ThresholdMap>(in[0], "ptr_gtsamISAM2ThresholdMap");
  obj->clear();
}

void gtsamISAM2ThresholdMap_empty_1423(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;
  checkArguments("empty",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2ThresholdMap>(in[0], "ptr_gtsamISAM2ThresholdMap");
  out[0] = wrap< bool >(obj->empty());
}

void gtsamISAM2ThresholdMap_insert_1424(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;
  checkArguments("insert",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2ThresholdMap>(in[0], "ptr_gtsamISAM2ThresholdMap");
  gtsam::ISAM2ThresholdMapValue& value = *unwrap_shared_ptr< gtsam::ISAM2ThresholdMapValue >(in[1], "ptr_gtsamISAM2ThresholdMapValue");
  obj->insert(value);
}

void gtsamISAM2ThresholdMap_size_1425(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2ThresholdMap> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2ThresholdMap>(in[0], "ptr_gtsamISAM2ThresholdMap");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamISAM2Params_collectorInsertAndMakeBase_1426(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2Params.insert(self);
}

void gtsamISAM2Params_constructor_1427(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;

  Shared *self = new Shared(new gtsam::ISAM2Params());
  collector_gtsamISAM2Params.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2Params_deconstructor_1428(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("delete_gtsamISAM2Params",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2Params::iterator item;
  item = collector_gtsamISAM2Params.find(self);
  if(item != collector_gtsamISAM2Params.end()) {
    delete self;
    collector_gtsamISAM2Params.erase(item);
  }
}

void gtsamISAM2Params_getFactorization_1429(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("getFactorization",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  out[0] = wrap< string >(obj->getFactorization());
}

void gtsamISAM2Params_getRelinearizeSkip_1430(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("getRelinearizeSkip",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  out[0] = wrap< int >(obj->getRelinearizeSkip());
}

void gtsamISAM2Params_isCacheLinearizedFactors_1431(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("isCacheLinearizedFactors",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  out[0] = wrap< bool >(obj->isCacheLinearizedFactors());
}

void gtsamISAM2Params_isEnableDetailedResults_1432(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("isEnableDetailedResults",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  out[0] = wrap< bool >(obj->isEnableDetailedResults());
}

void gtsamISAM2Params_isEnablePartialRelinearizationCheck_1433(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("isEnablePartialRelinearizationCheck",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  out[0] = wrap< bool >(obj->isEnablePartialRelinearizationCheck());
}

void gtsamISAM2Params_isEnableRelinearization_1434(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("isEnableRelinearization",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  out[0] = wrap< bool >(obj->isEnableRelinearization());
}

void gtsamISAM2Params_isEvaluateNonlinearError_1435(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("isEvaluateNonlinearError",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  out[0] = wrap< bool >(obj->isEvaluateNonlinearError());
}

void gtsamISAM2Params_print_1436(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  string str = unwrap< string >(in[1]);
  obj->print(str);
}

void gtsamISAM2Params_setCacheLinearizedFactors_1437(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setCacheLinearizedFactors",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  bool cacheLinearizedFactors = unwrap< bool >(in[1]);
  obj->setCacheLinearizedFactors(cacheLinearizedFactors);
}

void gtsamISAM2Params_setEnableDetailedResults_1438(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setEnableDetailedResults",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  bool enableDetailedResults = unwrap< bool >(in[1]);
  obj->setEnableDetailedResults(enableDetailedResults);
}

void gtsamISAM2Params_setEnablePartialRelinearizationCheck_1439(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setEnablePartialRelinearizationCheck",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  bool enablePartialRelinearizationCheck = unwrap< bool >(in[1]);
  obj->setEnablePartialRelinearizationCheck(enablePartialRelinearizationCheck);
}

void gtsamISAM2Params_setEnableRelinearization_1440(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setEnableRelinearization",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  bool enableRelinearization = unwrap< bool >(in[1]);
  obj->setEnableRelinearization(enableRelinearization);
}

void gtsamISAM2Params_setEvaluateNonlinearError_1441(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setEvaluateNonlinearError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  bool evaluateNonlinearError = unwrap< bool >(in[1]);
  obj->setEvaluateNonlinearError(evaluateNonlinearError);
}

void gtsamISAM2Params_setFactorization_1442(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setFactorization",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  string factorization = unwrap< string >(in[1]);
  obj->setFactorization(factorization);
}

void gtsamISAM2Params_setOptimizationParams_1443(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setOptimizationParams",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  gtsam::ISAM2GaussNewtonParams& gauss_newton__params = *unwrap_shared_ptr< gtsam::ISAM2GaussNewtonParams >(in[1], "ptr_gtsamISAM2GaussNewtonParams");
  obj->setOptimizationParams(gauss_newton__params);
}
void gtsamISAM2Params_setOptimizationParams_1444(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setOptimizationParams",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  gtsam::ISAM2DoglegParams& dogleg_params = *unwrap_shared_ptr< gtsam::ISAM2DoglegParams >(in[1], "ptr_gtsamISAM2DoglegParams");
  obj->setOptimizationParams(dogleg_params);
}

void gtsamISAM2Params_setRelinearizeSkip_1445(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setRelinearizeSkip",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  int relinearizeSkip = unwrap< int >(in[1]);
  obj->setRelinearizeSkip(relinearizeSkip);
}

void gtsamISAM2Params_setRelinearizeThreshold_1446(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setRelinearizeThreshold",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  double threshold = unwrap< double >(in[1]);
  obj->setRelinearizeThreshold(threshold);
}
void gtsamISAM2Params_setRelinearizeThreshold_1447(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> Shared;
  checkArguments("setRelinearizeThreshold",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Params>(in[0], "ptr_gtsamISAM2Params");
  gtsam::ISAM2ThresholdMap& threshold_map = *unwrap_shared_ptr< gtsam::ISAM2ThresholdMap >(in[1], "ptr_gtsamISAM2ThresholdMap");
  obj->setRelinearizeThreshold(threshold_map);
}

void gtsamISAM2Clique_collectorInsertAndMakeBase_1448(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2Clique> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2Clique.insert(self);
}

void gtsamISAM2Clique_constructor_1449(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2Clique> Shared;

  Shared *self = new Shared(new gtsam::ISAM2Clique());
  collector_gtsamISAM2Clique.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2Clique_deconstructor_1450(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Clique> Shared;
  checkArguments("delete_gtsamISAM2Clique",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2Clique::iterator item;
  item = collector_gtsamISAM2Clique.find(self);
  if(item != collector_gtsamISAM2Clique.end()) {
    delete self;
    collector_gtsamISAM2Clique.erase(item);
  }
}

void gtsamISAM2Clique_gradientContribution_1451(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Clique> Shared;
  checkArguments("gradientContribution",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Clique>(in[0], "ptr_gtsamISAM2Clique");
  out[0] = wrap< Vector >(obj->gradientContribution());
}

void gtsamISAM2Clique_print_1452(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Clique> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Clique>(in[0], "ptr_gtsamISAM2Clique");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamISAM2Result_collectorInsertAndMakeBase_1453(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2Result> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2Result.insert(self);
}

void gtsamISAM2Result_constructor_1454(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2Result> Shared;

  Shared *self = new Shared(new gtsam::ISAM2Result());
  collector_gtsamISAM2Result.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2Result_deconstructor_1455(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> Shared;
  checkArguments("delete_gtsamISAM2Result",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2Result::iterator item;
  item = collector_gtsamISAM2Result.find(self);
  if(item != collector_gtsamISAM2Result.end()) {
    delete self;
    collector_gtsamISAM2Result.erase(item);
  }
}

void gtsamISAM2Result_getCliques_1456(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> Shared;
  checkArguments("getCliques",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Result>(in[0], "ptr_gtsamISAM2Result");
  out[0] = wrap< size_t >(obj->getCliques());
}

void gtsamISAM2Result_getVariablesReeliminated_1457(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> Shared;
  checkArguments("getVariablesReeliminated",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Result>(in[0], "ptr_gtsamISAM2Result");
  out[0] = wrap< size_t >(obj->getVariablesReeliminated());
}

void gtsamISAM2Result_getVariablesRelinearized_1458(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> Shared;
  checkArguments("getVariablesRelinearized",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Result>(in[0], "ptr_gtsamISAM2Result");
  out[0] = wrap< size_t >(obj->getVariablesRelinearized());
}

void gtsamISAM2Result_print_1459(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2Result>(in[0], "ptr_gtsamISAM2Result");
  string str = unwrap< string >(in[1]);
  obj->print(str);
}

void gtsamFactorIndices_collectorInsertAndMakeBase_1460(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::FactorIndices> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamFactorIndices.insert(self);
}

void gtsamFactorIndices_deconstructor_1461(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::FactorIndices> Shared;
  checkArguments("delete_gtsamFactorIndices",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamFactorIndices::iterator item;
  item = collector_gtsamFactorIndices.find(self);
  if(item != collector_gtsamFactorIndices.end()) {
    delete self;
    collector_gtsamFactorIndices.erase(item);
  }
}

void gtsamISAM2_collectorInsertAndMakeBase_1462(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamISAM2.insert(self);
}

void gtsamISAM2_constructor_1463(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;

  Shared *self = new Shared(new gtsam::ISAM2());
  collector_gtsamISAM2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2_constructor_1464(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;

  gtsam::ISAM2Params& params = *unwrap_shared_ptr< gtsam::ISAM2Params >(in[0], "ptr_gtsamISAM2Params");
  Shared *self = new Shared(new gtsam::ISAM2(params));
  collector_gtsamISAM2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2_constructor_1465(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;

  gtsam::ISAM2& other = *unwrap_shared_ptr< gtsam::ISAM2 >(in[0], "ptr_gtsamISAM2");
  Shared *self = new Shared(new gtsam::ISAM2(other));
  collector_gtsamISAM2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamISAM2_deconstructor_1466(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("delete_gtsamISAM2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamISAM2::iterator item;
  item = collector_gtsamISAM2.find(self);
  if(item != collector_gtsamISAM2.end()) {
    delete self;
    collector_gtsamISAM2.erase(item);
  }
}

void gtsamISAM2_calculateBestEstimate_1467(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateBestEstimate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->calculateBestEstimate())),"gtsam.Values", false);
}

void gtsamISAM2_calculateEstimate_1468(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->calculateEstimate())),"gtsam.Values", false);
}

void gtsamISAM2_calculateEstimate_1469(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3Bundler> SharedCal3Bundler;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateCal3Bundler",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedCal3Bundler(new gtsam::Cal3Bundler(obj->calculateEstimate<gtsam::Cal3Bundler>(key))),"gtsam.Cal3Bundler", false);
}

void gtsamISAM2_calculateEstimate_1470(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> SharedCal3DS2;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateCal3DS2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->calculateEstimate<gtsam::Cal3DS2>(key).clone(),"gtsam.Cal3DS2", true);
}

void gtsamISAM2_calculateEstimate_1471(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> SharedCal3_S2;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateCal3_S2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedCal3_S2(new gtsam::Cal3_S2(obj->calculateEstimate<gtsam::Cal3_S2>(key))),"gtsam.Cal3_S2", false);
}

void gtsamISAM2_calculateEstimate_1472(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrix> SharedEssentialMatrix;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateEssentialMatrix",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedEssentialMatrix(new gtsam::EssentialMatrix(obj->calculateEstimate<gtsam::EssentialMatrix>(key))),"gtsam.EssentialMatrix", false);
}

void gtsamISAM2_calculateEstimate_1473(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateMatrix",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< Matrix >(obj->calculateEstimate<Matrix>(key));
}

void gtsamISAM2_calculateEstimate_1474(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimatePoint2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->calculateEstimate<gtsam::Point2>(key))),"gtsam.Point2", false);
}

void gtsamISAM2_calculateEstimate_1475(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimatePoint3",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->calculateEstimate<gtsam::Point3>(key))),"gtsam.Point3", false);
}

void gtsamISAM2_calculateEstimate_1476(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimatePose2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->calculateEstimate<gtsam::Pose2>(key))),"gtsam.Pose2", false);
}

void gtsamISAM2_calculateEstimate_1477(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimatePose3",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->calculateEstimate<gtsam::Pose3>(key))),"gtsam.Pose3", false);
}

void gtsamISAM2_calculateEstimate_1478(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateRot2",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->calculateEstimate<gtsam::Rot2>(key))),"gtsam.Rot2", false);
}

void gtsamISAM2_calculateEstimate_1479(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateRot3",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->calculateEstimate<gtsam::Rot3>(key))),"gtsam.Rot3", false);
}

void gtsamISAM2_calculateEstimate_1480(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> SharedSimpleCamera;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateSimpleCamera",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap_shared_ptr(obj->calculateEstimate<gtsam::SimpleCamera>(key).clone(),"gtsam.SimpleCamera", true);
}

void gtsamISAM2_calculateEstimate_1481(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("calculateEstimateVector",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< Vector >(obj->calculateEstimate<Vector>(key));
}

void gtsamISAM2_equals_1482(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  gtsam::ISAM2& other = *unwrap_shared_ptr< gtsam::ISAM2 >(in[1], "ptr_gtsamISAM2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamISAM2_getDelta_1483(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VectorValues> SharedVectorValues;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("getDelta",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedVectorValues(new gtsam::VectorValues(obj->getDelta())),"gtsam.VectorValues", false);
}

void gtsamISAM2_getFactorsUnsafe_1484(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("getFactorsUnsafe",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedNonlinearFactorGraph(new gtsam::NonlinearFactorGraph(obj->getFactorsUnsafe())),"gtsam.NonlinearFactorGraph", false);
}

void gtsamISAM2_getLinearizationPoint_1485(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("getLinearizationPoint",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->getLinearizationPoint())),"gtsam.Values", false);
}

void gtsamISAM2_getVariableIndex_1486(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::VariableIndex> SharedVariableIndex;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("getVariableIndex",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedVariableIndex(new gtsam::VariableIndex(obj->getVariableIndex())),"gtsam.VariableIndex", false);
}

void gtsamISAM2_marginalCovariance_1487(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("marginalCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< Matrix >(obj->marginalCovariance(key));
}

void gtsamISAM2_params_1488(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Params> SharedISAM2Params;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("params",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedISAM2Params(new gtsam::ISAM2Params(obj->params())),"gtsam.ISAM2Params", false);
}

void gtsamISAM2_print_1489(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamISAM2_printStats_1490(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("printStats",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  obj->printStats();
}

void gtsamISAM2_saveGraph_1491(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("saveGraph",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  string s = unwrap< string >(in[1]);
  obj->saveGraph(s);
}

void gtsamISAM2_update_1492(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> SharedISAM2Result;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("update",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  out[0] = wrap_shared_ptr(SharedISAM2Result(new gtsam::ISAM2Result(obj->update())),"gtsam.ISAM2Result", false);
}
void gtsamISAM2_update_1493(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> SharedISAM2Result;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  gtsam::NonlinearFactorGraph& newFactors = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[1], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& newTheta = *unwrap_shared_ptr< gtsam::Values >(in[2], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(SharedISAM2Result(new gtsam::ISAM2Result(obj->update(newFactors,newTheta))),"gtsam.ISAM2Result", false);
}
void gtsamISAM2_update_1494(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> SharedISAM2Result;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("update",nargout,nargin-1,3);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  gtsam::NonlinearFactorGraph& newFactors = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[1], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& newTheta = *unwrap_shared_ptr< gtsam::Values >(in[2], "ptr_gtsamValues");
  gtsam::FactorIndices& removeFactorIndices = *unwrap_shared_ptr< gtsam::FactorIndices >(in[3], "ptr_gtsamFactorIndices");
  out[0] = wrap_shared_ptr(SharedISAM2Result(new gtsam::ISAM2Result(obj->update(newFactors,newTheta,removeFactorIndices))),"gtsam.ISAM2Result", false);
}
void gtsamISAM2_update_1495(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ISAM2Result> SharedISAM2Result;
  typedef boost::shared_ptr<gtsam::ISAM2> Shared;
  checkArguments("update",nargout,nargin-1,4);
  Shared obj = unwrap_shared_ptr<gtsam::ISAM2>(in[0], "ptr_gtsamISAM2");
  gtsam::NonlinearFactorGraph& newFactors = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[1], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& newTheta = *unwrap_shared_ptr< gtsam::Values >(in[2], "ptr_gtsamValues");
  gtsam::FactorIndices& removeFactorIndices = *unwrap_shared_ptr< gtsam::FactorIndices >(in[3], "ptr_gtsamFactorIndices");
  gtsam::KeyGroupMap& constrainedKeys = *unwrap_shared_ptr< gtsam::KeyGroupMap >(in[4], "ptr_gtsamKeyGroupMap");
  out[0] = wrap_shared_ptr(SharedISAM2Result(new gtsam::ISAM2Result(obj->update(newFactors,newTheta,removeFactorIndices,constrainedKeys))),"gtsam.ISAM2Result", false);
}

void gtsamNonlinearISAM_collectorInsertAndMakeBase_1496(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearISAM.insert(self);
}

void gtsamNonlinearISAM_constructor_1497(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;

  Shared *self = new Shared(new gtsam::NonlinearISAM());
  collector_gtsamNonlinearISAM.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNonlinearISAM_constructor_1498(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;

  int reorderInterval = unwrap< int >(in[0]);
  Shared *self = new Shared(new gtsam::NonlinearISAM(reorderInterval));
  collector_gtsamNonlinearISAM.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNonlinearISAM_deconstructor_1499(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("delete_gtsamNonlinearISAM",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearISAM::iterator item;
  item = collector_gtsamNonlinearISAM.find(self);
  if(item != collector_gtsamNonlinearISAM.end()) {
    delete self;
    collector_gtsamNonlinearISAM.erase(item);
  }
}

void gtsamNonlinearISAM_bayesTree_1500(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianISAM> SharedGaussianISAM;
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("bayesTree",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  out[0] = wrap_shared_ptr(SharedGaussianISAM(new gtsam::GaussianISAM(obj->bayesTree())),"gtsam.GaussianISAM", false);
}

void gtsamNonlinearISAM_estimate_1501(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("estimate",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->estimate())),"gtsam.Values", false);
}

void gtsamNonlinearISAM_getFactorsUnsafe_1502(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("getFactorsUnsafe",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  out[0] = wrap_shared_ptr(SharedNonlinearFactorGraph(new gtsam::NonlinearFactorGraph(obj->getFactorsUnsafe())),"gtsam.NonlinearFactorGraph", false);
}

void gtsamNonlinearISAM_getLinearizationPoint_1503(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("getLinearizationPoint",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(obj->getLinearizationPoint())),"gtsam.Values", false);
}

void gtsamNonlinearISAM_marginalCovariance_1504(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("marginalCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  size_t key = unwrap< size_t >(in[1]);
  out[0] = wrap< Matrix >(obj->marginalCovariance(key));
}

void gtsamNonlinearISAM_print_1505(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearISAM_printStats_1506(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("printStats",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  obj->printStats();
}

void gtsamNonlinearISAM_reorderCounter_1507(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("reorderCounter",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  out[0] = wrap< int >(obj->reorderCounter());
}

void gtsamNonlinearISAM_reorderInterval_1508(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("reorderInterval",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  out[0] = wrap< int >(obj->reorderInterval());
}

void gtsamNonlinearISAM_reorder_relinearize_1509(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("reorder_relinearize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  obj->reorder_relinearize();
}

void gtsamNonlinearISAM_saveGraph_1510(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("saveGraph",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  string s = unwrap< string >(in[1]);
  obj->saveGraph(s);
}

void gtsamNonlinearISAM_update_1511(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearISAM> Shared;
  checkArguments("update",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearISAM>(in[0], "ptr_gtsamNonlinearISAM");
  gtsam::NonlinearFactorGraph& newFactors = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[1], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& initialValues = *unwrap_shared_ptr< gtsam::Values >(in[2], "ptr_gtsamValues");
  obj->update(newFactors,initialValues);
}

void gtsamPriorFactorVector_collectorInsertAndMakeBase_1512(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorVector.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorVector_upcastFromVoid_1513(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorVector>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorVector_constructor_1514(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;

  size_t key = unwrap< size_t >(in[0]);
  Vector prior = unwrap< Vector >(in[1]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorVector(key,prior,noiseModel));
  collector_gtsamPriorFactorVector.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorVector_deconstructor_1515(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("delete_gtsamPriorFactorVector",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorVector::iterator item;
  item = collector_gtsamPriorFactorVector.find(self);
  if(item != collector_gtsamPriorFactorVector.end()) {
    delete self;
    collector_gtsamPriorFactorVector.erase(item);
  }
}

void gtsamPriorFactorVector_active_1516(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorVector_clone_1517(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorVector_dim_1518(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorVector_equals_1519(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorVector_error_1520(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorVector_get_noiseModel_1521(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorVector_keys_1522(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorVector_linearize_1523(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorVector_noiseModel_1524(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorVector_print_1525(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorVector_printKeys_1526(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorVector_prior_1527(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  out[0] = wrap< Vector >(obj->prior());
}

void gtsamPriorFactorVector_size_1528(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorVector_unwhitenedError_1529(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorVector_whitenedError_1530(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorVector_string_serialize_1531(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorVector>(in[0], "ptr_gtsamPriorFactorVector");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorVector_string_deserialize_1532(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorVector> Shared;
  checkArguments("gtsamPriorFactorVector.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorVector());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorVector", false);
}
void gtsamPriorFactorPoint2_collectorInsertAndMakeBase_1533(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorPoint2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorPoint2_upcastFromVoid_1534(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorPoint2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorPoint2_constructor_1535(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Point2& prior = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorPoint2(key,prior,noiseModel));
  collector_gtsamPriorFactorPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorPoint2_deconstructor_1536(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("delete_gtsamPriorFactorPoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorPoint2::iterator item;
  item = collector_gtsamPriorFactorPoint2.find(self);
  if(item != collector_gtsamPriorFactorPoint2.end()) {
    delete self;
    collector_gtsamPriorFactorPoint2.erase(item);
  }
}

void gtsamPriorFactorPoint2_active_1537(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorPoint2_clone_1538(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorPoint2_dim_1539(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorPoint2_equals_1540(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorPoint2_error_1541(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorPoint2_get_noiseModel_1542(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPoint2_keys_1543(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorPoint2_linearize_1544(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorPoint2_noiseModel_1545(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPoint2_print_1546(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorPoint2_printKeys_1547(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorPoint2_prior_1548(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->prior())),"gtsam.Point2", false);
}

void gtsamPriorFactorPoint2_size_1549(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorPoint2_unwhitenedError_1550(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorPoint2_whitenedError_1551(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorPoint2_string_serialize_1552(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint2>(in[0], "ptr_gtsamPriorFactorPoint2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorPoint2_string_deserialize_1553(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint2> Shared;
  checkArguments("gtsamPriorFactorPoint2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorPoint2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorPoint2", false);
}
void gtsamPriorFactorStereoPoint2_collectorInsertAndMakeBase_1554(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorStereoPoint2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorStereoPoint2_upcastFromVoid_1555(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorStereoPoint2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorStereoPoint2_constructor_1556(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::StereoPoint2& prior = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorStereoPoint2(key,prior,noiseModel));
  collector_gtsamPriorFactorStereoPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorStereoPoint2_deconstructor_1557(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("delete_gtsamPriorFactorStereoPoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorStereoPoint2::iterator item;
  item = collector_gtsamPriorFactorStereoPoint2.find(self);
  if(item != collector_gtsamPriorFactorStereoPoint2.end()) {
    delete self;
    collector_gtsamPriorFactorStereoPoint2.erase(item);
  }
}

void gtsamPriorFactorStereoPoint2_active_1558(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorStereoPoint2_clone_1559(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorStereoPoint2_dim_1560(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorStereoPoint2_equals_1561(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorStereoPoint2_error_1562(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorStereoPoint2_get_noiseModel_1563(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorStereoPoint2_keys_1564(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorStereoPoint2_linearize_1565(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorStereoPoint2_noiseModel_1566(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorStereoPoint2_print_1567(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorStereoPoint2_printKeys_1568(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorStereoPoint2_prior_1569(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(obj->prior())),"gtsam.StereoPoint2", false);
}

void gtsamPriorFactorStereoPoint2_size_1570(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorStereoPoint2_unwhitenedError_1571(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorStereoPoint2_whitenedError_1572(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorStereoPoint2_string_serialize_1573(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorStereoPoint2>(in[0], "ptr_gtsamPriorFactorStereoPoint2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorStereoPoint2_string_deserialize_1574(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorStereoPoint2> Shared;
  checkArguments("gtsamPriorFactorStereoPoint2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorStereoPoint2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorStereoPoint2", false);
}
void gtsamPriorFactorPoint3_collectorInsertAndMakeBase_1575(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorPoint3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorPoint3_upcastFromVoid_1576(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorPoint3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorPoint3_constructor_1577(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Point3& prior = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorPoint3(key,prior,noiseModel));
  collector_gtsamPriorFactorPoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorPoint3_deconstructor_1578(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("delete_gtsamPriorFactorPoint3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorPoint3::iterator item;
  item = collector_gtsamPriorFactorPoint3.find(self);
  if(item != collector_gtsamPriorFactorPoint3.end()) {
    delete self;
    collector_gtsamPriorFactorPoint3.erase(item);
  }
}

void gtsamPriorFactorPoint3_active_1579(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorPoint3_clone_1580(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorPoint3_dim_1581(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorPoint3_equals_1582(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorPoint3_error_1583(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorPoint3_get_noiseModel_1584(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPoint3_keys_1585(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorPoint3_linearize_1586(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorPoint3_noiseModel_1587(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPoint3_print_1588(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorPoint3_printKeys_1589(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorPoint3_prior_1590(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->prior())),"gtsam.Point3", false);
}

void gtsamPriorFactorPoint3_size_1591(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorPoint3_unwhitenedError_1592(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorPoint3_whitenedError_1593(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorPoint3_string_serialize_1594(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPoint3>(in[0], "ptr_gtsamPriorFactorPoint3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorPoint3_string_deserialize_1595(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPoint3> Shared;
  checkArguments("gtsamPriorFactorPoint3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorPoint3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorPoint3", false);
}
void gtsamPriorFactorRot2_collectorInsertAndMakeBase_1596(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorRot2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorRot2_upcastFromVoid_1597(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorRot2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorRot2_constructor_1598(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Rot2& prior = *unwrap_shared_ptr< gtsam::Rot2 >(in[1], "ptr_gtsamRot2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorRot2(key,prior,noiseModel));
  collector_gtsamPriorFactorRot2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorRot2_deconstructor_1599(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("delete_gtsamPriorFactorRot2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorRot2::iterator item;
  item = collector_gtsamPriorFactorRot2.find(self);
  if(item != collector_gtsamPriorFactorRot2.end()) {
    delete self;
    collector_gtsamPriorFactorRot2.erase(item);
  }
}

void gtsamPriorFactorRot2_active_1600(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorRot2_clone_1601(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorRot2_dim_1602(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorRot2_equals_1603(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorRot2_error_1604(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorRot2_get_noiseModel_1605(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorRot2_keys_1606(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorRot2_linearize_1607(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorRot2_noiseModel_1608(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorRot2_print_1609(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorRot2_printKeys_1610(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorRot2_prior_1611(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->prior())),"gtsam.Rot2", false);
}

void gtsamPriorFactorRot2_size_1612(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorRot2_unwhitenedError_1613(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorRot2_whitenedError_1614(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorRot2_string_serialize_1615(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot2>(in[0], "ptr_gtsamPriorFactorRot2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorRot2_string_deserialize_1616(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot2> Shared;
  checkArguments("gtsamPriorFactorRot2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorRot2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorRot2", false);
}
void gtsamPriorFactorRot3_collectorInsertAndMakeBase_1617(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorRot3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorRot3_upcastFromVoid_1618(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorRot3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorRot3_constructor_1619(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Rot3& prior = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorRot3(key,prior,noiseModel));
  collector_gtsamPriorFactorRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorRot3_deconstructor_1620(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("delete_gtsamPriorFactorRot3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorRot3::iterator item;
  item = collector_gtsamPriorFactorRot3.find(self);
  if(item != collector_gtsamPriorFactorRot3.end()) {
    delete self;
    collector_gtsamPriorFactorRot3.erase(item);
  }
}

void gtsamPriorFactorRot3_active_1621(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorRot3_clone_1622(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorRot3_dim_1623(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorRot3_equals_1624(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorRot3_error_1625(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorRot3_get_noiseModel_1626(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorRot3_keys_1627(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorRot3_linearize_1628(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorRot3_noiseModel_1629(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorRot3_print_1630(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorRot3_printKeys_1631(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorRot3_prior_1632(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->prior())),"gtsam.Rot3", false);
}

void gtsamPriorFactorRot3_size_1633(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorRot3_unwhitenedError_1634(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorRot3_whitenedError_1635(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorRot3_string_serialize_1636(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorRot3>(in[0], "ptr_gtsamPriorFactorRot3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorRot3_string_deserialize_1637(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorRot3> Shared;
  checkArguments("gtsamPriorFactorRot3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorRot3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorRot3", false);
}
void gtsamPriorFactorPose2_collectorInsertAndMakeBase_1638(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorPose2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorPose2_upcastFromVoid_1639(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorPose2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorPose2_constructor_1640(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Pose2& prior = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorPose2(key,prior,noiseModel));
  collector_gtsamPriorFactorPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorPose2_deconstructor_1641(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("delete_gtsamPriorFactorPose2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorPose2::iterator item;
  item = collector_gtsamPriorFactorPose2.find(self);
  if(item != collector_gtsamPriorFactorPose2.end()) {
    delete self;
    collector_gtsamPriorFactorPose2.erase(item);
  }
}

void gtsamPriorFactorPose2_active_1642(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorPose2_clone_1643(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorPose2_dim_1644(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorPose2_equals_1645(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorPose2_error_1646(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorPose2_get_noiseModel_1647(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPose2_keys_1648(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorPose2_linearize_1649(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorPose2_noiseModel_1650(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPose2_print_1651(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorPose2_printKeys_1652(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorPose2_prior_1653(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->prior())),"gtsam.Pose2", false);
}

void gtsamPriorFactorPose2_size_1654(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorPose2_unwhitenedError_1655(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorPose2_whitenedError_1656(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorPose2_string_serialize_1657(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose2>(in[0], "ptr_gtsamPriorFactorPose2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorPose2_string_deserialize_1658(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose2> Shared;
  checkArguments("gtsamPriorFactorPose2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorPose2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorPose2", false);
}
void gtsamPriorFactorPose3_collectorInsertAndMakeBase_1659(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorPose3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorPose3_upcastFromVoid_1660(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorPose3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorPose3_constructor_1661(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Pose3& prior = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorPose3(key,prior,noiseModel));
  collector_gtsamPriorFactorPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorPose3_deconstructor_1662(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("delete_gtsamPriorFactorPose3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorPose3::iterator item;
  item = collector_gtsamPriorFactorPose3.find(self);
  if(item != collector_gtsamPriorFactorPose3.end()) {
    delete self;
    collector_gtsamPriorFactorPose3.erase(item);
  }
}

void gtsamPriorFactorPose3_active_1663(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorPose3_clone_1664(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorPose3_dim_1665(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorPose3_equals_1666(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorPose3_error_1667(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorPose3_get_noiseModel_1668(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPose3_keys_1669(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorPose3_linearize_1670(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorPose3_noiseModel_1671(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorPose3_print_1672(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorPose3_printKeys_1673(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorPose3_prior_1674(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->prior())),"gtsam.Pose3", false);
}

void gtsamPriorFactorPose3_size_1675(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorPose3_unwhitenedError_1676(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorPose3_whitenedError_1677(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorPose3_string_serialize_1678(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorPose3>(in[0], "ptr_gtsamPriorFactorPose3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorPose3_string_deserialize_1679(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorPose3> Shared;
  checkArguments("gtsamPriorFactorPose3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorPose3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorPose3", false);
}
void gtsamPriorFactorCal3_S2_collectorInsertAndMakeBase_1680(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorCal3_S2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorCal3_S2_upcastFromVoid_1681(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorCal3_S2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorCal3_S2_constructor_1682(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Cal3_S2& prior = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorCal3_S2(key,prior,noiseModel));
  collector_gtsamPriorFactorCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorCal3_S2_deconstructor_1683(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("delete_gtsamPriorFactorCal3_S2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorCal3_S2::iterator item;
  item = collector_gtsamPriorFactorCal3_S2.find(self);
  if(item != collector_gtsamPriorFactorCal3_S2.end()) {
    delete self;
    collector_gtsamPriorFactorCal3_S2.erase(item);
  }
}

void gtsamPriorFactorCal3_S2_active_1684(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorCal3_S2_clone_1685(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorCal3_S2_dim_1686(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorCal3_S2_equals_1687(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorCal3_S2_error_1688(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorCal3_S2_get_noiseModel_1689(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorCal3_S2_keys_1690(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorCal3_S2_linearize_1691(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorCal3_S2_noiseModel_1692(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorCal3_S2_print_1693(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorCal3_S2_printKeys_1694(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorCal3_S2_prior_1695(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> SharedCal3_S2;
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  out[0] = wrap_shared_ptr(SharedCal3_S2(new gtsam::Cal3_S2(obj->prior())),"gtsam.Cal3_S2", false);
}

void gtsamPriorFactorCal3_S2_size_1696(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorCal3_S2_unwhitenedError_1697(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorCal3_S2_whitenedError_1698(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorCal3_S2_string_serialize_1699(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCal3_S2>(in[0], "ptr_gtsamPriorFactorCal3_S2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorCal3_S2_string_deserialize_1700(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCal3_S2> Shared;
  checkArguments("gtsamPriorFactorCal3_S2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorCal3_S2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorCal3_S2", false);
}
void gtsamPriorFactorCalibratedCamera_collectorInsertAndMakeBase_1701(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorCalibratedCamera.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorCalibratedCamera_upcastFromVoid_1702(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorCalibratedCamera>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorCalibratedCamera_constructor_1703(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::CalibratedCamera& prior = *unwrap_shared_ptr< gtsam::CalibratedCamera >(in[1], "ptr_gtsamCalibratedCamera");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorCalibratedCamera(key,prior,noiseModel));
  collector_gtsamPriorFactorCalibratedCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorCalibratedCamera_deconstructor_1704(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("delete_gtsamPriorFactorCalibratedCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorCalibratedCamera::iterator item;
  item = collector_gtsamPriorFactorCalibratedCamera.find(self);
  if(item != collector_gtsamPriorFactorCalibratedCamera.end()) {
    delete self;
    collector_gtsamPriorFactorCalibratedCamera.erase(item);
  }
}

void gtsamPriorFactorCalibratedCamera_active_1705(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorCalibratedCamera_clone_1706(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorCalibratedCamera_dim_1707(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorCalibratedCamera_equals_1708(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorCalibratedCamera_error_1709(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorCalibratedCamera_get_noiseModel_1710(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorCalibratedCamera_keys_1711(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorCalibratedCamera_linearize_1712(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorCalibratedCamera_noiseModel_1713(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorCalibratedCamera_print_1714(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorCalibratedCamera_printKeys_1715(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorCalibratedCamera_prior_1716(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CalibratedCamera> SharedCalibratedCamera;
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(SharedCalibratedCamera(new gtsam::CalibratedCamera(obj->prior())),"gtsam.CalibratedCamera", false);
}

void gtsamPriorFactorCalibratedCamera_size_1717(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorCalibratedCamera_unwhitenedError_1718(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorCalibratedCamera_whitenedError_1719(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorCalibratedCamera_string_serialize_1720(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorCalibratedCamera>(in[0], "ptr_gtsamPriorFactorCalibratedCamera");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorCalibratedCamera_string_deserialize_1721(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorCalibratedCamera> Shared;
  checkArguments("gtsamPriorFactorCalibratedCamera.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorCalibratedCamera());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorCalibratedCamera", false);
}
void gtsamPriorFactorSimpleCamera_collectorInsertAndMakeBase_1722(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorSimpleCamera.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorSimpleCamera_upcastFromVoid_1723(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorSimpleCamera>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorSimpleCamera_constructor_1724(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::SimpleCamera& prior = *unwrap_shared_ptr< gtsam::SimpleCamera >(in[1], "ptr_gtsamSimpleCamera");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorSimpleCamera(key,prior,noiseModel));
  collector_gtsamPriorFactorSimpleCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorSimpleCamera_deconstructor_1725(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("delete_gtsamPriorFactorSimpleCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorSimpleCamera::iterator item;
  item = collector_gtsamPriorFactorSimpleCamera.find(self);
  if(item != collector_gtsamPriorFactorSimpleCamera.end()) {
    delete self;
    collector_gtsamPriorFactorSimpleCamera.erase(item);
  }
}

void gtsamPriorFactorSimpleCamera_active_1726(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorSimpleCamera_clone_1727(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorSimpleCamera_dim_1728(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorSimpleCamera_equals_1729(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorSimpleCamera_error_1730(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorSimpleCamera_get_noiseModel_1731(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorSimpleCamera_keys_1732(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorSimpleCamera_linearize_1733(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorSimpleCamera_noiseModel_1734(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorSimpleCamera_print_1735(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorSimpleCamera_printKeys_1736(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorSimpleCamera_prior_1737(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SimpleCamera> SharedSimpleCamera;
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  out[0] = wrap_shared_ptr(obj->prior().clone(),"gtsam.SimpleCamera", true);
}

void gtsamPriorFactorSimpleCamera_size_1738(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorSimpleCamera_unwhitenedError_1739(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorSimpleCamera_whitenedError_1740(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorSimpleCamera_string_serialize_1741(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorSimpleCamera>(in[0], "ptr_gtsamPriorFactorSimpleCamera");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorSimpleCamera_string_deserialize_1742(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorSimpleCamera> Shared;
  checkArguments("gtsamPriorFactorSimpleCamera.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorSimpleCamera());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorSimpleCamera", false);
}
void gtsamPriorFactorConstantBias_collectorInsertAndMakeBase_1743(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPriorFactorConstantBias.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPriorFactorConstantBias_upcastFromVoid_1744(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PriorFactorConstantBias>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPriorFactorConstantBias_constructor_1745(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::imuBias::ConstantBias& prior = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PriorFactorConstantBias(key,prior,noiseModel));
  collector_gtsamPriorFactorConstantBias.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPriorFactorConstantBias_deconstructor_1746(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("delete_gtsamPriorFactorConstantBias",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPriorFactorConstantBias::iterator item;
  item = collector_gtsamPriorFactorConstantBias.find(self);
  if(item != collector_gtsamPriorFactorConstantBias.end()) {
    delete self;
    collector_gtsamPriorFactorConstantBias.erase(item);
  }
}

void gtsamPriorFactorConstantBias_active_1747(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPriorFactorConstantBias_clone_1748(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPriorFactorConstantBias_dim_1749(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPriorFactorConstantBias_equals_1750(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPriorFactorConstantBias_error_1751(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPriorFactorConstantBias_get_noiseModel_1752(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorConstantBias_keys_1753(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPriorFactorConstantBias_linearize_1754(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPriorFactorConstantBias_noiseModel_1755(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPriorFactorConstantBias_print_1756(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPriorFactorConstantBias_printKeys_1757(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPriorFactorConstantBias_prior_1758(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("prior",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(obj->prior())),"gtsam.imuBias.ConstantBias", false);
}

void gtsamPriorFactorConstantBias_size_1759(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPriorFactorConstantBias_unwhitenedError_1760(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPriorFactorConstantBias_whitenedError_1761(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPriorFactorConstantBias_string_serialize_1762(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PriorFactorConstantBias>(in[0], "ptr_gtsamPriorFactorConstantBias");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPriorFactorConstantBias_string_deserialize_1763(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PriorFactorConstantBias> Shared;
  checkArguments("gtsamPriorFactorConstantBias.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PriorFactorConstantBias());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PriorFactorConstantBias", false);
}
void gtsamBetweenFactorPoint2_collectorInsertAndMakeBase_1764(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBetweenFactorPoint2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBetweenFactorPoint2_upcastFromVoid_1765(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BetweenFactorPoint2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBetweenFactorPoint2_constructor_1766(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::Point2& relativePose = *unwrap_shared_ptr< gtsam::Point2 >(in[2], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BetweenFactorPoint2(key1,key2,relativePose,noiseModel));
  collector_gtsamBetweenFactorPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBetweenFactorPoint2_deconstructor_1767(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("delete_gtsamBetweenFactorPoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBetweenFactorPoint2::iterator item;
  item = collector_gtsamBetweenFactorPoint2.find(self);
  if(item != collector_gtsamBetweenFactorPoint2.end()) {
    delete self;
    collector_gtsamBetweenFactorPoint2.erase(item);
  }
}

void gtsamBetweenFactorPoint2_active_1768(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBetweenFactorPoint2_clone_1769(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBetweenFactorPoint2_dim_1770(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBetweenFactorPoint2_equals_1771(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBetweenFactorPoint2_error_1772(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBetweenFactorPoint2_get_noiseModel_1773(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPoint2_keys_1774(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBetweenFactorPoint2_linearize_1775(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBetweenFactorPoint2_measured_1776(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->measured())),"gtsam.Point2", false);
}

void gtsamBetweenFactorPoint2_noiseModel_1777(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPoint2_print_1778(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBetweenFactorPoint2_printKeys_1779(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBetweenFactorPoint2_size_1780(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBetweenFactorPoint2_unwhitenedError_1781(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBetweenFactorPoint2_whitenedError_1782(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBetweenFactorPoint2_string_serialize_1783(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint2>(in[0], "ptr_gtsamBetweenFactorPoint2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBetweenFactorPoint2_string_deserialize_1784(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint2> Shared;
  checkArguments("gtsamBetweenFactorPoint2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BetweenFactorPoint2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BetweenFactorPoint2", false);
}
void gtsamBetweenFactorPoint3_collectorInsertAndMakeBase_1785(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBetweenFactorPoint3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBetweenFactorPoint3_upcastFromVoid_1786(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BetweenFactorPoint3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBetweenFactorPoint3_constructor_1787(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::Point3& relativePose = *unwrap_shared_ptr< gtsam::Point3 >(in[2], "ptr_gtsamPoint3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BetweenFactorPoint3(key1,key2,relativePose,noiseModel));
  collector_gtsamBetweenFactorPoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBetweenFactorPoint3_deconstructor_1788(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("delete_gtsamBetweenFactorPoint3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBetweenFactorPoint3::iterator item;
  item = collector_gtsamBetweenFactorPoint3.find(self);
  if(item != collector_gtsamBetweenFactorPoint3.end()) {
    delete self;
    collector_gtsamBetweenFactorPoint3.erase(item);
  }
}

void gtsamBetweenFactorPoint3_active_1789(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBetweenFactorPoint3_clone_1790(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBetweenFactorPoint3_dim_1791(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBetweenFactorPoint3_equals_1792(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBetweenFactorPoint3_error_1793(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBetweenFactorPoint3_get_noiseModel_1794(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPoint3_keys_1795(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBetweenFactorPoint3_linearize_1796(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBetweenFactorPoint3_measured_1797(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->measured())),"gtsam.Point3", false);
}

void gtsamBetweenFactorPoint3_noiseModel_1798(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPoint3_print_1799(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBetweenFactorPoint3_printKeys_1800(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBetweenFactorPoint3_size_1801(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBetweenFactorPoint3_unwhitenedError_1802(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBetweenFactorPoint3_whitenedError_1803(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBetweenFactorPoint3_string_serialize_1804(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPoint3>(in[0], "ptr_gtsamBetweenFactorPoint3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBetweenFactorPoint3_string_deserialize_1805(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPoint3> Shared;
  checkArguments("gtsamBetweenFactorPoint3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BetweenFactorPoint3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BetweenFactorPoint3", false);
}
void gtsamBetweenFactorRot2_collectorInsertAndMakeBase_1806(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBetweenFactorRot2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBetweenFactorRot2_upcastFromVoid_1807(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BetweenFactorRot2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBetweenFactorRot2_constructor_1808(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::Rot2& relativePose = *unwrap_shared_ptr< gtsam::Rot2 >(in[2], "ptr_gtsamRot2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BetweenFactorRot2(key1,key2,relativePose,noiseModel));
  collector_gtsamBetweenFactorRot2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBetweenFactorRot2_deconstructor_1809(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("delete_gtsamBetweenFactorRot2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBetweenFactorRot2::iterator item;
  item = collector_gtsamBetweenFactorRot2.find(self);
  if(item != collector_gtsamBetweenFactorRot2.end()) {
    delete self;
    collector_gtsamBetweenFactorRot2.erase(item);
  }
}

void gtsamBetweenFactorRot2_active_1810(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBetweenFactorRot2_clone_1811(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBetweenFactorRot2_dim_1812(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBetweenFactorRot2_equals_1813(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBetweenFactorRot2_error_1814(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBetweenFactorRot2_get_noiseModel_1815(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorRot2_keys_1816(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBetweenFactorRot2_linearize_1817(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBetweenFactorRot2_measured_1818(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot2> SharedRot2;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  out[0] = wrap_shared_ptr(SharedRot2(new gtsam::Rot2(obj->measured())),"gtsam.Rot2", false);
}

void gtsamBetweenFactorRot2_noiseModel_1819(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorRot2_print_1820(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBetweenFactorRot2_printKeys_1821(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBetweenFactorRot2_size_1822(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBetweenFactorRot2_unwhitenedError_1823(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBetweenFactorRot2_whitenedError_1824(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBetweenFactorRot2_string_serialize_1825(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot2>(in[0], "ptr_gtsamBetweenFactorRot2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBetweenFactorRot2_string_deserialize_1826(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot2> Shared;
  checkArguments("gtsamBetweenFactorRot2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BetweenFactorRot2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BetweenFactorRot2", false);
}
void gtsamBetweenFactorRot3_collectorInsertAndMakeBase_1827(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBetweenFactorRot3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBetweenFactorRot3_upcastFromVoid_1828(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BetweenFactorRot3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBetweenFactorRot3_constructor_1829(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::Rot3& relativePose = *unwrap_shared_ptr< gtsam::Rot3 >(in[2], "ptr_gtsamRot3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BetweenFactorRot3(key1,key2,relativePose,noiseModel));
  collector_gtsamBetweenFactorRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBetweenFactorRot3_deconstructor_1830(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("delete_gtsamBetweenFactorRot3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBetweenFactorRot3::iterator item;
  item = collector_gtsamBetweenFactorRot3.find(self);
  if(item != collector_gtsamBetweenFactorRot3.end()) {
    delete self;
    collector_gtsamBetweenFactorRot3.erase(item);
  }
}

void gtsamBetweenFactorRot3_active_1831(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBetweenFactorRot3_clone_1832(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBetweenFactorRot3_dim_1833(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBetweenFactorRot3_equals_1834(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBetweenFactorRot3_error_1835(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBetweenFactorRot3_get_noiseModel_1836(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorRot3_keys_1837(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBetweenFactorRot3_linearize_1838(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBetweenFactorRot3_measured_1839(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->measured())),"gtsam.Rot3", false);
}

void gtsamBetweenFactorRot3_noiseModel_1840(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorRot3_print_1841(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBetweenFactorRot3_printKeys_1842(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBetweenFactorRot3_size_1843(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBetweenFactorRot3_unwhitenedError_1844(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBetweenFactorRot3_whitenedError_1845(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBetweenFactorRot3_string_serialize_1846(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorRot3>(in[0], "ptr_gtsamBetweenFactorRot3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBetweenFactorRot3_string_deserialize_1847(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorRot3> Shared;
  checkArguments("gtsamBetweenFactorRot3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BetweenFactorRot3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BetweenFactorRot3", false);
}
void gtsamBetweenFactorPose2_collectorInsertAndMakeBase_1848(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBetweenFactorPose2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBetweenFactorPose2_upcastFromVoid_1849(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BetweenFactorPose2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBetweenFactorPose2_constructor_1850(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::Pose2& relativePose = *unwrap_shared_ptr< gtsam::Pose2 >(in[2], "ptr_gtsamPose2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BetweenFactorPose2(key1,key2,relativePose,noiseModel));
  collector_gtsamBetweenFactorPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBetweenFactorPose2_deconstructor_1851(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("delete_gtsamBetweenFactorPose2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBetweenFactorPose2::iterator item;
  item = collector_gtsamBetweenFactorPose2.find(self);
  if(item != collector_gtsamBetweenFactorPose2.end()) {
    delete self;
    collector_gtsamBetweenFactorPose2.erase(item);
  }
}

void gtsamBetweenFactorPose2_active_1852(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBetweenFactorPose2_clone_1853(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBetweenFactorPose2_dim_1854(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBetweenFactorPose2_equals_1855(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBetweenFactorPose2_error_1856(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBetweenFactorPose2_get_noiseModel_1857(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPose2_keys_1858(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBetweenFactorPose2_linearize_1859(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBetweenFactorPose2_measured_1860(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose2> SharedPose2;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  out[0] = wrap_shared_ptr(SharedPose2(new gtsam::Pose2(obj->measured())),"gtsam.Pose2", false);
}

void gtsamBetweenFactorPose2_noiseModel_1861(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPose2_print_1862(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBetweenFactorPose2_printKeys_1863(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBetweenFactorPose2_size_1864(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBetweenFactorPose2_unwhitenedError_1865(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBetweenFactorPose2_whitenedError_1866(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBetweenFactorPose2_string_serialize_1867(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose2>(in[0], "ptr_gtsamBetweenFactorPose2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBetweenFactorPose2_string_deserialize_1868(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose2> Shared;
  checkArguments("gtsamBetweenFactorPose2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BetweenFactorPose2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BetweenFactorPose2", false);
}
void gtsamBetweenFactorPose3_collectorInsertAndMakeBase_1869(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBetweenFactorPose3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBetweenFactorPose3_upcastFromVoid_1870(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BetweenFactorPose3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBetweenFactorPose3_constructor_1871(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::Pose3& relativePose = *unwrap_shared_ptr< gtsam::Pose3 >(in[2], "ptr_gtsamPose3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BetweenFactorPose3(key1,key2,relativePose,noiseModel));
  collector_gtsamBetweenFactorPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBetweenFactorPose3_deconstructor_1872(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("delete_gtsamBetweenFactorPose3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBetweenFactorPose3::iterator item;
  item = collector_gtsamBetweenFactorPose3.find(self);
  if(item != collector_gtsamBetweenFactorPose3.end()) {
    delete self;
    collector_gtsamBetweenFactorPose3.erase(item);
  }
}

void gtsamBetweenFactorPose3_active_1873(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBetweenFactorPose3_clone_1874(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBetweenFactorPose3_dim_1875(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBetweenFactorPose3_equals_1876(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBetweenFactorPose3_error_1877(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBetweenFactorPose3_get_noiseModel_1878(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPose3_keys_1879(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBetweenFactorPose3_linearize_1880(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBetweenFactorPose3_measured_1881(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->measured())),"gtsam.Pose3", false);
}

void gtsamBetweenFactorPose3_noiseModel_1882(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorPose3_print_1883(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBetweenFactorPose3_printKeys_1884(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBetweenFactorPose3_size_1885(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBetweenFactorPose3_unwhitenedError_1886(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBetweenFactorPose3_whitenedError_1887(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBetweenFactorPose3_string_serialize_1888(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorPose3>(in[0], "ptr_gtsamBetweenFactorPose3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBetweenFactorPose3_string_deserialize_1889(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorPose3> Shared;
  checkArguments("gtsamBetweenFactorPose3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BetweenFactorPose3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BetweenFactorPose3", false);
}
void gtsamBetweenFactorConstantBias_collectorInsertAndMakeBase_1890(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBetweenFactorConstantBias.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBetweenFactorConstantBias_upcastFromVoid_1891(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BetweenFactorConstantBias>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBetweenFactorConstantBias_constructor_1892(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::imuBias::ConstantBias& relativePose = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[2], "ptr_gtsamimuBiasConstantBias");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BetweenFactorConstantBias(key1,key2,relativePose,noiseModel));
  collector_gtsamBetweenFactorConstantBias.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBetweenFactorConstantBias_deconstructor_1893(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("delete_gtsamBetweenFactorConstantBias",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBetweenFactorConstantBias::iterator item;
  item = collector_gtsamBetweenFactorConstantBias.find(self);
  if(item != collector_gtsamBetweenFactorConstantBias.end()) {
    delete self;
    collector_gtsamBetweenFactorConstantBias.erase(item);
  }
}

void gtsamBetweenFactorConstantBias_active_1894(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBetweenFactorConstantBias_clone_1895(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBetweenFactorConstantBias_dim_1896(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBetweenFactorConstantBias_equals_1897(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBetweenFactorConstantBias_error_1898(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBetweenFactorConstantBias_get_noiseModel_1899(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorConstantBias_keys_1900(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBetweenFactorConstantBias_linearize_1901(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBetweenFactorConstantBias_measured_1902(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(obj->measured())),"gtsam.imuBias.ConstantBias", false);
}

void gtsamBetweenFactorConstantBias_noiseModel_1903(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBetweenFactorConstantBias_print_1904(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBetweenFactorConstantBias_printKeys_1905(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBetweenFactorConstantBias_size_1906(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBetweenFactorConstantBias_unwhitenedError_1907(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBetweenFactorConstantBias_whitenedError_1908(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBetweenFactorConstantBias_string_serialize_1909(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BetweenFactorConstantBias>(in[0], "ptr_gtsamBetweenFactorConstantBias");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBetweenFactorConstantBias_string_deserialize_1910(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BetweenFactorConstantBias> Shared;
  checkArguments("gtsamBetweenFactorConstantBias.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BetweenFactorConstantBias());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BetweenFactorConstantBias", false);
}
void gtsamNonlinearEqualityPoint2_collectorInsertAndMakeBase_1911(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityPoint2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPoint2_upcastFromVoid_1912(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityPoint2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityPoint2_constructor_1913(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Point2& feasible = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  Shared *self = new Shared(new gtsam::NonlinearEqualityPoint2(j,feasible));
  collector_gtsamNonlinearEqualityPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPoint2_constructor_1914(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Point2& feasible = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityPoint2(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPoint2_deconstructor_1915(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("delete_gtsamNonlinearEqualityPoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityPoint2::iterator item;
  item = collector_gtsamNonlinearEqualityPoint2.find(self);
  if(item != collector_gtsamNonlinearEqualityPoint2.end()) {
    delete self;
    collector_gtsamNonlinearEqualityPoint2.erase(item);
  }
}

void gtsamNonlinearEqualityPoint2_active_1916(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityPoint2_clone_1917(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityPoint2_dim_1918(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityPoint2_equals_1919(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityPoint2_error_1920(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityPoint2_get_noiseModel_1921(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPoint2_keys_1922(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityPoint2_linearize_1923(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityPoint2_noiseModel_1924(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPoint2_print_1925(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityPoint2_printKeys_1926(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityPoint2_size_1927(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityPoint2_unwhitenedError_1928(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityPoint2_whitenedError_1929(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityPoint2_string_serialize_1930(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint2>(in[0], "ptr_gtsamNonlinearEqualityPoint2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityPoint2_string_deserialize_1931(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint2> Shared;
  checkArguments("gtsamNonlinearEqualityPoint2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityPoint2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityPoint2", false);
}
void gtsamNonlinearEqualityStereoPoint2_collectorInsertAndMakeBase_1932(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityStereoPoint2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityStereoPoint2_upcastFromVoid_1933(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityStereoPoint2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityStereoPoint2_constructor_1934(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::StereoPoint2& feasible = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  Shared *self = new Shared(new gtsam::NonlinearEqualityStereoPoint2(j,feasible));
  collector_gtsamNonlinearEqualityStereoPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityStereoPoint2_constructor_1935(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::StereoPoint2& feasible = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[1], "ptr_gtsamStereoPoint2");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityStereoPoint2(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityStereoPoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityStereoPoint2_deconstructor_1936(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("delete_gtsamNonlinearEqualityStereoPoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityStereoPoint2::iterator item;
  item = collector_gtsamNonlinearEqualityStereoPoint2.find(self);
  if(item != collector_gtsamNonlinearEqualityStereoPoint2.end()) {
    delete self;
    collector_gtsamNonlinearEqualityStereoPoint2.erase(item);
  }
}

void gtsamNonlinearEqualityStereoPoint2_active_1937(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityStereoPoint2_clone_1938(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityStereoPoint2_dim_1939(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityStereoPoint2_equals_1940(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityStereoPoint2_error_1941(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityStereoPoint2_get_noiseModel_1942(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityStereoPoint2_keys_1943(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityStereoPoint2_linearize_1944(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityStereoPoint2_noiseModel_1945(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityStereoPoint2_print_1946(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityStereoPoint2_printKeys_1947(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityStereoPoint2_size_1948(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityStereoPoint2_unwhitenedError_1949(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityStereoPoint2_whitenedError_1950(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityStereoPoint2_string_serialize_1951(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityStereoPoint2>(in[0], "ptr_gtsamNonlinearEqualityStereoPoint2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityStereoPoint2_string_deserialize_1952(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityStereoPoint2> Shared;
  checkArguments("gtsamNonlinearEqualityStereoPoint2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityStereoPoint2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityStereoPoint2", false);
}
void gtsamNonlinearEqualityPoint3_collectorInsertAndMakeBase_1953(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityPoint3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPoint3_upcastFromVoid_1954(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityPoint3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityPoint3_constructor_1955(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Point3& feasible = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  Shared *self = new Shared(new gtsam::NonlinearEqualityPoint3(j,feasible));
  collector_gtsamNonlinearEqualityPoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPoint3_constructor_1956(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Point3& feasible = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityPoint3(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityPoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPoint3_deconstructor_1957(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("delete_gtsamNonlinearEqualityPoint3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityPoint3::iterator item;
  item = collector_gtsamNonlinearEqualityPoint3.find(self);
  if(item != collector_gtsamNonlinearEqualityPoint3.end()) {
    delete self;
    collector_gtsamNonlinearEqualityPoint3.erase(item);
  }
}

void gtsamNonlinearEqualityPoint3_active_1958(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityPoint3_clone_1959(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityPoint3_dim_1960(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityPoint3_equals_1961(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityPoint3_error_1962(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityPoint3_get_noiseModel_1963(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPoint3_keys_1964(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityPoint3_linearize_1965(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityPoint3_noiseModel_1966(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPoint3_print_1967(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityPoint3_printKeys_1968(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityPoint3_size_1969(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityPoint3_unwhitenedError_1970(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityPoint3_whitenedError_1971(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityPoint3_string_serialize_1972(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPoint3>(in[0], "ptr_gtsamNonlinearEqualityPoint3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityPoint3_string_deserialize_1973(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPoint3> Shared;
  checkArguments("gtsamNonlinearEqualityPoint3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityPoint3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityPoint3", false);
}
void gtsamNonlinearEqualityRot2_collectorInsertAndMakeBase_1974(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityRot2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityRot2_upcastFromVoid_1975(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityRot2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityRot2_constructor_1976(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Rot2& feasible = *unwrap_shared_ptr< gtsam::Rot2 >(in[1], "ptr_gtsamRot2");
  Shared *self = new Shared(new gtsam::NonlinearEqualityRot2(j,feasible));
  collector_gtsamNonlinearEqualityRot2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityRot2_constructor_1977(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Rot2& feasible = *unwrap_shared_ptr< gtsam::Rot2 >(in[1], "ptr_gtsamRot2");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityRot2(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityRot2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityRot2_deconstructor_1978(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("delete_gtsamNonlinearEqualityRot2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityRot2::iterator item;
  item = collector_gtsamNonlinearEqualityRot2.find(self);
  if(item != collector_gtsamNonlinearEqualityRot2.end()) {
    delete self;
    collector_gtsamNonlinearEqualityRot2.erase(item);
  }
}

void gtsamNonlinearEqualityRot2_active_1979(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityRot2_clone_1980(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityRot2_dim_1981(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityRot2_equals_1982(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityRot2_error_1983(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityRot2_get_noiseModel_1984(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityRot2_keys_1985(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityRot2_linearize_1986(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityRot2_noiseModel_1987(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityRot2_print_1988(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityRot2_printKeys_1989(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityRot2_size_1990(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityRot2_unwhitenedError_1991(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityRot2_whitenedError_1992(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityRot2_string_serialize_1993(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot2>(in[0], "ptr_gtsamNonlinearEqualityRot2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityRot2_string_deserialize_1994(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot2> Shared;
  checkArguments("gtsamNonlinearEqualityRot2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityRot2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityRot2", false);
}
void gtsamNonlinearEqualityRot3_collectorInsertAndMakeBase_1995(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityRot3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityRot3_upcastFromVoid_1996(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityRot3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityRot3_constructor_1997(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Rot3& feasible = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  Shared *self = new Shared(new gtsam::NonlinearEqualityRot3(j,feasible));
  collector_gtsamNonlinearEqualityRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityRot3_constructor_1998(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Rot3& feasible = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityRot3(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityRot3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityRot3_deconstructor_1999(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("delete_gtsamNonlinearEqualityRot3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityRot3::iterator item;
  item = collector_gtsamNonlinearEqualityRot3.find(self);
  if(item != collector_gtsamNonlinearEqualityRot3.end()) {
    delete self;
    collector_gtsamNonlinearEqualityRot3.erase(item);
  }
}

void gtsamNonlinearEqualityRot3_active_2000(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityRot3_clone_2001(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityRot3_dim_2002(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityRot3_equals_2003(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityRot3_error_2004(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityRot3_get_noiseModel_2005(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityRot3_keys_2006(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityRot3_linearize_2007(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityRot3_noiseModel_2008(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityRot3_print_2009(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityRot3_printKeys_2010(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityRot3_size_2011(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityRot3_unwhitenedError_2012(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityRot3_whitenedError_2013(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityRot3_string_serialize_2014(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityRot3>(in[0], "ptr_gtsamNonlinearEqualityRot3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityRot3_string_deserialize_2015(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityRot3> Shared;
  checkArguments("gtsamNonlinearEqualityRot3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityRot3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityRot3", false);
}
void gtsamNonlinearEqualityPose2_collectorInsertAndMakeBase_2016(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityPose2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPose2_upcastFromVoid_2017(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityPose2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityPose2_constructor_2018(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Pose2& feasible = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  Shared *self = new Shared(new gtsam::NonlinearEqualityPose2(j,feasible));
  collector_gtsamNonlinearEqualityPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPose2_constructor_2019(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Pose2& feasible = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityPose2(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPose2_deconstructor_2020(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("delete_gtsamNonlinearEqualityPose2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityPose2::iterator item;
  item = collector_gtsamNonlinearEqualityPose2.find(self);
  if(item != collector_gtsamNonlinearEqualityPose2.end()) {
    delete self;
    collector_gtsamNonlinearEqualityPose2.erase(item);
  }
}

void gtsamNonlinearEqualityPose2_active_2021(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityPose2_clone_2022(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityPose2_dim_2023(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityPose2_equals_2024(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityPose2_error_2025(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityPose2_get_noiseModel_2026(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPose2_keys_2027(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityPose2_linearize_2028(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityPose2_noiseModel_2029(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPose2_print_2030(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityPose2_printKeys_2031(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityPose2_size_2032(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityPose2_unwhitenedError_2033(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityPose2_whitenedError_2034(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityPose2_string_serialize_2035(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose2>(in[0], "ptr_gtsamNonlinearEqualityPose2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityPose2_string_deserialize_2036(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose2> Shared;
  checkArguments("gtsamNonlinearEqualityPose2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityPose2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityPose2", false);
}
void gtsamNonlinearEqualityPose3_collectorInsertAndMakeBase_2037(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityPose3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPose3_upcastFromVoid_2038(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityPose3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityPose3_constructor_2039(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Pose3& feasible = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::NonlinearEqualityPose3(j,feasible));
  collector_gtsamNonlinearEqualityPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPose3_constructor_2040(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Pose3& feasible = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityPose3(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityPose3_deconstructor_2041(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("delete_gtsamNonlinearEqualityPose3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityPose3::iterator item;
  item = collector_gtsamNonlinearEqualityPose3.find(self);
  if(item != collector_gtsamNonlinearEqualityPose3.end()) {
    delete self;
    collector_gtsamNonlinearEqualityPose3.erase(item);
  }
}

void gtsamNonlinearEqualityPose3_active_2042(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityPose3_clone_2043(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityPose3_dim_2044(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityPose3_equals_2045(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityPose3_error_2046(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityPose3_get_noiseModel_2047(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPose3_keys_2048(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityPose3_linearize_2049(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityPose3_noiseModel_2050(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityPose3_print_2051(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityPose3_printKeys_2052(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityPose3_size_2053(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityPose3_unwhitenedError_2054(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityPose3_whitenedError_2055(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityPose3_string_serialize_2056(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityPose3>(in[0], "ptr_gtsamNonlinearEqualityPose3");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityPose3_string_deserialize_2057(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityPose3> Shared;
  checkArguments("gtsamNonlinearEqualityPose3.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityPose3());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityPose3", false);
}
void gtsamNonlinearEqualityCal3_S2_collectorInsertAndMakeBase_2058(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityCal3_S2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityCal3_S2_upcastFromVoid_2059(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityCal3_S2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityCal3_S2_constructor_2060(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Cal3_S2& feasible = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  Shared *self = new Shared(new gtsam::NonlinearEqualityCal3_S2(j,feasible));
  collector_gtsamNonlinearEqualityCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityCal3_S2_constructor_2061(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::Cal3_S2& feasible = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityCal3_S2(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityCal3_S2_deconstructor_2062(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("delete_gtsamNonlinearEqualityCal3_S2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityCal3_S2::iterator item;
  item = collector_gtsamNonlinearEqualityCal3_S2.find(self);
  if(item != collector_gtsamNonlinearEqualityCal3_S2.end()) {
    delete self;
    collector_gtsamNonlinearEqualityCal3_S2.erase(item);
  }
}

void gtsamNonlinearEqualityCal3_S2_active_2063(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityCal3_S2_clone_2064(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityCal3_S2_dim_2065(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityCal3_S2_equals_2066(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityCal3_S2_error_2067(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityCal3_S2_get_noiseModel_2068(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityCal3_S2_keys_2069(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityCal3_S2_linearize_2070(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityCal3_S2_noiseModel_2071(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityCal3_S2_print_2072(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityCal3_S2_printKeys_2073(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityCal3_S2_size_2074(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityCal3_S2_unwhitenedError_2075(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityCal3_S2_whitenedError_2076(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityCal3_S2_string_serialize_2077(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCal3_S2>(in[0], "ptr_gtsamNonlinearEqualityCal3_S2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityCal3_S2_string_deserialize_2078(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCal3_S2> Shared;
  checkArguments("gtsamNonlinearEqualityCal3_S2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityCal3_S2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityCal3_S2", false);
}
void gtsamNonlinearEqualityCalibratedCamera_collectorInsertAndMakeBase_2079(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityCalibratedCamera.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityCalibratedCamera_upcastFromVoid_2080(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityCalibratedCamera>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityCalibratedCamera_constructor_2081(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::CalibratedCamera& feasible = *unwrap_shared_ptr< gtsam::CalibratedCamera >(in[1], "ptr_gtsamCalibratedCamera");
  Shared *self = new Shared(new gtsam::NonlinearEqualityCalibratedCamera(j,feasible));
  collector_gtsamNonlinearEqualityCalibratedCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityCalibratedCamera_constructor_2082(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::CalibratedCamera& feasible = *unwrap_shared_ptr< gtsam::CalibratedCamera >(in[1], "ptr_gtsamCalibratedCamera");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityCalibratedCamera(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityCalibratedCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityCalibratedCamera_deconstructor_2083(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("delete_gtsamNonlinearEqualityCalibratedCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityCalibratedCamera::iterator item;
  item = collector_gtsamNonlinearEqualityCalibratedCamera.find(self);
  if(item != collector_gtsamNonlinearEqualityCalibratedCamera.end()) {
    delete self;
    collector_gtsamNonlinearEqualityCalibratedCamera.erase(item);
  }
}

void gtsamNonlinearEqualityCalibratedCamera_active_2084(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityCalibratedCamera_clone_2085(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityCalibratedCamera_dim_2086(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityCalibratedCamera_equals_2087(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityCalibratedCamera_error_2088(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityCalibratedCamera_get_noiseModel_2089(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityCalibratedCamera_keys_2090(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityCalibratedCamera_linearize_2091(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityCalibratedCamera_noiseModel_2092(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityCalibratedCamera_print_2093(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityCalibratedCamera_printKeys_2094(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityCalibratedCamera_size_2095(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityCalibratedCamera_unwhitenedError_2096(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityCalibratedCamera_whitenedError_2097(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityCalibratedCamera_string_serialize_2098(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityCalibratedCamera>(in[0], "ptr_gtsamNonlinearEqualityCalibratedCamera");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityCalibratedCamera_string_deserialize_2099(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityCalibratedCamera> Shared;
  checkArguments("gtsamNonlinearEqualityCalibratedCamera.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityCalibratedCamera());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityCalibratedCamera", false);
}
void gtsamNonlinearEqualitySimpleCamera_collectorInsertAndMakeBase_2100(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualitySimpleCamera.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualitySimpleCamera_upcastFromVoid_2101(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualitySimpleCamera>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualitySimpleCamera_constructor_2102(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::SimpleCamera& feasible = *unwrap_shared_ptr< gtsam::SimpleCamera >(in[1], "ptr_gtsamSimpleCamera");
  Shared *self = new Shared(new gtsam::NonlinearEqualitySimpleCamera(j,feasible));
  collector_gtsamNonlinearEqualitySimpleCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualitySimpleCamera_constructor_2103(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::SimpleCamera& feasible = *unwrap_shared_ptr< gtsam::SimpleCamera >(in[1], "ptr_gtsamSimpleCamera");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualitySimpleCamera(j,feasible,error_gain));
  collector_gtsamNonlinearEqualitySimpleCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualitySimpleCamera_deconstructor_2104(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("delete_gtsamNonlinearEqualitySimpleCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualitySimpleCamera::iterator item;
  item = collector_gtsamNonlinearEqualitySimpleCamera.find(self);
  if(item != collector_gtsamNonlinearEqualitySimpleCamera.end()) {
    delete self;
    collector_gtsamNonlinearEqualitySimpleCamera.erase(item);
  }
}

void gtsamNonlinearEqualitySimpleCamera_active_2105(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualitySimpleCamera_clone_2106(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualitySimpleCamera_dim_2107(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualitySimpleCamera_equals_2108(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualitySimpleCamera_error_2109(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualitySimpleCamera_get_noiseModel_2110(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualitySimpleCamera_keys_2111(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualitySimpleCamera_linearize_2112(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualitySimpleCamera_noiseModel_2113(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualitySimpleCamera_print_2114(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualitySimpleCamera_printKeys_2115(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualitySimpleCamera_size_2116(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualitySimpleCamera_unwhitenedError_2117(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualitySimpleCamera_whitenedError_2118(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualitySimpleCamera_string_serialize_2119(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualitySimpleCamera>(in[0], "ptr_gtsamNonlinearEqualitySimpleCamera");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualitySimpleCamera_string_deserialize_2120(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualitySimpleCamera> Shared;
  checkArguments("gtsamNonlinearEqualitySimpleCamera.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualitySimpleCamera());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualitySimpleCamera", false);
}
void gtsamNonlinearEqualityConstantBias_collectorInsertAndMakeBase_2121(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNonlinearEqualityConstantBias.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityConstantBias_upcastFromVoid_2122(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::NonlinearEqualityConstantBias>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamNonlinearEqualityConstantBias_constructor_2123(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::imuBias::ConstantBias& feasible = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  Shared *self = new Shared(new gtsam::NonlinearEqualityConstantBias(j,feasible));
  collector_gtsamNonlinearEqualityConstantBias.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityConstantBias_constructor_2124(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;

  size_t j = unwrap< size_t >(in[0]);
  gtsam::imuBias::ConstantBias& feasible = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  double error_gain = unwrap< double >(in[2]);
  Shared *self = new Shared(new gtsam::NonlinearEqualityConstantBias(j,feasible,error_gain));
  collector_gtsamNonlinearEqualityConstantBias.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamNonlinearEqualityConstantBias_deconstructor_2125(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("delete_gtsamNonlinearEqualityConstantBias",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNonlinearEqualityConstantBias::iterator item;
  item = collector_gtsamNonlinearEqualityConstantBias.find(self);
  if(item != collector_gtsamNonlinearEqualityConstantBias.end()) {
    delete self;
    collector_gtsamNonlinearEqualityConstantBias.erase(item);
  }
}

void gtsamNonlinearEqualityConstantBias_active_2126(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamNonlinearEqualityConstantBias_clone_2127(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamNonlinearEqualityConstantBias_dim_2128(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamNonlinearEqualityConstantBias_equals_2129(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamNonlinearEqualityConstantBias_error_2130(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamNonlinearEqualityConstantBias_get_noiseModel_2131(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityConstantBias_keys_2132(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamNonlinearEqualityConstantBias_linearize_2133(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamNonlinearEqualityConstantBias_noiseModel_2134(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamNonlinearEqualityConstantBias_print_2135(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNonlinearEqualityConstantBias_printKeys_2136(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamNonlinearEqualityConstantBias_size_2137(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamNonlinearEqualityConstantBias_unwhitenedError_2138(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamNonlinearEqualityConstantBias_whitenedError_2139(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamNonlinearEqualityConstantBias_string_serialize_2140(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NonlinearEqualityConstantBias>(in[0], "ptr_gtsamNonlinearEqualityConstantBias");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamNonlinearEqualityConstantBias_string_deserialize_2141(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearEqualityConstantBias> Shared;
  checkArguments("gtsamNonlinearEqualityConstantBias.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::NonlinearEqualityConstantBias());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.NonlinearEqualityConstantBias", false);
}
void gtsamGeneralSFMFactor2Cal3_S2_collectorInsertAndMakeBase_2142(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGeneralSFMFactor2Cal3_S2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGeneralSFMFactor2Cal3_S2_upcastFromVoid_2143(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GeneralSFMFactor2Cal3_S2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGeneralSFMFactor2Cal3_S2_constructor_2144(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> model = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t landmarkKey = unwrap< size_t >(in[3]);
  size_t calibKey = unwrap< size_t >(in[4]);
  Shared *self = new Shared(new gtsam::GeneralSFMFactor2Cal3_S2(measured,model,poseKey,landmarkKey,calibKey));
  collector_gtsamGeneralSFMFactor2Cal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGeneralSFMFactor2Cal3_S2_deconstructor_2145(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("delete_gtsamGeneralSFMFactor2Cal3_S2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGeneralSFMFactor2Cal3_S2::iterator item;
  item = collector_gtsamGeneralSFMFactor2Cal3_S2.find(self);
  if(item != collector_gtsamGeneralSFMFactor2Cal3_S2.end()) {
    delete self;
    collector_gtsamGeneralSFMFactor2Cal3_S2.erase(item);
  }
}

void gtsamGeneralSFMFactor2Cal3_S2_active_2146(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamGeneralSFMFactor2Cal3_S2_clone_2147(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamGeneralSFMFactor2Cal3_S2_dim_2148(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamGeneralSFMFactor2Cal3_S2_equals_2149(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamGeneralSFMFactor2Cal3_S2_error_2150(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGeneralSFMFactor2Cal3_S2_get_noiseModel_2151(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGeneralSFMFactor2Cal3_S2_keys_2152(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGeneralSFMFactor2Cal3_S2_linearize_2153(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamGeneralSFMFactor2Cal3_S2_measured_2154(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->measured())),"gtsam.Point2", false);
}

void gtsamGeneralSFMFactor2Cal3_S2_noiseModel_2155(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGeneralSFMFactor2Cal3_S2_print_2156(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGeneralSFMFactor2Cal3_S2_printKeys_2157(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamGeneralSFMFactor2Cal3_S2_size_2158(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGeneralSFMFactor2Cal3_S2_unwhitenedError_2159(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamGeneralSFMFactor2Cal3_S2_whitenedError_2160(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamGeneralSFMFactor2Cal3_S2_string_serialize_2161(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2>(in[0], "ptr_gtsamGeneralSFMFactor2Cal3_S2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamGeneralSFMFactor2Cal3_S2_string_deserialize_2162(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactor2Cal3_S2> Shared;
  checkArguments("gtsamGeneralSFMFactor2Cal3_S2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::GeneralSFMFactor2Cal3_S2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.GeneralSFMFactor2Cal3_S2", false);
}
void gtsamSmartProjectionParams_collectorInsertAndMakeBase_2163(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SmartProjectionParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSmartProjectionParams.insert(self);
}

void gtsamSmartProjectionParams_constructor_2164(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SmartProjectionParams> Shared;

  Shared *self = new Shared(new gtsam::SmartProjectionParams());
  collector_gtsamSmartProjectionParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamSmartProjectionParams_deconstructor_2165(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionParams> Shared;
  checkArguments("delete_gtsamSmartProjectionParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSmartProjectionParams::iterator item;
  item = collector_gtsamSmartProjectionParams.find(self);
  if(item != collector_gtsamSmartProjectionParams.end()) {
    delete self;
    collector_gtsamSmartProjectionParams.erase(item);
  }
}

void gtsamSmartProjectionParams_setDynamicOutlierRejectionThreshold_2166(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionParams> Shared;
  checkArguments("setDynamicOutlierRejectionThreshold",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionParams>(in[0], "ptr_gtsamSmartProjectionParams");
  bool dynOutRejectionThreshold = unwrap< bool >(in[1]);
  obj->setDynamicOutlierRejectionThreshold(dynOutRejectionThreshold);
}

void gtsamSmartProjectionParams_setEnableEPI_2167(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionParams> Shared;
  checkArguments("setEnableEPI",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionParams>(in[0], "ptr_gtsamSmartProjectionParams");
  bool enableEPI = unwrap< bool >(in[1]);
  obj->setEnableEPI(enableEPI);
}

void gtsamSmartProjectionParams_setLandmarkDistanceThreshold_2168(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionParams> Shared;
  checkArguments("setLandmarkDistanceThreshold",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionParams>(in[0], "ptr_gtsamSmartProjectionParams");
  bool landmarkDistanceThreshold = unwrap< bool >(in[1]);
  obj->setLandmarkDistanceThreshold(landmarkDistanceThreshold);
}

void gtsamSmartProjectionParams_setRankTolerance_2169(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionParams> Shared;
  checkArguments("setRankTolerance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionParams>(in[0], "ptr_gtsamSmartProjectionParams");
  double rankTol = unwrap< double >(in[1]);
  obj->setRankTolerance(rankTol);
}

void gtsamEssentialMatrixFactor_collectorInsertAndMakeBase_2170(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamEssentialMatrixFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamEssentialMatrixFactor_upcastFromVoid_2171(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::EssentialMatrixFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamEssentialMatrixFactor_constructor_2172(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Point2& pA = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  gtsam::Point2& pB = *unwrap_shared_ptr< gtsam::Point2 >(in[2], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::EssentialMatrixFactor(key,pA,pB,noiseModel));
  collector_gtsamEssentialMatrixFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamEssentialMatrixFactor_deconstructor_2173(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("delete_gtsamEssentialMatrixFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamEssentialMatrixFactor::iterator item;
  item = collector_gtsamEssentialMatrixFactor.find(self);
  if(item != collector_gtsamEssentialMatrixFactor.end()) {
    delete self;
    collector_gtsamEssentialMatrixFactor.erase(item);
  }
}

void gtsamEssentialMatrixFactor_active_2174(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamEssentialMatrixFactor_clone_2175(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamEssentialMatrixFactor_dim_2176(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamEssentialMatrixFactor_equals_2177(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamEssentialMatrixFactor_error_2178(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamEssentialMatrixFactor_get_noiseModel_2179(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamEssentialMatrixFactor_keys_2180(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamEssentialMatrixFactor_linearize_2181(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamEssentialMatrixFactor_noiseModel_2182(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamEssentialMatrixFactor_print_2183(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamEssentialMatrixFactor_printKeys_2184(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamEssentialMatrixFactor_size_2185(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamEssentialMatrixFactor_unwhitenedError_2186(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamEssentialMatrixFactor_whitenedError_2187(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::EssentialMatrixFactor> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::EssentialMatrixFactor>(in[0], "ptr_gtsamEssentialMatrixFactor");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamimuBiasConstantBias_collectorInsertAndMakeBase_2188(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamimuBiasConstantBias.insert(self);
}

void gtsamimuBiasConstantBias_constructor_2189(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;

  Shared *self = new Shared(new gtsam::imuBias::ConstantBias());
  collector_gtsamimuBiasConstantBias.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamimuBiasConstantBias_constructor_2190(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;

  Vector biasAcc = unwrap< Vector >(in[0]);
  Vector biasGyro = unwrap< Vector >(in[1]);
  Shared *self = new Shared(new gtsam::imuBias::ConstantBias(biasAcc,biasGyro));
  collector_gtsamimuBiasConstantBias.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamimuBiasConstantBias_deconstructor_2191(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("delete_gtsamimuBiasConstantBias",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamimuBiasConstantBias::iterator item;
  item = collector_gtsamimuBiasConstantBias.find(self);
  if(item != collector_gtsamimuBiasConstantBias.end()) {
    delete self;
    collector_gtsamimuBiasConstantBias.erase(item);
  }
}

void gtsamimuBiasConstantBias_accelerometer_2192(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("accelerometer",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap< Vector >(obj->accelerometer());
}

void gtsamimuBiasConstantBias_between_2193(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("between",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  gtsam::imuBias::ConstantBias& b = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(obj->between(b))),"gtsam.imuBias.ConstantBias", false);
}

void gtsamimuBiasConstantBias_compose_2194(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("compose",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  gtsam::imuBias::ConstantBias& b = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(obj->compose(b))),"gtsam.imuBias.ConstantBias", false);
}

void gtsamimuBiasConstantBias_correctAccelerometer_2195(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("correctAccelerometer",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  Vector measurement = unwrap< Vector >(in[1]);
  out[0] = wrap< Vector >(obj->correctAccelerometer(measurement));
}

void gtsamimuBiasConstantBias_correctGyroscope_2196(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("correctGyroscope",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  Vector measurement = unwrap< Vector >(in[1]);
  out[0] = wrap< Vector >(obj->correctGyroscope(measurement));
}

void gtsamimuBiasConstantBias_equals_2197(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  gtsam::imuBias::ConstantBias& expected = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamimuBiasConstantBias_gyroscope_2198(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("gyroscope",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap< Vector >(obj->gyroscope());
}

void gtsamimuBiasConstantBias_inverse_2199(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("inverse",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(obj->inverse())),"gtsam.imuBias.ConstantBias", false);
}

void gtsamimuBiasConstantBias_localCoordinates_2200(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  gtsam::imuBias::ConstantBias& b = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap< Vector >(obj->localCoordinates(b));
}

void gtsamimuBiasConstantBias_print_2201(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamimuBiasConstantBias_retract_2202(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  Vector v = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(obj->retract(v))),"gtsam.imuBias.ConstantBias", false);
}

void gtsamimuBiasConstantBias_vector_2203(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("vector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::imuBias::ConstantBias>(in[0], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap< Vector >(obj->vector());
}

void gtsamimuBiasConstantBias_Expmap_2204(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("gtsamimuBiasConstantBias.Expmap",nargout,nargin,1);
  Vector v = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(gtsam::imuBias::ConstantBias::Expmap(v))),"gtsam.imuBias.ConstantBias", false);
}

void gtsamimuBiasConstantBias_Logmap_2205(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("gtsamimuBiasConstantBias.Logmap",nargout,nargin,1);
  gtsam::imuBias::ConstantBias& b = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[0], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap< Vector >(gtsam::imuBias::ConstantBias::Logmap(b));
}

void gtsamimuBiasConstantBias_identity_2206(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> SharedConstantBias;
  typedef boost::shared_ptr<gtsam::imuBias::ConstantBias> Shared;
  checkArguments("gtsamimuBiasConstantBias.identity",nargout,nargin,0);
  out[0] = wrap_shared_ptr(SharedConstantBias(new gtsam::imuBias::ConstantBias(gtsam::imuBias::ConstantBias::identity())),"gtsam.imuBias.ConstantBias", false);
}

void gtsamNavState_collectorInsertAndMakeBase_2207(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NavState> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamNavState.insert(self);
}

void gtsamNavState_constructor_2208(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NavState> Shared;

  Shared *self = new Shared(new gtsam::NavState());
  collector_gtsamNavState.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNavState_constructor_2209(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NavState> Shared;

  gtsam::Rot3& R = *unwrap_shared_ptr< gtsam::Rot3 >(in[0], "ptr_gtsamRot3");
  gtsam::Point3& t = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  Vector v = unwrap< Vector >(in[2]);
  Shared *self = new Shared(new gtsam::NavState(R,t,v));
  collector_gtsamNavState.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNavState_constructor_2210(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::NavState> Shared;

  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  Vector v = unwrap< Vector >(in[1]);
  Shared *self = new Shared(new gtsam::NavState(pose,v));
  collector_gtsamNavState.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamNavState_deconstructor_2211(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NavState> Shared;
  checkArguments("delete_gtsamNavState",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamNavState::iterator item;
  item = collector_gtsamNavState.find(self);
  if(item != collector_gtsamNavState.end()) {
    delete self;
    collector_gtsamNavState.erase(item);
  }
}

void gtsamNavState_attitude_2212(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::NavState> Shared;
  checkArguments("attitude",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NavState>(in[0], "ptr_gtsamNavState");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->attitude())),"gtsam.Rot3", false);
}

void gtsamNavState_equals_2213(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NavState> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::NavState>(in[0], "ptr_gtsamNavState");
  gtsam::NavState& expected = *unwrap_shared_ptr< gtsam::NavState >(in[1], "ptr_gtsamNavState");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamNavState_pose_2214(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::NavState> Shared;
  checkArguments("pose",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NavState>(in[0], "ptr_gtsamNavState");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->pose())),"gtsam.Pose3", false);
}

void gtsamNavState_position_2215(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::NavState> Shared;
  checkArguments("position",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NavState>(in[0], "ptr_gtsamNavState");
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->position())),"gtsam.Point3", false);
}

void gtsamNavState_print_2216(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NavState> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::NavState>(in[0], "ptr_gtsamNavState");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamNavState_velocity_2217(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NavState> Shared;
  checkArguments("velocity",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::NavState>(in[0], "ptr_gtsamNavState");
  out[0] = wrap< Vector >(obj->velocity());
}

void gtsamPreintegratedRotationParams_collectorInsertAndMakeBase_2218(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPreintegratedRotationParams.insert(self);
}

void gtsamPreintegratedRotationParams_upcastFromVoid_2219(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PreintegratedRotationParams>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPreintegratedRotationParams_constructor_2220(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;

  Shared *self = new Shared(new gtsam::PreintegratedRotationParams());
  collector_gtsamPreintegratedRotationParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPreintegratedRotationParams_deconstructor_2221(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;
  checkArguments("delete_gtsamPreintegratedRotationParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPreintegratedRotationParams::iterator item;
  item = collector_gtsamPreintegratedRotationParams.find(self);
  if(item != collector_gtsamPreintegratedRotationParams.end()) {
    delete self;
    collector_gtsamPreintegratedRotationParams.erase(item);
  }
}

void gtsamPreintegratedRotationParams_getGyroscopeCovariance_2222(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;
  checkArguments("getGyroscopeCovariance",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedRotationParams>(in[0], "ptr_gtsamPreintegratedRotationParams");
  out[0] = wrap< Matrix >(obj->getGyroscopeCovariance());
}

void gtsamPreintegratedRotationParams_setBodyPSensor_2223(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;
  checkArguments("setBodyPSensor",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedRotationParams>(in[0], "ptr_gtsamPreintegratedRotationParams");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  obj->setBodyPSensor(pose);
}

void gtsamPreintegratedRotationParams_setGyroscopeCovariance_2224(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;
  checkArguments("setGyroscopeCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedRotationParams>(in[0], "ptr_gtsamPreintegratedRotationParams");
  Matrix cov = unwrap< Matrix >(in[1]);
  obj->setGyroscopeCovariance(cov);
}

void gtsamPreintegratedRotationParams_setOmegaCoriolis_2225(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> Shared;
  checkArguments("setOmegaCoriolis",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedRotationParams>(in[0], "ptr_gtsamPreintegratedRotationParams");
  Vector omega = unwrap< Vector >(in[1]);
  obj->setOmegaCoriolis(omega);
}

void gtsamPreintegrationParams_collectorInsertAndMakeBase_2226(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPreintegrationParams.insert(self);

  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPreintegrationParams_upcastFromVoid_2227(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PreintegrationParams>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPreintegrationParams_constructor_2228(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;

  Vector n_gravity = unwrap< Vector >(in[0]);
  Shared *self = new Shared(new gtsam::PreintegrationParams(n_gravity));
  collector_gtsamPreintegrationParams.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::PreintegratedRotationParams> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPreintegrationParams_deconstructor_2229(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("delete_gtsamPreintegrationParams",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPreintegrationParams::iterator item;
  item = collector_gtsamPreintegrationParams.find(self);
  if(item != collector_gtsamPreintegrationParams.end()) {
    delete self;
    collector_gtsamPreintegrationParams.erase(item);
  }
}

void gtsamPreintegrationParams_getAccelerometerCovariance_2230(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("getAccelerometerCovariance",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  out[0] = wrap< Matrix >(obj->getAccelerometerCovariance());
}

void gtsamPreintegrationParams_getGyroscopeCovariance_2231(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("getGyroscopeCovariance",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  out[0] = wrap< Matrix >(obj->getGyroscopeCovariance());
}

void gtsamPreintegrationParams_getIntegrationCovariance_2232(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("getIntegrationCovariance",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  out[0] = wrap< Matrix >(obj->getIntegrationCovariance());
}

void gtsamPreintegrationParams_getUse2ndOrderCoriolis_2233(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("getUse2ndOrderCoriolis",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  out[0] = wrap< bool >(obj->getUse2ndOrderCoriolis());
}

void gtsamPreintegrationParams_print_2234(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPreintegrationParams_setAccelerometerCovariance_2235(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("setAccelerometerCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  Matrix cov = unwrap< Matrix >(in[1]);
  obj->setAccelerometerCovariance(cov);
}

void gtsamPreintegrationParams_setBodyPSensor_2236(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("setBodyPSensor",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  obj->setBodyPSensor(pose);
}

void gtsamPreintegrationParams_setGyroscopeCovariance_2237(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("setGyroscopeCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  Matrix cov = unwrap< Matrix >(in[1]);
  obj->setGyroscopeCovariance(cov);
}

void gtsamPreintegrationParams_setIntegrationCovariance_2238(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("setIntegrationCovariance",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  Matrix cov = unwrap< Matrix >(in[1]);
  obj->setIntegrationCovariance(cov);
}

void gtsamPreintegrationParams_setOmegaCoriolis_2239(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("setOmegaCoriolis",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  Vector omega = unwrap< Vector >(in[1]);
  obj->setOmegaCoriolis(omega);
}

void gtsamPreintegrationParams_setUse2ndOrderCoriolis_2240(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegrationParams> Shared;
  checkArguments("setUse2ndOrderCoriolis",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegrationParams>(in[0], "ptr_gtsamPreintegrationParams");
  bool flag = unwrap< bool >(in[1]);
  obj->setUse2ndOrderCoriolis(flag);
}

void gtsamPreintegratedImuMeasurements_collectorInsertAndMakeBase_2241(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPreintegratedImuMeasurements.insert(self);
}

void gtsamPreintegratedImuMeasurements_constructor_2242(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;

  boost::shared_ptr<gtsam::PreintegrationParams> params = unwrap_shared_ptr< gtsam::PreintegrationParams >(in[0], "ptr_gtsamPreintegrationParams");
  Shared *self = new Shared(new gtsam::PreintegratedImuMeasurements(params));
  collector_gtsamPreintegratedImuMeasurements.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPreintegratedImuMeasurements_constructor_2243(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;

  boost::shared_ptr<gtsam::PreintegrationParams> params = unwrap_shared_ptr< gtsam::PreintegrationParams >(in[0], "ptr_gtsamPreintegrationParams");
  gtsam::imuBias::ConstantBias& bias = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[1], "ptr_gtsamimuBiasConstantBias");
  Shared *self = new Shared(new gtsam::PreintegratedImuMeasurements(params,bias));
  collector_gtsamPreintegratedImuMeasurements.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPreintegratedImuMeasurements_deconstructor_2244(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("delete_gtsamPreintegratedImuMeasurements",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPreintegratedImuMeasurements::iterator item;
  item = collector_gtsamPreintegratedImuMeasurements.find(self);
  if(item != collector_gtsamPreintegratedImuMeasurements.end()) {
    delete self;
    collector_gtsamPreintegratedImuMeasurements.erase(item);
  }
}

void gtsamPreintegratedImuMeasurements_biasHatVector_2245(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("biasHatVector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  out[0] = wrap< Vector >(obj->biasHatVector());
}

void gtsamPreintegratedImuMeasurements_deltaPij_2246(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("deltaPij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  out[0] = wrap< Vector >(obj->deltaPij());
}

void gtsamPreintegratedImuMeasurements_deltaRij_2247(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("deltaRij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->deltaRij())),"gtsam.Rot3", false);
}

void gtsamPreintegratedImuMeasurements_deltaTij_2248(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("deltaTij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  out[0] = wrap< double >(obj->deltaTij());
}

void gtsamPreintegratedImuMeasurements_deltaVij_2249(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("deltaVij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  out[0] = wrap< Vector >(obj->deltaVij());
}

void gtsamPreintegratedImuMeasurements_equals_2250(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  gtsam::PreintegratedImuMeasurements& expected = *unwrap_shared_ptr< gtsam::PreintegratedImuMeasurements >(in[1], "ptr_gtsamPreintegratedImuMeasurements");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamPreintegratedImuMeasurements_integrateMeasurement_2251(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("integrateMeasurement",nargout,nargin-1,3);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  Vector measuredAcc = unwrap< Vector >(in[1]);
  Vector measuredOmega = unwrap< Vector >(in[2]);
  double deltaT = unwrap< double >(in[3]);
  obj->integrateMeasurement(measuredAcc,measuredOmega,deltaT);
}

void gtsamPreintegratedImuMeasurements_predict_2252(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NavState> SharedNavState;
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("predict",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  gtsam::NavState& state_i = *unwrap_shared_ptr< gtsam::NavState >(in[1], "ptr_gtsamNavState");
  gtsam::imuBias::ConstantBias& bias = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[2], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap_shared_ptr(SharedNavState(new gtsam::NavState(obj->predict(state_i,bias))),"gtsam.NavState", false);
}

void gtsamPreintegratedImuMeasurements_preintMeasCov_2253(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("preintMeasCov",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  out[0] = wrap< Matrix >(obj->preintMeasCov());
}

void gtsamPreintegratedImuMeasurements_print_2254(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPreintegratedImuMeasurements_resetIntegration_2255(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> Shared;
  checkArguments("resetIntegration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedImuMeasurements>(in[0], "ptr_gtsamPreintegratedImuMeasurements");
  obj->resetIntegration();
}

void gtsamImuFactor_collectorInsertAndMakeBase_2256(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamImuFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamImuFactor_upcastFromVoid_2257(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::ImuFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamImuFactor_constructor_2258(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;

  size_t pose_i = unwrap< size_t >(in[0]);
  size_t vel_i = unwrap< size_t >(in[1]);
  size_t pose_j = unwrap< size_t >(in[2]);
  size_t vel_j = unwrap< size_t >(in[3]);
  size_t bias = unwrap< size_t >(in[4]);
  gtsam::PreintegratedImuMeasurements& preintegratedMeasurements = *unwrap_shared_ptr< gtsam::PreintegratedImuMeasurements >(in[5], "ptr_gtsamPreintegratedImuMeasurements");
  Shared *self = new Shared(new gtsam::ImuFactor(pose_i,vel_i,pose_j,vel_j,bias,preintegratedMeasurements));
  collector_gtsamImuFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamImuFactor_deconstructor_2259(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("delete_gtsamImuFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamImuFactor::iterator item;
  item = collector_gtsamImuFactor.find(self);
  if(item != collector_gtsamImuFactor.end()) {
    delete self;
    collector_gtsamImuFactor.erase(item);
  }
}

void gtsamImuFactor_active_2260(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamImuFactor_clone_2261(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamImuFactor_dim_2262(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamImuFactor_equals_2263(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  gtsam::NonlinearFactor& other = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamImuFactor_error_2264(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamImuFactor_evaluateError_2265(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("evaluateError",nargout,nargin-1,5);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  gtsam::Pose3& pose_i = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  Vector vel_i = unwrap< Vector >(in[2]);
  gtsam::Pose3& pose_j = *unwrap_shared_ptr< gtsam::Pose3 >(in[3], "ptr_gtsamPose3");
  Vector vel_j = unwrap< Vector >(in[4]);
  gtsam::imuBias::ConstantBias& bias = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[5], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap< Vector >(obj->evaluateError(pose_i,vel_i,pose_j,vel_j,bias));
}

void gtsamImuFactor_keys_2266(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamImuFactor_linearize_2267(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamImuFactor_preintegratedMeasurements_2268(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedImuMeasurements> SharedPreintegratedImuMeasurements;
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("preintegratedMeasurements",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  out[0] = wrap_shared_ptr(SharedPreintegratedImuMeasurements(new gtsam::PreintegratedImuMeasurements(obj->preintegratedMeasurements())),"gtsam.PreintegratedImuMeasurements", false);
}

void gtsamImuFactor_print_2269(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamImuFactor_printKeys_2270(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamImuFactor_size_2271(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::ImuFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::ImuFactor>(in[0], "ptr_gtsamImuFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPreintegratedCombinedMeasurements_collectorInsertAndMakeBase_2272(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPreintegratedCombinedMeasurements.insert(self);
}

void gtsamPreintegratedCombinedMeasurements_deconstructor_2273(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("delete_gtsamPreintegratedCombinedMeasurements",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPreintegratedCombinedMeasurements::iterator item;
  item = collector_gtsamPreintegratedCombinedMeasurements.find(self);
  if(item != collector_gtsamPreintegratedCombinedMeasurements.end()) {
    delete self;
    collector_gtsamPreintegratedCombinedMeasurements.erase(item);
  }
}

void gtsamPreintegratedCombinedMeasurements_biasHatVector_2274(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("biasHatVector",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  out[0] = wrap< Vector >(obj->biasHatVector());
}

void gtsamPreintegratedCombinedMeasurements_deltaPij_2275(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("deltaPij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  out[0] = wrap< Vector >(obj->deltaPij());
}

void gtsamPreintegratedCombinedMeasurements_deltaRij_2276(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("deltaRij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->deltaRij())),"gtsam.Rot3", false);
}

void gtsamPreintegratedCombinedMeasurements_deltaTij_2277(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("deltaTij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  out[0] = wrap< double >(obj->deltaTij());
}

void gtsamPreintegratedCombinedMeasurements_deltaVij_2278(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("deltaVij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  out[0] = wrap< Vector >(obj->deltaVij());
}

void gtsamPreintegratedCombinedMeasurements_equals_2279(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  gtsam::PreintegratedCombinedMeasurements& expected = *unwrap_shared_ptr< gtsam::PreintegratedCombinedMeasurements >(in[1], "ptr_gtsamPreintegratedCombinedMeasurements");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamPreintegratedCombinedMeasurements_integrateMeasurement_2280(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("integrateMeasurement",nargout,nargin-1,3);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  Vector measuredAcc = unwrap< Vector >(in[1]);
  Vector measuredOmega = unwrap< Vector >(in[2]);
  double deltaT = unwrap< double >(in[3]);
  obj->integrateMeasurement(measuredAcc,measuredOmega,deltaT);
}

void gtsamPreintegratedCombinedMeasurements_predict_2281(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NavState> SharedNavState;
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("predict",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  gtsam::NavState& state_i = *unwrap_shared_ptr< gtsam::NavState >(in[1], "ptr_gtsamNavState");
  gtsam::imuBias::ConstantBias& bias = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[2], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap_shared_ptr(SharedNavState(new gtsam::NavState(obj->predict(state_i,bias))),"gtsam.NavState", false);
}

void gtsamPreintegratedCombinedMeasurements_preintMeasCov_2282(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("preintMeasCov",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  out[0] = wrap< Matrix >(obj->preintMeasCov());
}

void gtsamPreintegratedCombinedMeasurements_print_2283(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPreintegratedCombinedMeasurements_resetIntegration_2284(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> Shared;
  checkArguments("resetIntegration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedCombinedMeasurements>(in[0], "ptr_gtsamPreintegratedCombinedMeasurements");
  obj->resetIntegration();
}

void gtsamCombinedImuFactor_collectorInsertAndMakeBase_2285(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamCombinedImuFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamCombinedImuFactor_upcastFromVoid_2286(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::CombinedImuFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamCombinedImuFactor_constructor_2287(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;

  size_t pose_i = unwrap< size_t >(in[0]);
  size_t vel_i = unwrap< size_t >(in[1]);
  size_t pose_j = unwrap< size_t >(in[2]);
  size_t vel_j = unwrap< size_t >(in[3]);
  size_t bias_i = unwrap< size_t >(in[4]);
  size_t bias_j = unwrap< size_t >(in[5]);
  gtsam::PreintegratedCombinedMeasurements& CombinedPreintegratedMeasurements = *unwrap_shared_ptr< gtsam::PreintegratedCombinedMeasurements >(in[6], "ptr_gtsamPreintegratedCombinedMeasurements");
  Shared *self = new Shared(new gtsam::CombinedImuFactor(pose_i,vel_i,pose_j,vel_j,bias_i,bias_j,CombinedPreintegratedMeasurements));
  collector_gtsamCombinedImuFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamCombinedImuFactor_deconstructor_2288(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("delete_gtsamCombinedImuFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamCombinedImuFactor::iterator item;
  item = collector_gtsamCombinedImuFactor.find(self);
  if(item != collector_gtsamCombinedImuFactor.end()) {
    delete self;
    collector_gtsamCombinedImuFactor.erase(item);
  }
}

void gtsamCombinedImuFactor_active_2289(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamCombinedImuFactor_clone_2290(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamCombinedImuFactor_dim_2291(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamCombinedImuFactor_equals_2292(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  gtsam::NonlinearFactor& other = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamCombinedImuFactor_error_2293(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamCombinedImuFactor_evaluateError_2294(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("evaluateError",nargout,nargin-1,6);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  gtsam::Pose3& pose_i = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  Vector vel_i = unwrap< Vector >(in[2]);
  gtsam::Pose3& pose_j = *unwrap_shared_ptr< gtsam::Pose3 >(in[3], "ptr_gtsamPose3");
  Vector vel_j = unwrap< Vector >(in[4]);
  gtsam::imuBias::ConstantBias& bias_i = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[5], "ptr_gtsamimuBiasConstantBias");
  gtsam::imuBias::ConstantBias& bias_j = *unwrap_shared_ptr< gtsam::imuBias::ConstantBias >(in[6], "ptr_gtsamimuBiasConstantBias");
  out[0] = wrap< Vector >(obj->evaluateError(pose_i,vel_i,pose_j,vel_j,bias_i,bias_j));
}

void gtsamCombinedImuFactor_keys_2295(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamCombinedImuFactor_linearize_2296(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamCombinedImuFactor_preintegratedMeasurements_2297(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedCombinedMeasurements> SharedPreintegratedCombinedMeasurements;
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("preintegratedMeasurements",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  out[0] = wrap_shared_ptr(SharedPreintegratedCombinedMeasurements(new gtsam::PreintegratedCombinedMeasurements(obj->preintegratedMeasurements())),"gtsam.PreintegratedCombinedMeasurements", false);
}

void gtsamCombinedImuFactor_print_2298(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamCombinedImuFactor_printKeys_2299(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamCombinedImuFactor_size_2300(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::CombinedImuFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::CombinedImuFactor>(in[0], "ptr_gtsamCombinedImuFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPreintegratedAhrsMeasurements_collectorInsertAndMakeBase_2301(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPreintegratedAhrsMeasurements.insert(self);
}

void gtsamPreintegratedAhrsMeasurements_constructor_2302(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;

  Vector bias = unwrap< Vector >(in[0]);
  Matrix measuredOmegaCovariance = unwrap< Matrix >(in[1]);
  Shared *self = new Shared(new gtsam::PreintegratedAhrsMeasurements(bias,measuredOmegaCovariance));
  collector_gtsamPreintegratedAhrsMeasurements.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPreintegratedAhrsMeasurements_constructor_2303(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;

  gtsam::PreintegratedAhrsMeasurements& rhs = *unwrap_shared_ptr< gtsam::PreintegratedAhrsMeasurements >(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  Shared *self = new Shared(new gtsam::PreintegratedAhrsMeasurements(rhs));
  collector_gtsamPreintegratedAhrsMeasurements.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPreintegratedAhrsMeasurements_deconstructor_2304(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("delete_gtsamPreintegratedAhrsMeasurements",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPreintegratedAhrsMeasurements::iterator item;
  item = collector_gtsamPreintegratedAhrsMeasurements.find(self);
  if(item != collector_gtsamPreintegratedAhrsMeasurements.end()) {
    delete self;
    collector_gtsamPreintegratedAhrsMeasurements.erase(item);
  }
}

void gtsamPreintegratedAhrsMeasurements_biasHat_2305(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("biasHat",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedAhrsMeasurements>(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  out[0] = wrap< Vector >(obj->biasHat());
}

void gtsamPreintegratedAhrsMeasurements_deltaRij_2306(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("deltaRij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedAhrsMeasurements>(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->deltaRij())),"gtsam.Rot3", false);
}

void gtsamPreintegratedAhrsMeasurements_deltaTij_2307(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("deltaTij",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedAhrsMeasurements>(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  out[0] = wrap< double >(obj->deltaTij());
}

void gtsamPreintegratedAhrsMeasurements_equals_2308(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedAhrsMeasurements>(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  gtsam::PreintegratedAhrsMeasurements& expected = *unwrap_shared_ptr< gtsam::PreintegratedAhrsMeasurements >(in[1], "ptr_gtsamPreintegratedAhrsMeasurements");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamPreintegratedAhrsMeasurements_integrateMeasurement_2309(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("integrateMeasurement",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedAhrsMeasurements>(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  Vector measuredOmega = unwrap< Vector >(in[1]);
  double deltaT = unwrap< double >(in[2]);
  obj->integrateMeasurement(measuredOmega,deltaT);
}

void gtsamPreintegratedAhrsMeasurements_print_2310(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedAhrsMeasurements>(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPreintegratedAhrsMeasurements_resetIntegration_2311(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> Shared;
  checkArguments("resetIntegration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PreintegratedAhrsMeasurements>(in[0], "ptr_gtsamPreintegratedAhrsMeasurements");
  obj->resetIntegration();
}

void gtsamAHRSFactor_collectorInsertAndMakeBase_2312(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamAHRSFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamAHRSFactor_upcastFromVoid_2313(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::AHRSFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamAHRSFactor_constructor_2314(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;

  size_t rot_i = unwrap< size_t >(in[0]);
  size_t rot_j = unwrap< size_t >(in[1]);
  size_t bias = unwrap< size_t >(in[2]);
  gtsam::PreintegratedAhrsMeasurements& preintegratedMeasurements = *unwrap_shared_ptr< gtsam::PreintegratedAhrsMeasurements >(in[3], "ptr_gtsamPreintegratedAhrsMeasurements");
  Vector omegaCoriolis = unwrap< Vector >(in[4]);
  Shared *self = new Shared(new gtsam::AHRSFactor(rot_i,rot_j,bias,preintegratedMeasurements,omegaCoriolis));
  collector_gtsamAHRSFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamAHRSFactor_constructor_2315(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;

  size_t rot_i = unwrap< size_t >(in[0]);
  size_t rot_j = unwrap< size_t >(in[1]);
  size_t bias = unwrap< size_t >(in[2]);
  gtsam::PreintegratedAhrsMeasurements& preintegratedMeasurements = *unwrap_shared_ptr< gtsam::PreintegratedAhrsMeasurements >(in[3], "ptr_gtsamPreintegratedAhrsMeasurements");
  Vector omegaCoriolis = unwrap< Vector >(in[4]);
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[5], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::AHRSFactor(rot_i,rot_j,bias,preintegratedMeasurements,omegaCoriolis,body_P_sensor));
  collector_gtsamAHRSFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamAHRSFactor_deconstructor_2316(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("delete_gtsamAHRSFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamAHRSFactor::iterator item;
  item = collector_gtsamAHRSFactor.find(self);
  if(item != collector_gtsamAHRSFactor.end()) {
    delete self;
    collector_gtsamAHRSFactor.erase(item);
  }
}

void gtsamAHRSFactor_active_2317(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamAHRSFactor_clone_2318(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamAHRSFactor_dim_2319(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamAHRSFactor_equals_2320(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  gtsam::NonlinearFactor& other = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamAHRSFactor_error_2321(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamAHRSFactor_evaluateError_2322(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("evaluateError",nargout,nargin-1,3);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  gtsam::Rot3& rot_i = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  gtsam::Rot3& rot_j = *unwrap_shared_ptr< gtsam::Rot3 >(in[2], "ptr_gtsamRot3");
  Vector bias = unwrap< Vector >(in[3]);
  out[0] = wrap< Vector >(obj->evaluateError(rot_i,rot_j,bias));
}

void gtsamAHRSFactor_keys_2323(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamAHRSFactor_linearize_2324(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamAHRSFactor_predict_2325(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3> SharedRot3;
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("predict",nargout,nargin-1,4);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  gtsam::Rot3& rot_i = *unwrap_shared_ptr< gtsam::Rot3 >(in[1], "ptr_gtsamRot3");
  Vector bias = unwrap< Vector >(in[2]);
  gtsam::PreintegratedAhrsMeasurements& preintegratedMeasurements = *unwrap_shared_ptr< gtsam::PreintegratedAhrsMeasurements >(in[3], "ptr_gtsamPreintegratedAhrsMeasurements");
  Vector omegaCoriolis = unwrap< Vector >(in[4]);
  out[0] = wrap_shared_ptr(SharedRot3(new gtsam::Rot3(obj->predict(rot_i,bias,preintegratedMeasurements,omegaCoriolis))),"gtsam.Rot3", false);
}

void gtsamAHRSFactor_preintegratedMeasurements_2326(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PreintegratedAhrsMeasurements> SharedPreintegratedAhrsMeasurements;
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("preintegratedMeasurements",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  out[0] = wrap_shared_ptr(SharedPreintegratedAhrsMeasurements(new gtsam::PreintegratedAhrsMeasurements(obj->preintegratedMeasurements())),"gtsam.PreintegratedAhrsMeasurements", false);
}

void gtsamAHRSFactor_print_2327(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamAHRSFactor_printKeys_2328(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamAHRSFactor_size_2329(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::AHRSFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::AHRSFactor>(in[0], "ptr_gtsamAHRSFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRot3AttitudeFactor_collectorInsertAndMakeBase_2330(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRot3AttitudeFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRot3AttitudeFactor_upcastFromVoid_2331(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::Rot3AttitudeFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRot3AttitudeFactor_constructor_2332(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Unit3& nZ = *unwrap_shared_ptr< gtsam::Unit3 >(in[1], "ptr_gtsamUnit3");
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[2], "ptr_gtsamnoiseModelDiagonal");
  gtsam::Unit3& bRef = *unwrap_shared_ptr< gtsam::Unit3 >(in[3], "ptr_gtsamUnit3");
  Shared *self = new Shared(new gtsam::Rot3AttitudeFactor(key,nZ,model,bRef));
  collector_gtsamRot3AttitudeFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRot3AttitudeFactor_constructor_2333(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Unit3& nZ = *unwrap_shared_ptr< gtsam::Unit3 >(in[1], "ptr_gtsamUnit3");
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[2], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::Rot3AttitudeFactor(key,nZ,model));
  collector_gtsamRot3AttitudeFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRot3AttitudeFactor_constructor_2334(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;

  Shared *self = new Shared(new gtsam::Rot3AttitudeFactor());
  collector_gtsamRot3AttitudeFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRot3AttitudeFactor_deconstructor_2335(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("delete_gtsamRot3AttitudeFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRot3AttitudeFactor::iterator item;
  item = collector_gtsamRot3AttitudeFactor.find(self);
  if(item != collector_gtsamRot3AttitudeFactor.end()) {
    delete self;
    collector_gtsamRot3AttitudeFactor.erase(item);
  }
}

void gtsamRot3AttitudeFactor_active_2336(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRot3AttitudeFactor_bRef_2337(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> SharedUnit3;
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("bRef",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  out[0] = wrap_shared_ptr(SharedUnit3(new gtsam::Unit3(obj->bRef())),"gtsam.Unit3", false);
}

void gtsamRot3AttitudeFactor_clone_2338(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRot3AttitudeFactor_dim_2339(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRot3AttitudeFactor_equals_2340(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  gtsam::NonlinearFactor& expected = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamRot3AttitudeFactor_error_2341(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRot3AttitudeFactor_keys_2342(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRot3AttitudeFactor_linearize_2343(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRot3AttitudeFactor_nZ_2344(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> SharedUnit3;
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("nZ",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  out[0] = wrap_shared_ptr(SharedUnit3(new gtsam::Unit3(obj->nZ())),"gtsam.Unit3", false);
}

void gtsamRot3AttitudeFactor_print_2345(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRot3AttitudeFactor_printKeys_2346(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRot3AttitudeFactor_size_2347(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Rot3AttitudeFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Rot3AttitudeFactor>(in[0], "ptr_gtsamRot3AttitudeFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPose3AttitudeFactor_collectorInsertAndMakeBase_2348(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPose3AttitudeFactor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPose3AttitudeFactor_upcastFromVoid_2349(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::Pose3AttitudeFactor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPose3AttitudeFactor_constructor_2350(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Unit3& nZ = *unwrap_shared_ptr< gtsam::Unit3 >(in[1], "ptr_gtsamUnit3");
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[2], "ptr_gtsamnoiseModelDiagonal");
  gtsam::Unit3& bRef = *unwrap_shared_ptr< gtsam::Unit3 >(in[3], "ptr_gtsamUnit3");
  Shared *self = new Shared(new gtsam::Pose3AttitudeFactor(key,nZ,model,bRef));
  collector_gtsamPose3AttitudeFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPose3AttitudeFactor_constructor_2351(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Unit3& nZ = *unwrap_shared_ptr< gtsam::Unit3 >(in[1], "ptr_gtsamUnit3");
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[2], "ptr_gtsamnoiseModelDiagonal");
  Shared *self = new Shared(new gtsam::Pose3AttitudeFactor(key,nZ,model));
  collector_gtsamPose3AttitudeFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPose3AttitudeFactor_constructor_2352(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;

  Shared *self = new Shared(new gtsam::Pose3AttitudeFactor());
  collector_gtsamPose3AttitudeFactor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPose3AttitudeFactor_deconstructor_2353(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("delete_gtsamPose3AttitudeFactor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPose3AttitudeFactor::iterator item;
  item = collector_gtsamPose3AttitudeFactor.find(self);
  if(item != collector_gtsamPose3AttitudeFactor.end()) {
    delete self;
    collector_gtsamPose3AttitudeFactor.erase(item);
  }
}

void gtsamPose3AttitudeFactor_active_2354(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPose3AttitudeFactor_bRef_2355(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> SharedUnit3;
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("bRef",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  out[0] = wrap_shared_ptr(SharedUnit3(new gtsam::Unit3(obj->bRef())),"gtsam.Unit3", false);
}

void gtsamPose3AttitudeFactor_clone_2356(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPose3AttitudeFactor_dim_2357(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPose3AttitudeFactor_equals_2358(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  gtsam::NonlinearFactor& expected = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(expected,tol));
}

void gtsamPose3AttitudeFactor_error_2359(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPose3AttitudeFactor_keys_2360(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPose3AttitudeFactor_linearize_2361(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPose3AttitudeFactor_nZ_2362(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Unit3> SharedUnit3;
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("nZ",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  out[0] = wrap_shared_ptr(SharedUnit3(new gtsam::Unit3(obj->nZ())),"gtsam.Unit3", false);
}

void gtsamPose3AttitudeFactor_print_2363(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPose3AttitudeFactor_printKeys_2364(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPose3AttitudeFactor_size_2365(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3AttitudeFactor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::Pose3AttitudeFactor>(in[0], "ptr_gtsamPose3AttitudeFactor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRedirectCout_collectorInsertAndMakeBase_2366(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RedirectCout> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRedirectCout.insert(self);
}

void gtsamRedirectCout_constructor_2367(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RedirectCout> Shared;

  Shared *self = new Shared(new gtsam::RedirectCout());
  collector_gtsamRedirectCout.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamRedirectCout_deconstructor_2368(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RedirectCout> Shared;
  checkArguments("delete_gtsamRedirectCout",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRedirectCout::iterator item;
  item = collector_gtsamRedirectCout.find(self);
  if(item != collector_gtsamRedirectCout.end()) {
    delete self;
    collector_gtsamRedirectCout.erase(item);
  }
}

void gtsamRedirectCout_str_2369(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RedirectCout> Shared;
  checkArguments("str",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RedirectCout>(in[0], "ptr_gtsamRedirectCout");
  out[0] = wrap< string >(obj->str());
}

void gtsamPinholeCameraCal3_S2_collectorInsertAndMakeBase_2370(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPinholeCameraCal3_S2.insert(self);
}

void gtsamPinholeCameraCal3_S2_constructor_2371(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;

  Shared *self = new Shared(new gtsam::PinholeCameraCal3_S2());
  collector_gtsamPinholeCameraCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPinholeCameraCal3_S2_constructor_2372(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;

  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::PinholeCameraCal3_S2(pose));
  collector_gtsamPinholeCameraCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPinholeCameraCal3_S2_constructor_2373(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;

  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[0], "ptr_gtsamPose3");
  gtsam::Cal3_S2& K = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  Shared *self = new Shared(new gtsam::PinholeCameraCal3_S2(pose,K));
  collector_gtsamPinholeCameraCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;
}

void gtsamPinholeCameraCal3_S2_deconstructor_2374(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("delete_gtsamPinholeCameraCal3_S2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPinholeCameraCal3_S2::iterator item;
  item = collector_gtsamPinholeCameraCal3_S2.find(self);
  if(item != collector_gtsamPinholeCameraCal3_S2.end()) {
    delete self;
    collector_gtsamPinholeCameraCal3_S2.erase(item);
  }
}

void gtsamPinholeCameraCal3_S2_backproject_2375(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("backproject",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  gtsam::Point2& p = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  double depth = unwrap< double >(in[2]);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(obj->backproject(p,depth))),"gtsam.Point3", false);
}

void gtsamPinholeCameraCal3_S2_calibration_2376(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> SharedCal3_S2;
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("calibration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  out[0] = wrap_shared_ptr(SharedCal3_S2(new gtsam::Cal3_S2(obj->calibration())),"gtsam.Cal3_S2", false);
}

void gtsamPinholeCameraCal3_S2_dim_2377(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPinholeCameraCal3_S2_equals_2378(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  gtsam::PinholeCameraCal3_S2& camera = *unwrap_shared_ptr< gtsam::PinholeCameraCal3_S2 >(in[1], "ptr_gtsamPinholeCameraCal3_S2");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(camera,tol));
}

void gtsamPinholeCameraCal3_S2_localCoordinates_2379(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("localCoordinates",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  gtsam::PinholeCameraCal3_S2& T2 = *unwrap_shared_ptr< gtsam::PinholeCameraCal3_S2 >(in[1], "ptr_gtsamPinholeCameraCal3_S2");
  out[0] = wrap< Vector >(obj->localCoordinates(T2));
}

void gtsamPinholeCameraCal3_S2_pose_2380(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Pose3> SharedPose3;
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("pose",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  out[0] = wrap_shared_ptr(SharedPose3(new gtsam::Pose3(obj->pose())),"gtsam.Pose3", false);
}

void gtsamPinholeCameraCal3_S2_print_2381(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPinholeCameraCal3_S2_project_2382(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("project",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->project(point))),"gtsam.Point2", false);
}

void gtsamPinholeCameraCal3_S2_projectSafe_2383(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("projectSafe",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  gtsam::Point3& pw = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  pair< gtsam::Point2, bool > pairResult = obj->projectSafe(pw);
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(pairResult.first)),"gtsam.Point2", false);
  out[1] = wrap< bool >(pairResult.second);
}

void gtsamPinholeCameraCal3_S2_range_2384(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  gtsam::Point3& point = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  out[0] = wrap< double >(obj->range(point));
}
void gtsamPinholeCameraCal3_S2_range_2385(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("range",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  gtsam::Pose3& pose = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  out[0] = wrap< double >(obj->range(pose));
}

void gtsamPinholeCameraCal3_S2_retract_2386(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("retract",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  Vector d = unwrap< Vector >(in[1]);
  out[0] = wrap< gtsam::PinholeCameraCal3_S2 >(obj->retract(d));
}

void gtsamPinholeCameraCal3_S2_string_serialize_2387(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PinholeCameraCal3_S2>(in[0], "ptr_gtsamPinholeCameraCal3_S2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamPinholeCameraCal3_S2_Dim_2388(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("gtsamPinholeCameraCal3_S2.Dim",nargout,nargin,0);
  out[0] = wrap< size_t >(gtsam::PinholeCameraCal3_S2::Dim());
}

void gtsamPinholeCameraCal3_S2_Level_2389(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("gtsamPinholeCameraCal3_S2.Level",nargout,nargin,3);
  gtsam::Cal3_S2& K = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[0], "ptr_gtsamCal3_S2");
  gtsam::Pose2& pose = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  double height = unwrap< double >(in[2]);
  out[0] = wrap< gtsam::PinholeCameraCal3_S2 >(gtsam::PinholeCameraCal3_S2::Level(K,pose,height));
}
void gtsamPinholeCameraCal3_S2_Level_2390(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("gtsamPinholeCameraCal3_S2.Level",nargout,nargin,2);
  gtsam::Pose2& pose = *unwrap_shared_ptr< gtsam::Pose2 >(in[0], "ptr_gtsamPose2");
  double height = unwrap< double >(in[1]);
  out[0] = wrap< gtsam::PinholeCameraCal3_S2 >(gtsam::PinholeCameraCal3_S2::Level(pose,height));
}

void gtsamPinholeCameraCal3_S2_Lookat_2391(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("gtsamPinholeCameraCal3_S2.Lookat",nargout,nargin,4);
  gtsam::Point3& eye = *unwrap_shared_ptr< gtsam::Point3 >(in[0], "ptr_gtsamPoint3");
  gtsam::Point3& target = *unwrap_shared_ptr< gtsam::Point3 >(in[1], "ptr_gtsamPoint3");
  gtsam::Point3& upVector = *unwrap_shared_ptr< gtsam::Point3 >(in[2], "ptr_gtsamPoint3");
  gtsam::Cal3_S2& K = *unwrap_shared_ptr< gtsam::Cal3_S2 >(in[3], "ptr_gtsamCal3_S2");
  out[0] = wrap< gtsam::PinholeCameraCal3_S2 >(gtsam::PinholeCameraCal3_S2::Lookat(eye,target,upVector,K));
}

void gtsamPinholeCameraCal3_S2_Project_2392(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("gtsamPinholeCameraCal3_S2.Project",nargout,nargin,1);
  gtsam::Point3& cameraPoint = *unwrap_shared_ptr< gtsam::Point3 >(in[0], "ptr_gtsamPoint3");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(gtsam::PinholeCameraCal3_S2::Project(cameraPoint))),"gtsam.Point2", false);
}

void gtsamPinholeCameraCal3_S2_string_deserialize_2393(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PinholeCameraCal3_S2> Shared;
  checkArguments("gtsamPinholeCameraCal3_S2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::PinholeCameraCal3_S2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.PinholeCameraCal3_S2", false);
}
void gtsamRangeFactorPosePoint2_collectorInsertAndMakeBase_2394(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorPosePoint2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorPosePoint2_upcastFromVoid_2395(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorPosePoint2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorPosePoint2_constructor_2396(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorPosePoint2(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorPosePoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorPosePoint2_deconstructor_2397(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("delete_gtsamRangeFactorPosePoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorPosePoint2::iterator item;
  item = collector_gtsamRangeFactorPosePoint2.find(self);
  if(item != collector_gtsamRangeFactorPosePoint2.end()) {
    delete self;
    collector_gtsamRangeFactorPosePoint2.erase(item);
  }
}

void gtsamRangeFactorPosePoint2_active_2398(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorPosePoint2_clone_2399(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorPosePoint2_dim_2400(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorPosePoint2_equals_2401(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorPosePoint2_error_2402(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorPosePoint2_get_noiseModel_2403(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPosePoint2_keys_2404(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorPosePoint2_linearize_2405(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorPosePoint2_noiseModel_2406(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPosePoint2_print_2407(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorPosePoint2_printKeys_2408(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorPosePoint2_size_2409(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorPosePoint2_unwhitenedError_2410(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorPosePoint2_whitenedError_2411(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint2>(in[0], "ptr_gtsamRangeFactorPosePoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorPosePoint3_collectorInsertAndMakeBase_2412(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorPosePoint3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorPosePoint3_upcastFromVoid_2413(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorPosePoint3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorPosePoint3_constructor_2414(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorPosePoint3(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorPosePoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorPosePoint3_deconstructor_2415(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("delete_gtsamRangeFactorPosePoint3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorPosePoint3::iterator item;
  item = collector_gtsamRangeFactorPosePoint3.find(self);
  if(item != collector_gtsamRangeFactorPosePoint3.end()) {
    delete self;
    collector_gtsamRangeFactorPosePoint3.erase(item);
  }
}

void gtsamRangeFactorPosePoint3_active_2416(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorPosePoint3_clone_2417(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorPosePoint3_dim_2418(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorPosePoint3_equals_2419(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorPosePoint3_error_2420(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorPosePoint3_get_noiseModel_2421(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPosePoint3_keys_2422(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorPosePoint3_linearize_2423(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorPosePoint3_noiseModel_2424(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPosePoint3_print_2425(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorPosePoint3_printKeys_2426(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorPosePoint3_size_2427(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorPosePoint3_unwhitenedError_2428(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorPosePoint3_whitenedError_2429(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPosePoint3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPosePoint3>(in[0], "ptr_gtsamRangeFactorPosePoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorPose2_collectorInsertAndMakeBase_2430(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorPose2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorPose2_upcastFromVoid_2431(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorPose2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorPose2_constructor_2432(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorPose2(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorPose2_deconstructor_2433(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("delete_gtsamRangeFactorPose2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorPose2::iterator item;
  item = collector_gtsamRangeFactorPose2.find(self);
  if(item != collector_gtsamRangeFactorPose2.end()) {
    delete self;
    collector_gtsamRangeFactorPose2.erase(item);
  }
}

void gtsamRangeFactorPose2_active_2434(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorPose2_clone_2435(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorPose2_dim_2436(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorPose2_equals_2437(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorPose2_error_2438(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorPose2_get_noiseModel_2439(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPose2_keys_2440(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorPose2_linearize_2441(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorPose2_noiseModel_2442(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPose2_print_2443(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorPose2_printKeys_2444(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorPose2_size_2445(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorPose2_unwhitenedError_2446(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorPose2_whitenedError_2447(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose2>(in[0], "ptr_gtsamRangeFactorPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorPose3_collectorInsertAndMakeBase_2448(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorPose3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorPose3_upcastFromVoid_2449(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorPose3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorPose3_constructor_2450(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorPose3(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorPose3_deconstructor_2451(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("delete_gtsamRangeFactorPose3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorPose3::iterator item;
  item = collector_gtsamRangeFactorPose3.find(self);
  if(item != collector_gtsamRangeFactorPose3.end()) {
    delete self;
    collector_gtsamRangeFactorPose3.erase(item);
  }
}

void gtsamRangeFactorPose3_active_2452(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorPose3_clone_2453(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorPose3_dim_2454(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorPose3_equals_2455(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorPose3_error_2456(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorPose3_get_noiseModel_2457(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPose3_keys_2458(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorPose3_linearize_2459(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorPose3_noiseModel_2460(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorPose3_print_2461(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorPose3_printKeys_2462(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorPose3_size_2463(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorPose3_unwhitenedError_2464(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorPose3_whitenedError_2465(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorPose3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorPose3>(in[0], "ptr_gtsamRangeFactorPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorCalibratedCameraPoint_collectorInsertAndMakeBase_2466(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorCalibratedCameraPoint.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorCalibratedCameraPoint_upcastFromVoid_2467(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorCalibratedCameraPoint>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorCalibratedCameraPoint_constructor_2468(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorCalibratedCameraPoint(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorCalibratedCameraPoint.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorCalibratedCameraPoint_deconstructor_2469(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("delete_gtsamRangeFactorCalibratedCameraPoint",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorCalibratedCameraPoint::iterator item;
  item = collector_gtsamRangeFactorCalibratedCameraPoint.find(self);
  if(item != collector_gtsamRangeFactorCalibratedCameraPoint.end()) {
    delete self;
    collector_gtsamRangeFactorCalibratedCameraPoint.erase(item);
  }
}

void gtsamRangeFactorCalibratedCameraPoint_active_2470(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorCalibratedCameraPoint_clone_2471(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorCalibratedCameraPoint_dim_2472(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorCalibratedCameraPoint_equals_2473(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorCalibratedCameraPoint_error_2474(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorCalibratedCameraPoint_get_noiseModel_2475(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorCalibratedCameraPoint_keys_2476(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorCalibratedCameraPoint_linearize_2477(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorCalibratedCameraPoint_noiseModel_2478(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorCalibratedCameraPoint_print_2479(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorCalibratedCameraPoint_printKeys_2480(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorCalibratedCameraPoint_size_2481(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorCalibratedCameraPoint_unwhitenedError_2482(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorCalibratedCameraPoint_whitenedError_2483(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCameraPoint> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCameraPoint>(in[0], "ptr_gtsamRangeFactorCalibratedCameraPoint");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorSimpleCameraPoint_collectorInsertAndMakeBase_2484(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorSimpleCameraPoint.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorSimpleCameraPoint_upcastFromVoid_2485(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorSimpleCameraPoint>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorSimpleCameraPoint_constructor_2486(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorSimpleCameraPoint(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorSimpleCameraPoint.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorSimpleCameraPoint_deconstructor_2487(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("delete_gtsamRangeFactorSimpleCameraPoint",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorSimpleCameraPoint::iterator item;
  item = collector_gtsamRangeFactorSimpleCameraPoint.find(self);
  if(item != collector_gtsamRangeFactorSimpleCameraPoint.end()) {
    delete self;
    collector_gtsamRangeFactorSimpleCameraPoint.erase(item);
  }
}

void gtsamRangeFactorSimpleCameraPoint_active_2488(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorSimpleCameraPoint_clone_2489(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorSimpleCameraPoint_dim_2490(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorSimpleCameraPoint_equals_2491(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorSimpleCameraPoint_error_2492(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorSimpleCameraPoint_get_noiseModel_2493(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorSimpleCameraPoint_keys_2494(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorSimpleCameraPoint_linearize_2495(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorSimpleCameraPoint_noiseModel_2496(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorSimpleCameraPoint_print_2497(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorSimpleCameraPoint_printKeys_2498(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorSimpleCameraPoint_size_2499(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorSimpleCameraPoint_unwhitenedError_2500(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorSimpleCameraPoint_whitenedError_2501(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCameraPoint> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCameraPoint>(in[0], "ptr_gtsamRangeFactorSimpleCameraPoint");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorCalibratedCamera_collectorInsertAndMakeBase_2502(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorCalibratedCamera.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorCalibratedCamera_upcastFromVoid_2503(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorCalibratedCamera>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorCalibratedCamera_constructor_2504(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorCalibratedCamera(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorCalibratedCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorCalibratedCamera_deconstructor_2505(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("delete_gtsamRangeFactorCalibratedCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorCalibratedCamera::iterator item;
  item = collector_gtsamRangeFactorCalibratedCamera.find(self);
  if(item != collector_gtsamRangeFactorCalibratedCamera.end()) {
    delete self;
    collector_gtsamRangeFactorCalibratedCamera.erase(item);
  }
}

void gtsamRangeFactorCalibratedCamera_active_2506(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorCalibratedCamera_clone_2507(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorCalibratedCamera_dim_2508(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorCalibratedCamera_equals_2509(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorCalibratedCamera_error_2510(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorCalibratedCamera_get_noiseModel_2511(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorCalibratedCamera_keys_2512(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorCalibratedCamera_linearize_2513(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorCalibratedCamera_noiseModel_2514(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorCalibratedCamera_print_2515(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorCalibratedCamera_printKeys_2516(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorCalibratedCamera_size_2517(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorCalibratedCamera_unwhitenedError_2518(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorCalibratedCamera_whitenedError_2519(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorCalibratedCamera> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorCalibratedCamera>(in[0], "ptr_gtsamRangeFactorCalibratedCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorSimpleCamera_collectorInsertAndMakeBase_2520(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorSimpleCamera.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorSimpleCamera_upcastFromVoid_2521(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorSimpleCamera>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorSimpleCamera_constructor_2522(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::RangeFactorSimpleCamera(key1,key2,measured,noiseModel));
  collector_gtsamRangeFactorSimpleCamera.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorSimpleCamera_deconstructor_2523(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("delete_gtsamRangeFactorSimpleCamera",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorSimpleCamera::iterator item;
  item = collector_gtsamRangeFactorSimpleCamera.find(self);
  if(item != collector_gtsamRangeFactorSimpleCamera.end()) {
    delete self;
    collector_gtsamRangeFactorSimpleCamera.erase(item);
  }
}

void gtsamRangeFactorSimpleCamera_active_2524(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorSimpleCamera_clone_2525(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorSimpleCamera_dim_2526(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorSimpleCamera_equals_2527(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorSimpleCamera_error_2528(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorSimpleCamera_get_noiseModel_2529(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorSimpleCamera_keys_2530(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorSimpleCamera_linearize_2531(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorSimpleCamera_noiseModel_2532(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorSimpleCamera_print_2533(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorSimpleCamera_printKeys_2534(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorSimpleCamera_size_2535(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorSimpleCamera_unwhitenedError_2536(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorSimpleCamera_whitenedError_2537(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorSimpleCamera> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorSimpleCamera>(in[0], "ptr_gtsamRangeFactorSimpleCamera");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorWithTransformPosePoint2_collectorInsertAndMakeBase_2538(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorWithTransformPosePoint2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPosePoint2_upcastFromVoid_2539(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorWithTransformPosePoint2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorWithTransformPosePoint2_constructor_2540(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  gtsam::Pose2& body_T_sensor = *unwrap_shared_ptr< gtsam::Pose2 >(in[4], "ptr_gtsamPose2");
  Shared *self = new Shared(new gtsam::RangeFactorWithTransformPosePoint2(key1,key2,measured,noiseModel,body_T_sensor));
  collector_gtsamRangeFactorWithTransformPosePoint2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPosePoint2_deconstructor_2541(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("delete_gtsamRangeFactorWithTransformPosePoint2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorWithTransformPosePoint2::iterator item;
  item = collector_gtsamRangeFactorWithTransformPosePoint2.find(self);
  if(item != collector_gtsamRangeFactorWithTransformPosePoint2.end()) {
    delete self;
    collector_gtsamRangeFactorWithTransformPosePoint2.erase(item);
  }
}

void gtsamRangeFactorWithTransformPosePoint2_active_2542(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorWithTransformPosePoint2_clone_2543(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorWithTransformPosePoint2_dim_2544(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorWithTransformPosePoint2_equals_2545(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorWithTransformPosePoint2_error_2546(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorWithTransformPosePoint2_get_noiseModel_2547(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPosePoint2_keys_2548(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorWithTransformPosePoint2_linearize_2549(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorWithTransformPosePoint2_noiseModel_2550(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPosePoint2_print_2551(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorWithTransformPosePoint2_printKeys_2552(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorWithTransformPosePoint2_size_2553(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorWithTransformPosePoint2_unwhitenedError_2554(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorWithTransformPosePoint2_whitenedError_2555(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint2>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorWithTransformPosePoint3_collectorInsertAndMakeBase_2556(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorWithTransformPosePoint3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPosePoint3_upcastFromVoid_2557(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorWithTransformPosePoint3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorWithTransformPosePoint3_constructor_2558(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  gtsam::Pose3& body_T_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[4], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::RangeFactorWithTransformPosePoint3(key1,key2,measured,noiseModel,body_T_sensor));
  collector_gtsamRangeFactorWithTransformPosePoint3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPosePoint3_deconstructor_2559(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("delete_gtsamRangeFactorWithTransformPosePoint3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorWithTransformPosePoint3::iterator item;
  item = collector_gtsamRangeFactorWithTransformPosePoint3.find(self);
  if(item != collector_gtsamRangeFactorWithTransformPosePoint3.end()) {
    delete self;
    collector_gtsamRangeFactorWithTransformPosePoint3.erase(item);
  }
}

void gtsamRangeFactorWithTransformPosePoint3_active_2560(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorWithTransformPosePoint3_clone_2561(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorWithTransformPosePoint3_dim_2562(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorWithTransformPosePoint3_equals_2563(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorWithTransformPosePoint3_error_2564(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorWithTransformPosePoint3_get_noiseModel_2565(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPosePoint3_keys_2566(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorWithTransformPosePoint3_linearize_2567(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorWithTransformPosePoint3_noiseModel_2568(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPosePoint3_print_2569(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorWithTransformPosePoint3_printKeys_2570(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorWithTransformPosePoint3_size_2571(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorWithTransformPosePoint3_unwhitenedError_2572(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorWithTransformPosePoint3_whitenedError_2573(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPosePoint3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPosePoint3>(in[0], "ptr_gtsamRangeFactorWithTransformPosePoint3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorWithTransformPose2_collectorInsertAndMakeBase_2574(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorWithTransformPose2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPose2_upcastFromVoid_2575(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorWithTransformPose2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorWithTransformPose2_constructor_2576(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  gtsam::Pose2& body_T_sensor = *unwrap_shared_ptr< gtsam::Pose2 >(in[4], "ptr_gtsamPose2");
  Shared *self = new Shared(new gtsam::RangeFactorWithTransformPose2(key1,key2,measured,noiseModel,body_T_sensor));
  collector_gtsamRangeFactorWithTransformPose2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPose2_deconstructor_2577(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("delete_gtsamRangeFactorWithTransformPose2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorWithTransformPose2::iterator item;
  item = collector_gtsamRangeFactorWithTransformPose2.find(self);
  if(item != collector_gtsamRangeFactorWithTransformPose2.end()) {
    delete self;
    collector_gtsamRangeFactorWithTransformPose2.erase(item);
  }
}

void gtsamRangeFactorWithTransformPose2_active_2578(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorWithTransformPose2_clone_2579(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorWithTransformPose2_dim_2580(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorWithTransformPose2_equals_2581(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorWithTransformPose2_error_2582(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorWithTransformPose2_get_noiseModel_2583(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPose2_keys_2584(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorWithTransformPose2_linearize_2585(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorWithTransformPose2_noiseModel_2586(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPose2_print_2587(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorWithTransformPose2_printKeys_2588(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorWithTransformPose2_size_2589(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorWithTransformPose2_unwhitenedError_2590(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorWithTransformPose2_whitenedError_2591(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose2>(in[0], "ptr_gtsamRangeFactorWithTransformPose2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamRangeFactorWithTransformPose3_collectorInsertAndMakeBase_2592(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamRangeFactorWithTransformPose3.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPose3_upcastFromVoid_2593(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::RangeFactorWithTransformPose3>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamRangeFactorWithTransformPose3_constructor_2594(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  double measured = unwrap< double >(in[2]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  gtsam::Pose3& body_T_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[4], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::RangeFactorWithTransformPose3(key1,key2,measured,noiseModel,body_T_sensor));
  collector_gtsamRangeFactorWithTransformPose3.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamRangeFactorWithTransformPose3_deconstructor_2595(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("delete_gtsamRangeFactorWithTransformPose3",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamRangeFactorWithTransformPose3::iterator item;
  item = collector_gtsamRangeFactorWithTransformPose3.find(self);
  if(item != collector_gtsamRangeFactorWithTransformPose3.end()) {
    delete self;
    collector_gtsamRangeFactorWithTransformPose3.erase(item);
  }
}

void gtsamRangeFactorWithTransformPose3_active_2596(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamRangeFactorWithTransformPose3_clone_2597(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamRangeFactorWithTransformPose3_dim_2598(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamRangeFactorWithTransformPose3_equals_2599(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamRangeFactorWithTransformPose3_error_2600(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamRangeFactorWithTransformPose3_get_noiseModel_2601(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPose3_keys_2602(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamRangeFactorWithTransformPose3_linearize_2603(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamRangeFactorWithTransformPose3_noiseModel_2604(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamRangeFactorWithTransformPose3_print_2605(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamRangeFactorWithTransformPose3_printKeys_2606(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamRangeFactorWithTransformPose3_size_2607(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamRangeFactorWithTransformPose3_unwhitenedError_2608(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamRangeFactorWithTransformPose3_whitenedError_2609(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::RangeFactorWithTransformPose3> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::RangeFactorWithTransformPose3>(in[0], "ptr_gtsamRangeFactorWithTransformPose3");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBearingFactor2D_collectorInsertAndMakeBase_2610(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBearingFactor2D.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBearingFactor2D_upcastFromVoid_2611(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BearingFactor2D>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBearingFactor2D_constructor_2612(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;

  size_t key1 = unwrap< size_t >(in[0]);
  size_t key2 = unwrap< size_t >(in[1]);
  gtsam::Rot2& measured = *unwrap_shared_ptr< gtsam::Rot2 >(in[2], "ptr_gtsamRot2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[3], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BearingFactor2D(key1,key2,measured,noiseModel));
  collector_gtsamBearingFactor2D.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBearingFactor2D_deconstructor_2613(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("delete_gtsamBearingFactor2D",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBearingFactor2D::iterator item;
  item = collector_gtsamBearingFactor2D.find(self);
  if(item != collector_gtsamBearingFactor2D.end()) {
    delete self;
    collector_gtsamBearingFactor2D.erase(item);
  }
}

void gtsamBearingFactor2D_active_2614(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBearingFactor2D_clone_2615(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBearingFactor2D_dim_2616(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBearingFactor2D_equals_2617(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBearingFactor2D_error_2618(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBearingFactor2D_get_noiseModel_2619(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBearingFactor2D_keys_2620(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBearingFactor2D_linearize_2621(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBearingFactor2D_noiseModel_2622(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBearingFactor2D_print_2623(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBearingFactor2D_printKeys_2624(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBearingFactor2D_size_2625(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBearingFactor2D_unwhitenedError_2626(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBearingFactor2D_whitenedError_2627(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBearingFactor2D_string_serialize_2628(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingFactor2D>(in[0], "ptr_gtsamBearingFactor2D");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBearingFactor2D_string_deserialize_2629(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingFactor2D> Shared;
  checkArguments("gtsamBearingFactor2D.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BearingFactor2D());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BearingFactor2D", false);
}
void gtsamBearingRangeFactor2D_collectorInsertAndMakeBase_2630(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamBearingRangeFactor2D.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamBearingRangeFactor2D_upcastFromVoid_2631(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::BearingRangeFactor2D>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamBearingRangeFactor2D_constructor_2632(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;

  size_t poseKey = unwrap< size_t >(in[0]);
  size_t pointKey = unwrap< size_t >(in[1]);
  gtsam::Rot2& measuredBearing = *unwrap_shared_ptr< gtsam::Rot2 >(in[2], "ptr_gtsamRot2");
  double measuredRange = unwrap< double >(in[3]);
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[4], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::BearingRangeFactor2D(poseKey,pointKey,measuredBearing,measuredRange,noiseModel));
  collector_gtsamBearingRangeFactor2D.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamBearingRangeFactor2D_deconstructor_2633(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("delete_gtsamBearingRangeFactor2D",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamBearingRangeFactor2D::iterator item;
  item = collector_gtsamBearingRangeFactor2D.find(self);
  if(item != collector_gtsamBearingRangeFactor2D.end()) {
    delete self;
    collector_gtsamBearingRangeFactor2D.erase(item);
  }
}

void gtsamBearingRangeFactor2D_active_2634(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamBearingRangeFactor2D_clone_2635(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamBearingRangeFactor2D_dim_2636(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamBearingRangeFactor2D_equals_2637(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamBearingRangeFactor2D_error_2638(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamBearingRangeFactor2D_get_noiseModel_2639(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBearingRangeFactor2D_keys_2640(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamBearingRangeFactor2D_linearize_2641(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamBearingRangeFactor2D_noiseModel_2642(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamBearingRangeFactor2D_print_2643(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamBearingRangeFactor2D_printKeys_2644(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamBearingRangeFactor2D_size_2645(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamBearingRangeFactor2D_unwhitenedError_2646(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamBearingRangeFactor2D_whitenedError_2647(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamBearingRangeFactor2D_string_serialize_2648(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::BearingRangeFactor2D>(in[0], "ptr_gtsamBearingRangeFactor2D");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamBearingRangeFactor2D_string_deserialize_2649(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::BearingRangeFactor2D> Shared;
  checkArguments("gtsamBearingRangeFactor2D.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::BearingRangeFactor2D());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.BearingRangeFactor2D", false);
}
void gtsamGenericProjectionFactorCal3_S2_collectorInsertAndMakeBase_2650(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGenericProjectionFactorCal3_S2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3_S2_upcastFromVoid_2651(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GenericProjectionFactorCal3_S2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGenericProjectionFactorCal3_S2_constructor_2652(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3_S2> k = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[4], "ptr_gtsamCal3_S2");
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3_S2(measured,noiseModel,poseKey,pointKey,k));
  collector_gtsamGenericProjectionFactorCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3_S2_constructor_2653(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3_S2> k = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[4], "ptr_gtsamCal3_S2");
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[5], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3_S2(measured,noiseModel,poseKey,pointKey,k,body_P_sensor));
  collector_gtsamGenericProjectionFactorCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3_S2_constructor_2654(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3_S2> k = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[4], "ptr_gtsamCal3_S2");
  bool throwCheirality = unwrap< bool >(in[5]);
  bool verboseCheirality = unwrap< bool >(in[6]);
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3_S2(measured,noiseModel,poseKey,pointKey,k,throwCheirality,verboseCheirality));
  collector_gtsamGenericProjectionFactorCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3_S2_constructor_2655(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3_S2> k = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[4], "ptr_gtsamCal3_S2");
  bool throwCheirality = unwrap< bool >(in[5]);
  bool verboseCheirality = unwrap< bool >(in[6]);
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[7], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3_S2(measured,noiseModel,poseKey,pointKey,k,throwCheirality,verboseCheirality,body_P_sensor));
  collector_gtsamGenericProjectionFactorCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3_S2_deconstructor_2656(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("delete_gtsamGenericProjectionFactorCal3_S2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGenericProjectionFactorCal3_S2::iterator item;
  item = collector_gtsamGenericProjectionFactorCal3_S2.find(self);
  if(item != collector_gtsamGenericProjectionFactorCal3_S2.end()) {
    delete self;
    collector_gtsamGenericProjectionFactorCal3_S2.erase(item);
  }
}

void gtsamGenericProjectionFactorCal3_S2_active_2657(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamGenericProjectionFactorCal3_S2_calibration_2658(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2> SharedCal3_S2;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("calibration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->calibration(),"gtsam.Cal3_S2", false);
}

void gtsamGenericProjectionFactorCal3_S2_clone_2659(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamGenericProjectionFactorCal3_S2_dim_2660(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamGenericProjectionFactorCal3_S2_equals_2661(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamGenericProjectionFactorCal3_S2_error_2662(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGenericProjectionFactorCal3_S2_get_noiseModel_2663(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGenericProjectionFactorCal3_S2_keys_2664(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGenericProjectionFactorCal3_S2_linearize_2665(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamGenericProjectionFactorCal3_S2_measured_2666(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->measured())),"gtsam.Point2", false);
}

void gtsamGenericProjectionFactorCal3_S2_noiseModel_2667(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGenericProjectionFactorCal3_S2_print_2668(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGenericProjectionFactorCal3_S2_printKeys_2669(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamGenericProjectionFactorCal3_S2_size_2670(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGenericProjectionFactorCal3_S2_throwCheirality_2671(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("throwCheirality",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap< bool >(obj->throwCheirality());
}

void gtsamGenericProjectionFactorCal3_S2_unwhitenedError_2672(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamGenericProjectionFactorCal3_S2_verboseCheirality_2673(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("verboseCheirality",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  out[0] = wrap< bool >(obj->verboseCheirality());
}

void gtsamGenericProjectionFactorCal3_S2_whitenedError_2674(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamGenericProjectionFactorCal3_S2_string_serialize_2675(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3_S2>(in[0], "ptr_gtsamGenericProjectionFactorCal3_S2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamGenericProjectionFactorCal3_S2_string_deserialize_2676(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3_S2> Shared;
  checkArguments("gtsamGenericProjectionFactorCal3_S2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::GenericProjectionFactorCal3_S2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.GenericProjectionFactorCal3_S2", false);
}
void gtsamGenericProjectionFactorCal3DS2_collectorInsertAndMakeBase_2677(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGenericProjectionFactorCal3DS2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3DS2_upcastFromVoid_2678(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GenericProjectionFactorCal3DS2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGenericProjectionFactorCal3DS2_constructor_2679(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3DS2> k = unwrap_shared_ptr< gtsam::Cal3DS2 >(in[4], "ptr_gtsamCal3DS2");
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3DS2(measured,noiseModel,poseKey,pointKey,k));
  collector_gtsamGenericProjectionFactorCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3DS2_constructor_2680(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3DS2> k = unwrap_shared_ptr< gtsam::Cal3DS2 >(in[4], "ptr_gtsamCal3DS2");
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[5], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3DS2(measured,noiseModel,poseKey,pointKey,k,body_P_sensor));
  collector_gtsamGenericProjectionFactorCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3DS2_constructor_2681(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3DS2> k = unwrap_shared_ptr< gtsam::Cal3DS2 >(in[4], "ptr_gtsamCal3DS2");
  bool throwCheirality = unwrap< bool >(in[5]);
  bool verboseCheirality = unwrap< bool >(in[6]);
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3DS2(measured,noiseModel,poseKey,pointKey,k,throwCheirality,verboseCheirality));
  collector_gtsamGenericProjectionFactorCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3DS2_constructor_2682(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t pointKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3DS2> k = unwrap_shared_ptr< gtsam::Cal3DS2 >(in[4], "ptr_gtsamCal3DS2");
  bool throwCheirality = unwrap< bool >(in[5]);
  bool verboseCheirality = unwrap< bool >(in[6]);
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[7], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::GenericProjectionFactorCal3DS2(measured,noiseModel,poseKey,pointKey,k,throwCheirality,verboseCheirality,body_P_sensor));
  collector_gtsamGenericProjectionFactorCal3DS2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericProjectionFactorCal3DS2_deconstructor_2683(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("delete_gtsamGenericProjectionFactorCal3DS2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGenericProjectionFactorCal3DS2::iterator item;
  item = collector_gtsamGenericProjectionFactorCal3DS2.find(self);
  if(item != collector_gtsamGenericProjectionFactorCal3DS2.end()) {
    delete self;
    collector_gtsamGenericProjectionFactorCal3DS2.erase(item);
  }
}

void gtsamGenericProjectionFactorCal3DS2_active_2684(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamGenericProjectionFactorCal3DS2_calibration_2685(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3DS2> SharedCal3DS2;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("calibration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap_shared_ptr(obj->calibration(),"gtsam.Cal3DS2", true);
}

void gtsamGenericProjectionFactorCal3DS2_clone_2686(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamGenericProjectionFactorCal3DS2_dim_2687(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamGenericProjectionFactorCal3DS2_equals_2688(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamGenericProjectionFactorCal3DS2_error_2689(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGenericProjectionFactorCal3DS2_get_noiseModel_2690(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGenericProjectionFactorCal3DS2_keys_2691(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGenericProjectionFactorCal3DS2_linearize_2692(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamGenericProjectionFactorCal3DS2_measured_2693(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->measured())),"gtsam.Point2", false);
}

void gtsamGenericProjectionFactorCal3DS2_noiseModel_2694(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGenericProjectionFactorCal3DS2_print_2695(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGenericProjectionFactorCal3DS2_printKeys_2696(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamGenericProjectionFactorCal3DS2_size_2697(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGenericProjectionFactorCal3DS2_throwCheirality_2698(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("throwCheirality",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap< bool >(obj->throwCheirality());
}

void gtsamGenericProjectionFactorCal3DS2_unwhitenedError_2699(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamGenericProjectionFactorCal3DS2_verboseCheirality_2700(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("verboseCheirality",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  out[0] = wrap< bool >(obj->verboseCheirality());
}

void gtsamGenericProjectionFactorCal3DS2_whitenedError_2701(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamGenericProjectionFactorCal3DS2_string_serialize_2702(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericProjectionFactorCal3DS2>(in[0], "ptr_gtsamGenericProjectionFactorCal3DS2");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamGenericProjectionFactorCal3DS2_string_deserialize_2703(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericProjectionFactorCal3DS2> Shared;
  checkArguments("gtsamGenericProjectionFactorCal3DS2.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::GenericProjectionFactorCal3DS2());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.GenericProjectionFactorCal3DS2", false);
}
void gtsamGeneralSFMFactorCal3_S2_collectorInsertAndMakeBase_2704(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGeneralSFMFactorCal3_S2.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGeneralSFMFactorCal3_S2_upcastFromVoid_2705(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GeneralSFMFactorCal3_S2>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGeneralSFMFactorCal3_S2_constructor_2706(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;

  gtsam::Point2& measured = *unwrap_shared_ptr< gtsam::Point2 >(in[0], "ptr_gtsamPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> model = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t cameraKey = unwrap< size_t >(in[2]);
  size_t landmarkKey = unwrap< size_t >(in[3]);
  Shared *self = new Shared(new gtsam::GeneralSFMFactorCal3_S2(measured,model,cameraKey,landmarkKey));
  collector_gtsamGeneralSFMFactorCal3_S2.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGeneralSFMFactorCal3_S2_deconstructor_2707(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("delete_gtsamGeneralSFMFactorCal3_S2",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGeneralSFMFactorCal3_S2::iterator item;
  item = collector_gtsamGeneralSFMFactorCal3_S2.find(self);
  if(item != collector_gtsamGeneralSFMFactorCal3_S2.end()) {
    delete self;
    collector_gtsamGeneralSFMFactorCal3_S2.erase(item);
  }
}

void gtsamGeneralSFMFactorCal3_S2_active_2708(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamGeneralSFMFactorCal3_S2_clone_2709(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamGeneralSFMFactorCal3_S2_dim_2710(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamGeneralSFMFactorCal3_S2_equals_2711(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamGeneralSFMFactorCal3_S2_error_2712(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGeneralSFMFactorCal3_S2_get_noiseModel_2713(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGeneralSFMFactorCal3_S2_keys_2714(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGeneralSFMFactorCal3_S2_linearize_2715(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamGeneralSFMFactorCal3_S2_measured_2716(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point2> SharedPoint2;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  out[0] = wrap_shared_ptr(SharedPoint2(new gtsam::Point2(obj->measured())),"gtsam.Point2", false);
}

void gtsamGeneralSFMFactorCal3_S2_noiseModel_2717(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGeneralSFMFactorCal3_S2_print_2718(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGeneralSFMFactorCal3_S2_printKeys_2719(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamGeneralSFMFactorCal3_S2_size_2720(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGeneralSFMFactorCal3_S2_unwhitenedError_2721(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamGeneralSFMFactorCal3_S2_whitenedError_2722(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GeneralSFMFactorCal3_S2> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GeneralSFMFactorCal3_S2>(in[0], "ptr_gtsamGeneralSFMFactorCal3_S2");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamSmartProjectionPose3Factor_collectorInsertAndMakeBase_2723(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamSmartProjectionPose3Factor.insert(self);

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamSmartProjectionPose3Factor_upcastFromVoid_2724(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::SmartProjectionPose3Factor>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamSmartProjectionPose3Factor_constructor_2725(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;

  boost::shared_ptr<gtsam::noiseModel::Base> noise = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[0], "ptr_gtsamnoiseModelBase");
  boost::shared_ptr<gtsam::Cal3_S2> K = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  Shared *self = new Shared(new gtsam::SmartProjectionPose3Factor(noise,K));
  collector_gtsamSmartProjectionPose3Factor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSmartProjectionPose3Factor_constructor_2726(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;

  boost::shared_ptr<gtsam::noiseModel::Base> noise = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[0], "ptr_gtsamnoiseModelBase");
  boost::shared_ptr<gtsam::Cal3_S2> K = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[2], "ptr_gtsamPose3");
  Shared *self = new Shared(new gtsam::SmartProjectionPose3Factor(noise,K,body_P_sensor));
  collector_gtsamSmartProjectionPose3Factor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSmartProjectionPose3Factor_constructor_2727(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;

  boost::shared_ptr<gtsam::noiseModel::Base> noise = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[0], "ptr_gtsamnoiseModelBase");
  boost::shared_ptr<gtsam::Cal3_S2> K = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[2], "ptr_gtsamPose3");
  gtsam::SmartProjectionParams& params = *unwrap_shared_ptr< gtsam::SmartProjectionParams >(in[3], "ptr_gtsamSmartProjectionParams");
  Shared *self = new Shared(new gtsam::SmartProjectionPose3Factor(noise,K,body_P_sensor,params));
  collector_gtsamSmartProjectionPose3Factor.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamSmartProjectionPose3Factor_deconstructor_2728(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("delete_gtsamSmartProjectionPose3Factor",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamSmartProjectionPose3Factor::iterator item;
  item = collector_gtsamSmartProjectionPose3Factor.find(self);
  if(item != collector_gtsamSmartProjectionPose3Factor.end()) {
    delete self;
    collector_gtsamSmartProjectionPose3Factor.erase(item);
  }
}

void gtsamSmartProjectionPose3Factor_active_2729(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamSmartProjectionPose3Factor_add_2730(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("add",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  gtsam::Point2& measured_i = *unwrap_shared_ptr< gtsam::Point2 >(in[1], "ptr_gtsamPoint2");
  size_t poseKey_i = unwrap< size_t >(in[2]);
  obj->add(measured_i,poseKey_i);
}

void gtsamSmartProjectionPose3Factor_clone_2731(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamSmartProjectionPose3Factor_dim_2732(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamSmartProjectionPose3Factor_equals_2733(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  gtsam::NonlinearFactor& other = *unwrap_shared_ptr< gtsam::NonlinearFactor >(in[1], "ptr_gtsamNonlinearFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamSmartProjectionPose3Factor_error_2734(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamSmartProjectionPose3Factor_keys_2735(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamSmartProjectionPose3Factor_linearize_2736(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamSmartProjectionPose3Factor_print_2737(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamSmartProjectionPose3Factor_printKeys_2738(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamSmartProjectionPose3Factor_size_2739(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::SmartProjectionPose3Factor> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::SmartProjectionPose3Factor>(in[0], "ptr_gtsamSmartProjectionPose3Factor");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGenericStereoFactor3D_collectorInsertAndMakeBase_2740(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamGenericStereoFactor3D.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamGenericStereoFactor3D_upcastFromVoid_2741(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::GenericStereoFactor3D>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamGenericStereoFactor3D_constructor_2742(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;

  gtsam::StereoPoint2& measured = *unwrap_shared_ptr< gtsam::StereoPoint2 >(in[0], "ptr_gtsamStereoPoint2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  size_t poseKey = unwrap< size_t >(in[2]);
  size_t landmarkKey = unwrap< size_t >(in[3]);
  boost::shared_ptr<gtsam::Cal3_S2Stereo> K = unwrap_shared_ptr< gtsam::Cal3_S2Stereo >(in[4], "ptr_gtsamCal3_S2Stereo");
  Shared *self = new Shared(new gtsam::GenericStereoFactor3D(measured,noiseModel,poseKey,landmarkKey,K));
  collector_gtsamGenericStereoFactor3D.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamGenericStereoFactor3D_deconstructor_2743(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("delete_gtsamGenericStereoFactor3D",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamGenericStereoFactor3D::iterator item;
  item = collector_gtsamGenericStereoFactor3D.find(self);
  if(item != collector_gtsamGenericStereoFactor3D.end()) {
    delete self;
    collector_gtsamGenericStereoFactor3D.erase(item);
  }
}

void gtsamGenericStereoFactor3D_active_2744(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamGenericStereoFactor3D_calibration_2745(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Cal3_S2Stereo> SharedCal3_S2Stereo;
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("calibration",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap_shared_ptr(obj->calibration(),"gtsam.Cal3_S2Stereo", false);
}

void gtsamGenericStereoFactor3D_clone_2746(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamGenericStereoFactor3D_dim_2747(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamGenericStereoFactor3D_equals_2748(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamGenericStereoFactor3D_error_2749(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamGenericStereoFactor3D_get_noiseModel_2750(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGenericStereoFactor3D_keys_2751(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamGenericStereoFactor3D_linearize_2752(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamGenericStereoFactor3D_measured_2753(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::StereoPoint2> SharedStereoPoint2;
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("measured",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap_shared_ptr(SharedStereoPoint2(new gtsam::StereoPoint2(obj->measured())),"gtsam.StereoPoint2", false);
}

void gtsamGenericStereoFactor3D_noiseModel_2754(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamGenericStereoFactor3D_print_2755(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamGenericStereoFactor3D_printKeys_2756(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamGenericStereoFactor3D_size_2757(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamGenericStereoFactor3D_unwhitenedError_2758(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamGenericStereoFactor3D_whitenedError_2759(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamGenericStereoFactor3D_string_serialize_2760(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("string_serialize",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::GenericStereoFactor3D>(in[0], "ptr_gtsamGenericStereoFactor3D");
  ostringstream out_archive_stream;
  boost::archive::text_oarchive out_archive(out_archive_stream);
  out_archive << *obj;
  out[0] = wrap< string >(out_archive_stream.str());
}
void gtsamGenericStereoFactor3D_string_deserialize_2761(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GenericStereoFactor3D> Shared;
  checkArguments("gtsamGenericStereoFactor3D.string_deserialize",nargout,nargin,1);
  string serialized = unwrap< string >(in[0]);
  istringstream in_archive_stream(serialized);
  boost::archive::text_iarchive in_archive(in_archive_stream);
  Shared output(new gtsam::GenericStereoFactor3D());
  in_archive >> *output;
  out[0] = wrap_shared_ptr(output,"gtsam.GenericStereoFactor3D", false);
}
void gtsamPoseTranslationPrior2D_collectorInsertAndMakeBase_2762(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPoseTranslationPrior2D.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPoseTranslationPrior2D_upcastFromVoid_2763(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PoseTranslationPrior2D>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPoseTranslationPrior2D_constructor_2764(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Pose2& pose_z = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PoseTranslationPrior2D(key,pose_z,noiseModel));
  collector_gtsamPoseTranslationPrior2D.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPoseTranslationPrior2D_deconstructor_2765(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("delete_gtsamPoseTranslationPrior2D",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPoseTranslationPrior2D::iterator item;
  item = collector_gtsamPoseTranslationPrior2D.find(self);
  if(item != collector_gtsamPoseTranslationPrior2D.end()) {
    delete self;
    collector_gtsamPoseTranslationPrior2D.erase(item);
  }
}

void gtsamPoseTranslationPrior2D_active_2766(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPoseTranslationPrior2D_clone_2767(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPoseTranslationPrior2D_dim_2768(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPoseTranslationPrior2D_equals_2769(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPoseTranslationPrior2D_error_2770(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPoseTranslationPrior2D_get_noiseModel_2771(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseTranslationPrior2D_keys_2772(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPoseTranslationPrior2D_linearize_2773(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPoseTranslationPrior2D_noiseModel_2774(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseTranslationPrior2D_print_2775(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPoseTranslationPrior2D_printKeys_2776(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPoseTranslationPrior2D_size_2777(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPoseTranslationPrior2D_unwhitenedError_2778(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPoseTranslationPrior2D_whitenedError_2779(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior2D> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior2D>(in[0], "ptr_gtsamPoseTranslationPrior2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPoseTranslationPrior3D_collectorInsertAndMakeBase_2780(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPoseTranslationPrior3D.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPoseTranslationPrior3D_upcastFromVoid_2781(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PoseTranslationPrior3D>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPoseTranslationPrior3D_constructor_2782(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Pose3& pose_z = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PoseTranslationPrior3D(key,pose_z,noiseModel));
  collector_gtsamPoseTranslationPrior3D.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPoseTranslationPrior3D_deconstructor_2783(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("delete_gtsamPoseTranslationPrior3D",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPoseTranslationPrior3D::iterator item;
  item = collector_gtsamPoseTranslationPrior3D.find(self);
  if(item != collector_gtsamPoseTranslationPrior3D.end()) {
    delete self;
    collector_gtsamPoseTranslationPrior3D.erase(item);
  }
}

void gtsamPoseTranslationPrior3D_active_2784(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPoseTranslationPrior3D_clone_2785(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPoseTranslationPrior3D_dim_2786(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPoseTranslationPrior3D_equals_2787(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPoseTranslationPrior3D_error_2788(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPoseTranslationPrior3D_get_noiseModel_2789(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseTranslationPrior3D_keys_2790(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPoseTranslationPrior3D_linearize_2791(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPoseTranslationPrior3D_noiseModel_2792(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseTranslationPrior3D_print_2793(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPoseTranslationPrior3D_printKeys_2794(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPoseTranslationPrior3D_size_2795(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPoseTranslationPrior3D_unwhitenedError_2796(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPoseTranslationPrior3D_whitenedError_2797(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseTranslationPrior3D> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseTranslationPrior3D>(in[0], "ptr_gtsamPoseTranslationPrior3D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPoseRotationPrior2D_collectorInsertAndMakeBase_2798(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPoseRotationPrior2D.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPoseRotationPrior2D_upcastFromVoid_2799(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PoseRotationPrior2D>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPoseRotationPrior2D_constructor_2800(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Pose2& pose_z = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PoseRotationPrior2D(key,pose_z,noiseModel));
  collector_gtsamPoseRotationPrior2D.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPoseRotationPrior2D_deconstructor_2801(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("delete_gtsamPoseRotationPrior2D",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPoseRotationPrior2D::iterator item;
  item = collector_gtsamPoseRotationPrior2D.find(self);
  if(item != collector_gtsamPoseRotationPrior2D.end()) {
    delete self;
    collector_gtsamPoseRotationPrior2D.erase(item);
  }
}

void gtsamPoseRotationPrior2D_active_2802(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPoseRotationPrior2D_clone_2803(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPoseRotationPrior2D_dim_2804(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPoseRotationPrior2D_equals_2805(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPoseRotationPrior2D_error_2806(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPoseRotationPrior2D_get_noiseModel_2807(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseRotationPrior2D_keys_2808(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPoseRotationPrior2D_linearize_2809(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPoseRotationPrior2D_noiseModel_2810(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseRotationPrior2D_print_2811(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPoseRotationPrior2D_printKeys_2812(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPoseRotationPrior2D_size_2813(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPoseRotationPrior2D_unwhitenedError_2814(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPoseRotationPrior2D_whitenedError_2815(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior2D> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior2D>(in[0], "ptr_gtsamPoseRotationPrior2D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPoseRotationPrior3D_collectorInsertAndMakeBase_2816(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;

  Shared *self = *reinterpret_cast<Shared**> (mxGetData(in[0]));
  collector_gtsamPoseRotationPrior3D.insert(self);

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[0])) = new SharedBase(*self);
}

void gtsamPoseRotationPrior3D_upcastFromVoid_2817(int nargout, mxArray *out[], int nargin, const mxArray *in[]) {
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  boost::shared_ptr<void> *asVoid = *reinterpret_cast<boost::shared_ptr<void>**> (mxGetData(in[0]));
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  Shared *self = new Shared(boost::static_pointer_cast<gtsam::PoseRotationPrior3D>(*asVoid));
  *reinterpret_cast<Shared**>(mxGetData(out[0])) = self;
}

void gtsamPoseRotationPrior3D_constructor_2818(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mexAtExit(&_deleteAllObjects);
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;

  size_t key = unwrap< size_t >(in[0]);
  gtsam::Pose3& pose_z = *unwrap_shared_ptr< gtsam::Pose3 >(in[1], "ptr_gtsamPose3");
  boost::shared_ptr<gtsam::noiseModel::Base> noiseModel = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[2], "ptr_gtsamnoiseModelBase");
  Shared *self = new Shared(new gtsam::PoseRotationPrior3D(key,pose_z,noiseModel));
  collector_gtsamPoseRotationPrior3D.insert(self);
  out[0] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<Shared**> (mxGetData(out[0])) = self;

  typedef boost::shared_ptr<gtsam::NoiseModelFactor> SharedBase;
  out[1] = mxCreateNumericMatrix(1, 1, mxUINT32OR64_CLASS, mxREAL);
  *reinterpret_cast<SharedBase**>(mxGetData(out[1])) = new SharedBase(*self);
}

void gtsamPoseRotationPrior3D_deconstructor_2819(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("delete_gtsamPoseRotationPrior3D",nargout,nargin,1);
  Shared *self = *reinterpret_cast<Shared**>(mxGetData(in[0]));
  Collector_gtsamPoseRotationPrior3D::iterator item;
  item = collector_gtsamPoseRotationPrior3D.find(self);
  if(item != collector_gtsamPoseRotationPrior3D.end()) {
    delete self;
    collector_gtsamPoseRotationPrior3D.erase(item);
  }
}

void gtsamPoseRotationPrior3D_active_2820(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("active",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< bool >(obj->active(c));
}

void gtsamPoseRotationPrior3D_clone_2821(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactor> SharedNonlinearFactor;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("clone",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  out[0] = wrap_shared_ptr(obj->clone(),"gtsam.NonlinearFactor", true);
}

void gtsamPoseRotationPrior3D_dim_2822(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("dim",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  out[0] = wrap< size_t >(obj->dim());
}

void gtsamPoseRotationPrior3D_equals_2823(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("equals",nargout,nargin-1,2);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  gtsam::NoiseModelFactor& other = *unwrap_shared_ptr< gtsam::NoiseModelFactor >(in[1], "ptr_gtsamNoiseModelFactor");
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(obj->equals(other,tol));
}

void gtsamPoseRotationPrior3D_error_2824(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("error",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< double >(obj->error(c));
}

void gtsamPoseRotationPrior3D_get_noiseModel_2825(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("get_noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  out[0] = wrap_shared_ptr(obj->get_noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseRotationPrior3D_keys_2826(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("keys",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(obj->keys())),"gtsam.KeyVector", false);
}

void gtsamPoseRotationPrior3D_linearize_2827(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::GaussianFactor> SharedGaussianFactor;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("linearize",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  gtsam::Values& c = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(obj->linearize(c),"gtsam.GaussianFactor", true);
}

void gtsamPoseRotationPrior3D_noiseModel_2828(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::noiseModel::Base> SharedBase;
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("noiseModel",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  out[0] = wrap_shared_ptr(obj->noiseModel(),"gtsam.noiseModel.Base", true);
}

void gtsamPoseRotationPrior3D_print_2829(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("print",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  string s = unwrap< string >(in[1]);
  obj->print(s);
}

void gtsamPoseRotationPrior3D_printKeys_2830(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("printKeys",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  string s = unwrap< string >(in[1]);
  obj->printKeys(s);
}

void gtsamPoseRotationPrior3D_size_2831(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("size",nargout,nargin-1,0);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  out[0] = wrap< size_t >(obj->size());
}

void gtsamPoseRotationPrior3D_unwhitenedError_2832(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("unwhitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->unwhitenedError(x));
}

void gtsamPoseRotationPrior3D_whitenedError_2833(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::PoseRotationPrior3D> Shared;
  checkArguments("whitenedError",nargout,nargin-1,1);
  Shared obj = unwrap_shared_ptr<gtsam::PoseRotationPrior3D>(in[0], "ptr_gtsamPoseRotationPrior3D");
  gtsam::Values& x = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Vector >(obj->whitenedError(x));
}

void gtsamPrintKeyList_2834(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamPrintKeyList",nargout,nargin,1);
  gtsam::KeyList& keys = *unwrap_shared_ptr< gtsam::KeyList >(in[0], "ptr_gtsamKeyList");
gtsam::PrintKeyList(keys);
}
void gtsamPrintKeyList_2835(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamPrintKeyList",nargout,nargin,2);
  gtsam::KeyList& keys = *unwrap_shared_ptr< gtsam::KeyList >(in[0], "ptr_gtsamKeyList");
  string s = unwrap< string >(in[1]);
gtsam::PrintKeyList(keys,s);
}
void gtsamPrintKeySet_2836(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamPrintKeySet",nargout,nargin,1);
  gtsam::KeySet& keys = *unwrap_shared_ptr< gtsam::KeySet >(in[0], "ptr_gtsamKeySet");
gtsam::PrintKeySet(keys);
}
void gtsamPrintKeySet_2837(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamPrintKeySet",nargout,nargin,2);
  gtsam::KeySet& keys = *unwrap_shared_ptr< gtsam::KeySet >(in[0], "ptr_gtsamKeySet");
  string s = unwrap< string >(in[1]);
gtsam::PrintKeySet(keys,s);
}
void gtsamPrintKeyVector_2838(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamPrintKeyVector",nargout,nargin,1);
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[0], "ptr_gtsamKeyVector");
gtsam::PrintKeyVector(keys);
}
void gtsamPrintKeyVector_2839(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamPrintKeyVector",nargout,nargin,2);
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[0], "ptr_gtsamKeyVector");
  string s = unwrap< string >(in[1]);
gtsam::PrintKeyVector(keys,s);
}
void gtsamutilitiesallPose3s_2840(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamutilitiesallPose3s",nargout,nargin,1);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(gtsam::utilities::allPose3s(values))),"gtsam.Values", false);
}
void gtsamcheckConvergence_2841(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamcheckConvergence",nargout,nargin,5);
  double relativeErrorTreshold = unwrap< double >(in[0]);
  double absoluteErrorTreshold = unwrap< double >(in[1]);
  double errorThreshold = unwrap< double >(in[2]);
  double currentError = unwrap< double >(in[3]);
  double newError = unwrap< double >(in[4]);
  out[0] = wrap< bool >(gtsam::checkConvergence(relativeErrorTreshold,absoluteErrorTreshold,errorThreshold,currentError,newError));
}
void gtsamutilitiescreateKeyList_2842(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> SharedKeyList;
  checkArguments("gtsamutilitiescreateKeyList",nargout,nargin,1);
  Vector I = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedKeyList(new gtsam::KeyList(gtsam::utilities::createKeyList(I))),"gtsam.KeyList", false);
}
void gtsamutilitiescreateKeyList_2843(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyList> SharedKeyList;
  checkArguments("gtsamutilitiescreateKeyList",nargout,nargin,2);
  string s = unwrap< string >(in[0]);
  Vector I = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedKeyList(new gtsam::KeyList(gtsam::utilities::createKeyList(s,I))),"gtsam.KeyList", false);
}
void gtsamutilitiescreateKeySet_2844(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> SharedKeySet;
  checkArguments("gtsamutilitiescreateKeySet",nargout,nargin,1);
  Vector I = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedKeySet(new gtsam::KeySet(gtsam::utilities::createKeySet(I))),"gtsam.KeySet", false);
}
void gtsamutilitiescreateKeySet_2845(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeySet> SharedKeySet;
  checkArguments("gtsamutilitiescreateKeySet",nargout,nargin,2);
  string s = unwrap< string >(in[0]);
  Vector I = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedKeySet(new gtsam::KeySet(gtsam::utilities::createKeySet(s,I))),"gtsam.KeySet", false);
}
void gtsamutilitiescreateKeyVector_2846(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  checkArguments("gtsamutilitiescreateKeyVector",nargout,nargin,1);
  Vector I = unwrap< Vector >(in[0]);
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(gtsam::utilities::createKeyVector(I))),"gtsam.KeyVector", false);
}
void gtsamutilitiescreateKeyVector_2847(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::KeyVector> SharedKeyVector;
  checkArguments("gtsamutilitiescreateKeyVector",nargout,nargin,2);
  string s = unwrap< string >(in[0]);
  Vector I = unwrap< Vector >(in[1]);
  out[0] = wrap_shared_ptr(SharedKeyVector(new gtsam::KeyVector(gtsam::utilities::createKeyVector(s,I))),"gtsam.KeyVector", false);
}
void gtsamutilitiesextractPoint2_2848(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesextractPoint2",nargout,nargin,1);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  out[0] = wrap< Matrix >(gtsam::utilities::extractPoint2(values));
}
void gtsamutilitiesextractPoint3_2849(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesextractPoint3",nargout,nargin,1);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  out[0] = wrap< Matrix >(gtsam::utilities::extractPoint3(values));
}
void gtsamutilitiesextractPose2_2850(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesextractPose2",nargout,nargin,1);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  out[0] = wrap< Matrix >(gtsam::utilities::extractPose2(values));
}
void gtsamutilitiesextractPose3_2851(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesextractPose3",nargout,nargin,1);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  out[0] = wrap< Matrix >(gtsam::utilities::extractPose3(values));
}
void gtsamutilitiesinsertBackprojections_2852(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesinsertBackprojections",nargout,nargin,5);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  gtsam::SimpleCamera& c = *unwrap_shared_ptr< gtsam::SimpleCamera >(in[1], "ptr_gtsamSimpleCamera");
  Vector J = unwrap< Vector >(in[2]);
  Matrix Z = unwrap< Matrix >(in[3]);
  double depth = unwrap< double >(in[4]);
gtsam::utilities::insertBackprojections(values,c,J,Z,depth);
}
void gtsamutilitiesinsertProjectionFactors_2853(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesinsertProjectionFactors",nargout,nargin,6);
  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  size_t i = unwrap< size_t >(in[1]);
  Vector J = unwrap< Vector >(in[2]);
  Matrix Z = unwrap< Matrix >(in[3]);
  boost::shared_ptr<gtsam::noiseModel::Base> model = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[4], "ptr_gtsamnoiseModelBase");
  boost::shared_ptr<gtsam::Cal3_S2> K = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[5], "ptr_gtsamCal3_S2");
gtsam::utilities::insertProjectionFactors(graph,i,J,Z,model,K);
}
void gtsamutilitiesinsertProjectionFactors_2854(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesinsertProjectionFactors",nargout,nargin,7);
  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  size_t i = unwrap< size_t >(in[1]);
  Vector J = unwrap< Vector >(in[2]);
  Matrix Z = unwrap< Matrix >(in[3]);
  boost::shared_ptr<gtsam::noiseModel::Base> model = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[4], "ptr_gtsamnoiseModelBase");
  boost::shared_ptr<gtsam::Cal3_S2> K = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[5], "ptr_gtsamCal3_S2");
  gtsam::Pose3& body_P_sensor = *unwrap_shared_ptr< gtsam::Pose3 >(in[6], "ptr_gtsamPose3");
gtsam::utilities::insertProjectionFactors(graph,i,J,Z,model,K,body_P_sensor);
}
void gtsamlinear_independent_2855(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamlinear_independent",nargout,nargin,3);
  Matrix A = unwrap< Matrix >(in[0]);
  Matrix B = unwrap< Matrix >(in[1]);
  double tol = unwrap< double >(in[2]);
  out[0] = wrap< bool >(gtsam::linear_independent(A,B,tol));
}
void gtsamload2D_2856(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamload2D",nargout,nargin,5);
  string filename = unwrap< string >(in[0]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[1], "ptr_gtsamnoiseModelDiagonal");
  int maxID = unwrap< int >(in[2]);
  bool addNoise = unwrap< bool >(in[3]);
  bool smart = unwrap< bool >(in[4]);
  pair< SharedNonlinearFactorGraph, SharedValues > pairResult = gtsam::load2D(filename,model,maxID,addNoise,smart);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.NonlinearFactorGraph", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.Values", false);
}
void gtsamload2D_2857(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamload2D",nargout,nargin,4);
  string filename = unwrap< string >(in[0]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[1], "ptr_gtsamnoiseModelDiagonal");
  int maxID = unwrap< int >(in[2]);
  bool addNoise = unwrap< bool >(in[3]);
  pair< SharedNonlinearFactorGraph, SharedValues > pairResult = gtsam::load2D(filename,model,maxID,addNoise);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.NonlinearFactorGraph", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.Values", false);
}
void gtsamload2D_2858(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamload2D",nargout,nargin,3);
  string filename = unwrap< string >(in[0]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[1], "ptr_gtsamnoiseModelDiagonal");
  int maxID = unwrap< int >(in[2]);
  pair< SharedNonlinearFactorGraph, SharedValues > pairResult = gtsam::load2D(filename,model,maxID);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.NonlinearFactorGraph", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.Values", false);
}
void gtsamload2D_2859(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamload2D",nargout,nargin,2);
  string filename = unwrap< string >(in[0]);
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[1], "ptr_gtsamnoiseModelDiagonal");
  pair< SharedNonlinearFactorGraph, SharedValues > pairResult = gtsam::load2D(filename,model);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.NonlinearFactorGraph", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.Values", false);
}
void gtsamload2D_2860(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamload2D",nargout,nargin,1);
  string filename = unwrap< string >(in[0]);
  pair< SharedNonlinearFactorGraph, SharedValues > pairResult = gtsam::load2D(filename);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.NonlinearFactorGraph", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.Values", false);
}
void gtsamload2D_robust_2861(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamload2D_robust",nargout,nargin,2);
  string filename = unwrap< string >(in[0]);
  boost::shared_ptr<gtsam::noiseModel::Base> model = unwrap_shared_ptr< gtsam::noiseModel::Base >(in[1], "ptr_gtsamnoiseModelBase");
  pair< SharedNonlinearFactorGraph, SharedValues > pairResult = gtsam::load2D_robust(filename,model);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.NonlinearFactorGraph", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.Values", false);
}
void gtsamutilitieslocalToWorld_2862(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamutilitieslocalToWorld",nargout,nargin,2);
  gtsam::Values& local = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  gtsam::Pose2& base = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(gtsam::utilities::localToWorld(local,base))),"gtsam.Values", false);
}
void gtsamutilitieslocalToWorld_2863(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamutilitieslocalToWorld",nargout,nargin,3);
  gtsam::Values& local = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  gtsam::Pose2& base = *unwrap_shared_ptr< gtsam::Pose2 >(in[1], "ptr_gtsamPose2");
  gtsam::KeyVector& keys = *unwrap_shared_ptr< gtsam::KeyVector >(in[2], "ptr_gtsamKeyVector");
  out[0] = wrap_shared_ptr(SharedValues(new gtsam::Values(gtsam::utilities::localToWorld(local,base,keys))),"gtsam.Values", false);
}
void gtsammrsymbol_2864(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsammrsymbol",nargout,nargin,3);
  unsigned char c = unwrap< unsigned char >(in[0]);
  unsigned char label = unwrap< unsigned char >(in[1]);
  size_t j = unwrap< size_t >(in[2]);
  out[0] = wrap< size_t >(gtsam::mrsymbol(c,label,j));
}
void gtsammrsymbolChr_2865(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsammrsymbolChr",nargout,nargin,1);
  size_t key = unwrap< size_t >(in[0]);
  out[0] = wrap< unsigned char >(gtsam::mrsymbolChr(key));
}
void gtsammrsymbolIndex_2866(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsammrsymbolIndex",nargout,nargin,1);
  size_t key = unwrap< size_t >(in[0]);
  out[0] = wrap< size_t >(gtsam::mrsymbolIndex(key));
}
void gtsammrsymbolLabel_2867(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsammrsymbolLabel",nargout,nargin,1);
  size_t key = unwrap< size_t >(in[0]);
  out[0] = wrap< unsigned char >(gtsam::mrsymbolLabel(key));
}
void gtsamutilitiesperturbPoint2_2868(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesperturbPoint2",nargout,nargin,3);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  double sigma = unwrap< double >(in[1]);
  int seed = unwrap< int >(in[2]);
gtsam::utilities::perturbPoint2(values,sigma,seed);
}
void gtsamutilitiesperturbPoint3_2869(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesperturbPoint3",nargout,nargin,3);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  double sigma = unwrap< double >(in[1]);
  int seed = unwrap< int >(in[2]);
gtsam::utilities::perturbPoint3(values,sigma,seed);
}
void gtsamutilitiesperturbPose2_2870(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesperturbPose2",nargout,nargin,4);
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[0], "ptr_gtsamValues");
  double sigmaT = unwrap< double >(in[1]);
  double sigmaR = unwrap< double >(in[2]);
  int seed = unwrap< int >(in[3]);
gtsam::utilities::perturbPose2(values,sigmaT,sigmaR,seed);
}
void gtsamreadG2o_2871(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::NonlinearFactorGraph> SharedNonlinearFactorGraph;
  typedef boost::shared_ptr<gtsam::Values> SharedValues;
  checkArguments("gtsamreadG2o",nargout,nargin,1);
  string filename = unwrap< string >(in[0]);
  pair< SharedNonlinearFactorGraph, SharedValues > pairResult = gtsam::readG2o(filename);
  out[0] = wrap_shared_ptr(pairResult.first,"gtsam.NonlinearFactorGraph", false);
  out[1] = wrap_shared_ptr(pairResult.second,"gtsam.Values", false);
}
void gtsamutilitiesreprojectionErrors_2872(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamutilitiesreprojectionErrors",nargout,nargin,2);
  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& values = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  out[0] = wrap< Matrix >(gtsam::utilities::reprojectionErrors(graph,values));
}
void gtsamsave2D_2873(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamsave2D",nargout,nargin,4);
  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& config = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  boost::shared_ptr<gtsam::noiseModel::Diagonal> model = unwrap_shared_ptr< gtsam::noiseModel::Diagonal >(in[2], "ptr_gtsamnoiseModelDiagonal");
  string filename = unwrap< string >(in[3]);
gtsam::save2D(graph,config,model,filename);
}
void gtsamsymbol_2874(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamsymbol",nargout,nargin,2);
  char chr = unwrap< char >(in[0]);
  size_t index = unwrap< size_t >(in[1]);
  out[0] = wrap< size_t >(gtsam::symbol(chr,index));
}
void gtsamsymbolChr_2875(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamsymbolChr",nargout,nargin,1);
  size_t key = unwrap< size_t >(in[0]);
  out[0] = wrap< char >(gtsam::symbolChr(key));
}
void gtsamsymbolIndex_2876(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamsymbolIndex",nargout,nargin,1);
  size_t key = unwrap< size_t >(in[0]);
  out[0] = wrap< size_t >(gtsam::symbolIndex(key));
}
void gtsamtriangulatePoint3_2877(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  checkArguments("gtsamtriangulatePoint3",nargout,nargin,5);
  gtsam::Pose3Vector& poses = *unwrap_shared_ptr< gtsam::Pose3Vector >(in[0], "ptr_gtsamPose3Vector");
  boost::shared_ptr<gtsam::Cal3_S2> sharedCal = unwrap_shared_ptr< gtsam::Cal3_S2 >(in[1], "ptr_gtsamCal3_S2");
  gtsam::Point2Vector& measurements = *unwrap_shared_ptr< gtsam::Point2Vector >(in[2], "ptr_gtsamPoint2Vector");
  double rank_tol = unwrap< double >(in[3]);
  bool optimize = unwrap< bool >(in[4]);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(gtsam::triangulatePoint3(poses,sharedCal,measurements,rank_tol,optimize))),"gtsam.Point3", false);
}
void gtsamtriangulatePoint3_2878(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  typedef boost::shared_ptr<gtsam::Point3> SharedPoint3;
  checkArguments("gtsamtriangulatePoint3",nargout,nargin,5);
  gtsam::Pose3Vector& poses = *unwrap_shared_ptr< gtsam::Pose3Vector >(in[0], "ptr_gtsamPose3Vector");
  boost::shared_ptr<gtsam::Cal3Bundler> sharedCal = unwrap_shared_ptr< gtsam::Cal3Bundler >(in[1], "ptr_gtsamCal3Bundler");
  gtsam::Point2Vector& measurements = *unwrap_shared_ptr< gtsam::Point2Vector >(in[2], "ptr_gtsamPoint2Vector");
  double rank_tol = unwrap< double >(in[3]);
  bool optimize = unwrap< bool >(in[4]);
  out[0] = wrap_shared_ptr(SharedPoint3(new gtsam::Point3(gtsam::triangulatePoint3(poses,sharedCal,measurements,rank_tol,optimize))),"gtsam.Point3", false);
}
void gtsamwriteG2o_2879(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  checkArguments("gtsamwriteG2o",nargout,nargin,3);
  gtsam::NonlinearFactorGraph& graph = *unwrap_shared_ptr< gtsam::NonlinearFactorGraph >(in[0], "ptr_gtsamNonlinearFactorGraph");
  gtsam::Values& estimate = *unwrap_shared_ptr< gtsam::Values >(in[1], "ptr_gtsamValues");
  string filename = unwrap< string >(in[2]);
gtsam::writeG2o(graph,estimate,filename);
}

void mexFunction(int nargout, mxArray *out[], int nargin, const mxArray *in[])
{
  mstream mout;
  std::streambuf *outbuf = std::cout.rdbuf(&mout);

  _gtsam_RTTIRegister();

  int id = unwrap<int>(in[0]);

  try {
    switch(id) {
    case 0:
      gtsamKeyList_collectorInsertAndMakeBase_0(nargout, out, nargin-1, in+1);
      break;
    case 1:
      gtsamKeyList_constructor_1(nargout, out, nargin-1, in+1);
      break;
    case 2:
      gtsamKeyList_constructor_2(nargout, out, nargin-1, in+1);
      break;
    case 3:
      gtsamKeyList_deconstructor_3(nargout, out, nargin-1, in+1);
      break;
    case 4:
      gtsamKeyList_back_4(nargout, out, nargin-1, in+1);
      break;
    case 5:
      gtsamKeyList_clear_5(nargout, out, nargin-1, in+1);
      break;
    case 6:
      gtsamKeyList_empty_6(nargout, out, nargin-1, in+1);
      break;
    case 7:
      gtsamKeyList_front_7(nargout, out, nargin-1, in+1);
      break;
    case 8:
      gtsamKeyList_pop_back_8(nargout, out, nargin-1, in+1);
      break;
    case 9:
      gtsamKeyList_pop_front_9(nargout, out, nargin-1, in+1);
      break;
    case 10:
      gtsamKeyList_push_back_10(nargout, out, nargin-1, in+1);
      break;
    case 11:
      gtsamKeyList_push_front_11(nargout, out, nargin-1, in+1);
      break;
    case 12:
      gtsamKeyList_remove_12(nargout, out, nargin-1, in+1);
      break;
    case 13:
      gtsamKeyList_size_13(nargout, out, nargin-1, in+1);
      break;
    case 14:
      gtsamKeyList_sort_14(nargout, out, nargin-1, in+1);
      break;
    case 15:
      gtsamKeyList_string_serialize_15(nargout, out, nargin-1, in+1);
      break;
    case 16:
      gtsamKeyList_string_deserialize_16(nargout, out, nargin-1, in+1);
      break;
    case 17:
      gtsamKeySet_collectorInsertAndMakeBase_17(nargout, out, nargin-1, in+1);
      break;
    case 18:
      gtsamKeySet_constructor_18(nargout, out, nargin-1, in+1);
      break;
    case 19:
      gtsamKeySet_constructor_19(nargout, out, nargin-1, in+1);
      break;
    case 20:
      gtsamKeySet_constructor_20(nargout, out, nargin-1, in+1);
      break;
    case 21:
      gtsamKeySet_constructor_21(nargout, out, nargin-1, in+1);
      break;
    case 22:
      gtsamKeySet_deconstructor_22(nargout, out, nargin-1, in+1);
      break;
    case 23:
      gtsamKeySet_clear_23(nargout, out, nargin-1, in+1);
      break;
    case 24:
      gtsamKeySet_count_24(nargout, out, nargin-1, in+1);
      break;
    case 25:
      gtsamKeySet_empty_25(nargout, out, nargin-1, in+1);
      break;
    case 26:
      gtsamKeySet_equals_26(nargout, out, nargin-1, in+1);
      break;
    case 27:
      gtsamKeySet_erase_27(nargout, out, nargin-1, in+1);
      break;
    case 28:
      gtsamKeySet_insert_28(nargout, out, nargin-1, in+1);
      break;
    case 29:
      gtsamKeySet_merge_29(nargout, out, nargin-1, in+1);
      break;
    case 30:
      gtsamKeySet_print_30(nargout, out, nargin-1, in+1);
      break;
    case 31:
      gtsamKeySet_size_31(nargout, out, nargin-1, in+1);
      break;
    case 32:
      gtsamKeySet_string_serialize_32(nargout, out, nargin-1, in+1);
      break;
    case 33:
      gtsamKeySet_string_deserialize_33(nargout, out, nargin-1, in+1);
      break;
    case 34:
      gtsamKeyVector_collectorInsertAndMakeBase_34(nargout, out, nargin-1, in+1);
      break;
    case 35:
      gtsamKeyVector_constructor_35(nargout, out, nargin-1, in+1);
      break;
    case 36:
      gtsamKeyVector_constructor_36(nargout, out, nargin-1, in+1);
      break;
    case 37:
      gtsamKeyVector_deconstructor_37(nargout, out, nargin-1, in+1);
      break;
    case 38:
      gtsamKeyVector_at_38(nargout, out, nargin-1, in+1);
      break;
    case 39:
      gtsamKeyVector_back_39(nargout, out, nargin-1, in+1);
      break;
    case 40:
      gtsamKeyVector_clear_40(nargout, out, nargin-1, in+1);
      break;
    case 41:
      gtsamKeyVector_empty_41(nargout, out, nargin-1, in+1);
      break;
    case 42:
      gtsamKeyVector_front_42(nargout, out, nargin-1, in+1);
      break;
    case 43:
      gtsamKeyVector_push_back_43(nargout, out, nargin-1, in+1);
      break;
    case 44:
      gtsamKeyVector_size_44(nargout, out, nargin-1, in+1);
      break;
    case 45:
      gtsamKeyVector_string_serialize_45(nargout, out, nargin-1, in+1);
      break;
    case 46:
      gtsamKeyVector_string_deserialize_46(nargout, out, nargin-1, in+1);
      break;
    case 47:
      gtsamKeyGroupMap_collectorInsertAndMakeBase_47(nargout, out, nargin-1, in+1);
      break;
    case 48:
      gtsamKeyGroupMap_constructor_48(nargout, out, nargin-1, in+1);
      break;
    case 49:
      gtsamKeyGroupMap_deconstructor_49(nargout, out, nargin-1, in+1);
      break;
    case 50:
      gtsamKeyGroupMap_at_50(nargout, out, nargin-1, in+1);
      break;
    case 51:
      gtsamKeyGroupMap_clear_51(nargout, out, nargin-1, in+1);
      break;
    case 52:
      gtsamKeyGroupMap_empty_52(nargout, out, nargin-1, in+1);
      break;
    case 53:
      gtsamKeyGroupMap_erase_53(nargout, out, nargin-1, in+1);
      break;
    case 54:
      gtsamKeyGroupMap_insert2_54(nargout, out, nargin-1, in+1);
      break;
    case 55:
      gtsamKeyGroupMap_size_55(nargout, out, nargin-1, in+1);
      break;
    case 56:
      gtsamValue_collectorInsertAndMakeBase_56(nargout, out, nargin-1, in+1);
      break;
    case 57:
      gtsamValue_upcastFromVoid_57(nargout, out, nargin-1, in+1);
      break;
    case 58:
      gtsamValue_deconstructor_58(nargout, out, nargin-1, in+1);
      break;
    case 59:
      gtsamValue_dim_59(nargout, out, nargin-1, in+1);
      break;
    case 60:
      gtsamValue_print_60(nargout, out, nargin-1, in+1);
      break;
    case 61:
      gtsamLieScalar_collectorInsertAndMakeBase_61(nargout, out, nargin-1, in+1);
      break;
    case 62:
      gtsamLieScalar_constructor_62(nargout, out, nargin-1, in+1);
      break;
    case 63:
      gtsamLieScalar_constructor_63(nargout, out, nargin-1, in+1);
      break;
    case 64:
      gtsamLieScalar_deconstructor_64(nargout, out, nargin-1, in+1);
      break;
    case 65:
      gtsamLieScalar_between_65(nargout, out, nargin-1, in+1);
      break;
    case 66:
      gtsamLieScalar_compose_66(nargout, out, nargin-1, in+1);
      break;
    case 67:
      gtsamLieScalar_dim_67(nargout, out, nargin-1, in+1);
      break;
    case 68:
      gtsamLieScalar_equals_68(nargout, out, nargin-1, in+1);
      break;
    case 69:
      gtsamLieScalar_inverse_69(nargout, out, nargin-1, in+1);
      break;
    case 70:
      gtsamLieScalar_localCoordinates_70(nargout, out, nargin-1, in+1);
      break;
    case 71:
      gtsamLieScalar_print_71(nargout, out, nargin-1, in+1);
      break;
    case 72:
      gtsamLieScalar_retract_72(nargout, out, nargin-1, in+1);
      break;
    case 73:
      gtsamLieScalar_value_73(nargout, out, nargin-1, in+1);
      break;
    case 74:
      gtsamLieScalar_Expmap_74(nargout, out, nargin-1, in+1);
      break;
    case 75:
      gtsamLieScalar_Logmap_75(nargout, out, nargin-1, in+1);
      break;
    case 76:
      gtsamLieScalar_identity_76(nargout, out, nargin-1, in+1);
      break;
    case 77:
      gtsamLieVector_collectorInsertAndMakeBase_77(nargout, out, nargin-1, in+1);
      break;
    case 78:
      gtsamLieVector_constructor_78(nargout, out, nargin-1, in+1);
      break;
    case 79:
      gtsamLieVector_constructor_79(nargout, out, nargin-1, in+1);
      break;
    case 80:
      gtsamLieVector_deconstructor_80(nargout, out, nargin-1, in+1);
      break;
    case 81:
      gtsamLieVector_between_81(nargout, out, nargin-1, in+1);
      break;
    case 82:
      gtsamLieVector_compose_82(nargout, out, nargin-1, in+1);
      break;
    case 83:
      gtsamLieVector_dim_83(nargout, out, nargin-1, in+1);
      break;
    case 84:
      gtsamLieVector_equals_84(nargout, out, nargin-1, in+1);
      break;
    case 85:
      gtsamLieVector_inverse_85(nargout, out, nargin-1, in+1);
      break;
    case 86:
      gtsamLieVector_localCoordinates_86(nargout, out, nargin-1, in+1);
      break;
    case 87:
      gtsamLieVector_print_87(nargout, out, nargin-1, in+1);
      break;
    case 88:
      gtsamLieVector_retract_88(nargout, out, nargin-1, in+1);
      break;
    case 89:
      gtsamLieVector_vector_89(nargout, out, nargin-1, in+1);
      break;
    case 90:
      gtsamLieVector_string_serialize_90(nargout, out, nargin-1, in+1);
      break;
    case 91:
      gtsamLieVector_Expmap_91(nargout, out, nargin-1, in+1);
      break;
    case 92:
      gtsamLieVector_Logmap_92(nargout, out, nargin-1, in+1);
      break;
    case 93:
      gtsamLieVector_identity_93(nargout, out, nargin-1, in+1);
      break;
    case 94:
      gtsamLieVector_string_deserialize_94(nargout, out, nargin-1, in+1);
      break;
    case 95:
      gtsamLieMatrix_collectorInsertAndMakeBase_95(nargout, out, nargin-1, in+1);
      break;
    case 96:
      gtsamLieMatrix_constructor_96(nargout, out, nargin-1, in+1);
      break;
    case 97:
      gtsamLieMatrix_constructor_97(nargout, out, nargin-1, in+1);
      break;
    case 98:
      gtsamLieMatrix_deconstructor_98(nargout, out, nargin-1, in+1);
      break;
    case 99:
      gtsamLieMatrix_between_99(nargout, out, nargin-1, in+1);
      break;
    case 100:
      gtsamLieMatrix_compose_100(nargout, out, nargin-1, in+1);
      break;
    case 101:
      gtsamLieMatrix_dim_101(nargout, out, nargin-1, in+1);
      break;
    case 102:
      gtsamLieMatrix_equals_102(nargout, out, nargin-1, in+1);
      break;
    case 103:
      gtsamLieMatrix_inverse_103(nargout, out, nargin-1, in+1);
      break;
    case 104:
      gtsamLieMatrix_localCoordinates_104(nargout, out, nargin-1, in+1);
      break;
    case 105:
      gtsamLieMatrix_matrix_105(nargout, out, nargin-1, in+1);
      break;
    case 106:
      gtsamLieMatrix_print_106(nargout, out, nargin-1, in+1);
      break;
    case 107:
      gtsamLieMatrix_retract_107(nargout, out, nargin-1, in+1);
      break;
    case 108:
      gtsamLieMatrix_string_serialize_108(nargout, out, nargin-1, in+1);
      break;
    case 109:
      gtsamLieMatrix_Expmap_109(nargout, out, nargin-1, in+1);
      break;
    case 110:
      gtsamLieMatrix_Logmap_110(nargout, out, nargin-1, in+1);
      break;
    case 111:
      gtsamLieMatrix_identity_111(nargout, out, nargin-1, in+1);
      break;
    case 112:
      gtsamLieMatrix_string_deserialize_112(nargout, out, nargin-1, in+1);
      break;
    case 113:
      gtsamPoint2_collectorInsertAndMakeBase_113(nargout, out, nargin-1, in+1);
      break;
    case 114:
      gtsamPoint2_constructor_114(nargout, out, nargin-1, in+1);
      break;
    case 115:
      gtsamPoint2_constructor_115(nargout, out, nargin-1, in+1);
      break;
    case 116:
      gtsamPoint2_constructor_116(nargout, out, nargin-1, in+1);
      break;
    case 117:
      gtsamPoint2_deconstructor_117(nargout, out, nargin-1, in+1);
      break;
    case 118:
      gtsamPoint2_distance_118(nargout, out, nargin-1, in+1);
      break;
    case 119:
      gtsamPoint2_equals_119(nargout, out, nargin-1, in+1);
      break;
    case 120:
      gtsamPoint2_norm_120(nargout, out, nargin-1, in+1);
      break;
    case 121:
      gtsamPoint2_print_121(nargout, out, nargin-1, in+1);
      break;
    case 122:
      gtsamPoint2_vector_122(nargout, out, nargin-1, in+1);
      break;
    case 123:
      gtsamPoint2_x_123(nargout, out, nargin-1, in+1);
      break;
    case 124:
      gtsamPoint2_y_124(nargout, out, nargin-1, in+1);
      break;
    case 125:
      gtsamPoint2_string_serialize_125(nargout, out, nargin-1, in+1);
      break;
    case 126:
      gtsamPoint2_identity_126(nargout, out, nargin-1, in+1);
      break;
    case 127:
      gtsamPoint2_string_deserialize_127(nargout, out, nargin-1, in+1);
      break;
    case 128:
      gtsamPoint2Vector_collectorInsertAndMakeBase_128(nargout, out, nargin-1, in+1);
      break;
    case 129:
      gtsamPoint2Vector_constructor_129(nargout, out, nargin-1, in+1);
      break;
    case 130:
      gtsamPoint2Vector_constructor_130(nargout, out, nargin-1, in+1);
      break;
    case 131:
      gtsamPoint2Vector_deconstructor_131(nargout, out, nargin-1, in+1);
      break;
    case 132:
      gtsamPoint2Vector_assign_132(nargout, out, nargin-1, in+1);
      break;
    case 133:
      gtsamPoint2Vector_at_133(nargout, out, nargin-1, in+1);
      break;
    case 134:
      gtsamPoint2Vector_back_134(nargout, out, nargin-1, in+1);
      break;
    case 135:
      gtsamPoint2Vector_capacity_135(nargout, out, nargin-1, in+1);
      break;
    case 136:
      gtsamPoint2Vector_empty_136(nargout, out, nargin-1, in+1);
      break;
    case 137:
      gtsamPoint2Vector_front_137(nargout, out, nargin-1, in+1);
      break;
    case 138:
      gtsamPoint2Vector_max_size_138(nargout, out, nargin-1, in+1);
      break;
    case 139:
      gtsamPoint2Vector_pop_back_139(nargout, out, nargin-1, in+1);
      break;
    case 140:
      gtsamPoint2Vector_push_back_140(nargout, out, nargin-1, in+1);
      break;
    case 141:
      gtsamPoint2Vector_reserve_141(nargout, out, nargin-1, in+1);
      break;
    case 142:
      gtsamPoint2Vector_resize_142(nargout, out, nargin-1, in+1);
      break;
    case 143:
      gtsamPoint2Vector_size_143(nargout, out, nargin-1, in+1);
      break;
    case 144:
      gtsamStereoPoint2_collectorInsertAndMakeBase_144(nargout, out, nargin-1, in+1);
      break;
    case 145:
      gtsamStereoPoint2_constructor_145(nargout, out, nargin-1, in+1);
      break;
    case 146:
      gtsamStereoPoint2_constructor_146(nargout, out, nargin-1, in+1);
      break;
    case 147:
      gtsamStereoPoint2_deconstructor_147(nargout, out, nargin-1, in+1);
      break;
    case 148:
      gtsamStereoPoint2_between_148(nargout, out, nargin-1, in+1);
      break;
    case 149:
      gtsamStereoPoint2_compose_149(nargout, out, nargin-1, in+1);
      break;
    case 150:
      gtsamStereoPoint2_equals_150(nargout, out, nargin-1, in+1);
      break;
    case 151:
      gtsamStereoPoint2_inverse_151(nargout, out, nargin-1, in+1);
      break;
    case 152:
      gtsamStereoPoint2_localCoordinates_152(nargout, out, nargin-1, in+1);
      break;
    case 153:
      gtsamStereoPoint2_print_153(nargout, out, nargin-1, in+1);
      break;
    case 154:
      gtsamStereoPoint2_retract_154(nargout, out, nargin-1, in+1);
      break;
    case 155:
      gtsamStereoPoint2_uL_155(nargout, out, nargin-1, in+1);
      break;
    case 156:
      gtsamStereoPoint2_uR_156(nargout, out, nargin-1, in+1);
      break;
    case 157:
      gtsamStereoPoint2_v_157(nargout, out, nargin-1, in+1);
      break;
    case 158:
      gtsamStereoPoint2_vector_158(nargout, out, nargin-1, in+1);
      break;
    case 159:
      gtsamStereoPoint2_string_serialize_159(nargout, out, nargin-1, in+1);
      break;
    case 160:
      gtsamStereoPoint2_Expmap_160(nargout, out, nargin-1, in+1);
      break;
    case 161:
      gtsamStereoPoint2_Logmap_161(nargout, out, nargin-1, in+1);
      break;
    case 162:
      gtsamStereoPoint2_identity_162(nargout, out, nargin-1, in+1);
      break;
    case 163:
      gtsamStereoPoint2_string_deserialize_163(nargout, out, nargin-1, in+1);
      break;
    case 164:
      gtsamPoint3_collectorInsertAndMakeBase_164(nargout, out, nargin-1, in+1);
      break;
    case 165:
      gtsamPoint3_constructor_165(nargout, out, nargin-1, in+1);
      break;
    case 166:
      gtsamPoint3_constructor_166(nargout, out, nargin-1, in+1);
      break;
    case 167:
      gtsamPoint3_constructor_167(nargout, out, nargin-1, in+1);
      break;
    case 168:
      gtsamPoint3_deconstructor_168(nargout, out, nargin-1, in+1);
      break;
    case 169:
      gtsamPoint3_equals_169(nargout, out, nargin-1, in+1);
      break;
    case 170:
      gtsamPoint3_print_170(nargout, out, nargin-1, in+1);
      break;
    case 171:
      gtsamPoint3_vector_171(nargout, out, nargin-1, in+1);
      break;
    case 172:
      gtsamPoint3_x_172(nargout, out, nargin-1, in+1);
      break;
    case 173:
      gtsamPoint3_y_173(nargout, out, nargin-1, in+1);
      break;
    case 174:
      gtsamPoint3_z_174(nargout, out, nargin-1, in+1);
      break;
    case 175:
      gtsamPoint3_string_serialize_175(nargout, out, nargin-1, in+1);
      break;
    case 176:
      gtsamPoint3_identity_176(nargout, out, nargin-1, in+1);
      break;
    case 177:
      gtsamPoint3_string_deserialize_177(nargout, out, nargin-1, in+1);
      break;
    case 178:
      gtsamRot2_collectorInsertAndMakeBase_178(nargout, out, nargin-1, in+1);
      break;
    case 179:
      gtsamRot2_constructor_179(nargout, out, nargin-1, in+1);
      break;
    case 180:
      gtsamRot2_constructor_180(nargout, out, nargin-1, in+1);
      break;
    case 181:
      gtsamRot2_deconstructor_181(nargout, out, nargin-1, in+1);
      break;
    case 182:
      gtsamRot2_between_182(nargout, out, nargin-1, in+1);
      break;
    case 183:
      gtsamRot2_c_183(nargout, out, nargin-1, in+1);
      break;
    case 184:
      gtsamRot2_compose_184(nargout, out, nargin-1, in+1);
      break;
    case 185:
      gtsamRot2_degrees_185(nargout, out, nargin-1, in+1);
      break;
    case 186:
      gtsamRot2_equals_186(nargout, out, nargin-1, in+1);
      break;
    case 187:
      gtsamRot2_inverse_187(nargout, out, nargin-1, in+1);
      break;
    case 188:
      gtsamRot2_localCoordinates_188(nargout, out, nargin-1, in+1);
      break;
    case 189:
      gtsamRot2_matrix_189(nargout, out, nargin-1, in+1);
      break;
    case 190:
      gtsamRot2_print_190(nargout, out, nargin-1, in+1);
      break;
    case 191:
      gtsamRot2_retract_191(nargout, out, nargin-1, in+1);
      break;
    case 192:
      gtsamRot2_rotate_192(nargout, out, nargin-1, in+1);
      break;
    case 193:
      gtsamRot2_s_193(nargout, out, nargin-1, in+1);
      break;
    case 194:
      gtsamRot2_theta_194(nargout, out, nargin-1, in+1);
      break;
    case 195:
      gtsamRot2_unrotate_195(nargout, out, nargin-1, in+1);
      break;
    case 196:
      gtsamRot2_string_serialize_196(nargout, out, nargin-1, in+1);
      break;
    case 197:
      gtsamRot2_Expmap_197(nargout, out, nargin-1, in+1);
      break;
    case 198:
      gtsamRot2_Logmap_198(nargout, out, nargin-1, in+1);
      break;
    case 199:
      gtsamRot2_atan2_199(nargout, out, nargin-1, in+1);
      break;
    case 200:
      gtsamRot2_fromAngle_200(nargout, out, nargin-1, in+1);
      break;
    case 201:
      gtsamRot2_fromCosSin_201(nargout, out, nargin-1, in+1);
      break;
    case 202:
      gtsamRot2_fromDegrees_202(nargout, out, nargin-1, in+1);
      break;
    case 203:
      gtsamRot2_identity_203(nargout, out, nargin-1, in+1);
      break;
    case 204:
      gtsamRot2_relativeBearing_204(nargout, out, nargin-1, in+1);
      break;
    case 205:
      gtsamRot2_string_deserialize_205(nargout, out, nargin-1, in+1);
      break;
    case 206:
      gtsamRot3_collectorInsertAndMakeBase_206(nargout, out, nargin-1, in+1);
      break;
    case 207:
      gtsamRot3_constructor_207(nargout, out, nargin-1, in+1);
      break;
    case 208:
      gtsamRot3_constructor_208(nargout, out, nargin-1, in+1);
      break;
    case 209:
      gtsamRot3_constructor_209(nargout, out, nargin-1, in+1);
      break;
    case 210:
      gtsamRot3_constructor_210(nargout, out, nargin-1, in+1);
      break;
    case 211:
      gtsamRot3_deconstructor_211(nargout, out, nargin-1, in+1);
      break;
    case 212:
      gtsamRot3_between_212(nargout, out, nargin-1, in+1);
      break;
    case 213:
      gtsamRot3_column_213(nargout, out, nargin-1, in+1);
      break;
    case 214:
      gtsamRot3_compose_214(nargout, out, nargin-1, in+1);
      break;
    case 215:
      gtsamRot3_equals_215(nargout, out, nargin-1, in+1);
      break;
    case 216:
      gtsamRot3_inverse_216(nargout, out, nargin-1, in+1);
      break;
    case 217:
      gtsamRot3_localCoordinates_217(nargout, out, nargin-1, in+1);
      break;
    case 218:
      gtsamRot3_matrix_218(nargout, out, nargin-1, in+1);
      break;
    case 219:
      gtsamRot3_pitch_219(nargout, out, nargin-1, in+1);
      break;
    case 220:
      gtsamRot3_print_220(nargout, out, nargin-1, in+1);
      break;
    case 221:
      gtsamRot3_quaternion_221(nargout, out, nargin-1, in+1);
      break;
    case 222:
      gtsamRot3_retract_222(nargout, out, nargin-1, in+1);
      break;
    case 223:
      gtsamRot3_roll_223(nargout, out, nargin-1, in+1);
      break;
    case 224:
      gtsamRot3_rotate_224(nargout, out, nargin-1, in+1);
      break;
    case 225:
      gtsamRot3_rpy_225(nargout, out, nargin-1, in+1);
      break;
    case 226:
      gtsamRot3_transpose_226(nargout, out, nargin-1, in+1);
      break;
    case 227:
      gtsamRot3_unrotate_227(nargout, out, nargin-1, in+1);
      break;
    case 228:
      gtsamRot3_xyz_228(nargout, out, nargin-1, in+1);
      break;
    case 229:
      gtsamRot3_yaw_229(nargout, out, nargin-1, in+1);
      break;
    case 230:
      gtsamRot3_ypr_230(nargout, out, nargin-1, in+1);
      break;
    case 231:
      gtsamRot3_string_serialize_231(nargout, out, nargin-1, in+1);
      break;
    case 232:
      gtsamRot3_Expmap_232(nargout, out, nargin-1, in+1);
      break;
    case 233:
      gtsamRot3_Logmap_233(nargout, out, nargin-1, in+1);
      break;
    case 234:
      gtsamRot3_Pitch_234(nargout, out, nargin-1, in+1);
      break;
    case 235:
      gtsamRot3_Quaternion_235(nargout, out, nargin-1, in+1);
      break;
    case 236:
      gtsamRot3_Rodrigues_236(nargout, out, nargin-1, in+1);
      break;
    case 237:
      gtsamRot3_Rodrigues_237(nargout, out, nargin-1, in+1);
      break;
    case 238:
      gtsamRot3_Roll_238(nargout, out, nargin-1, in+1);
      break;
    case 239:
      gtsamRot3_Rx_239(nargout, out, nargin-1, in+1);
      break;
    case 240:
      gtsamRot3_Ry_240(nargout, out, nargin-1, in+1);
      break;
    case 241:
      gtsamRot3_Rz_241(nargout, out, nargin-1, in+1);
      break;
    case 242:
      gtsamRot3_RzRyRx_242(nargout, out, nargin-1, in+1);
      break;
    case 243:
      gtsamRot3_RzRyRx_243(nargout, out, nargin-1, in+1);
      break;
    case 244:
      gtsamRot3_Yaw_244(nargout, out, nargin-1, in+1);
      break;
    case 245:
      gtsamRot3_Ypr_245(nargout, out, nargin-1, in+1);
      break;
    case 246:
      gtsamRot3_identity_246(nargout, out, nargin-1, in+1);
      break;
    case 247:
      gtsamRot3_string_deserialize_247(nargout, out, nargin-1, in+1);
      break;
    case 248:
      gtsamPose2_collectorInsertAndMakeBase_248(nargout, out, nargin-1, in+1);
      break;
    case 249:
      gtsamPose2_constructor_249(nargout, out, nargin-1, in+1);
      break;
    case 250:
      gtsamPose2_constructor_250(nargout, out, nargin-1, in+1);
      break;
    case 251:
      gtsamPose2_constructor_251(nargout, out, nargin-1, in+1);
      break;
    case 252:
      gtsamPose2_constructor_252(nargout, out, nargin-1, in+1);
      break;
    case 253:
      gtsamPose2_constructor_253(nargout, out, nargin-1, in+1);
      break;
    case 254:
      gtsamPose2_constructor_254(nargout, out, nargin-1, in+1);
      break;
    case 255:
      gtsamPose2_deconstructor_255(nargout, out, nargin-1, in+1);
      break;
    case 256:
      gtsamPose2_Adjoint_256(nargout, out, nargin-1, in+1);
      break;
    case 257:
      gtsamPose2_AdjointMap_257(nargout, out, nargin-1, in+1);
      break;
    case 258:
      gtsamPose2_bearing_258(nargout, out, nargin-1, in+1);
      break;
    case 259:
      gtsamPose2_between_259(nargout, out, nargin-1, in+1);
      break;
    case 260:
      gtsamPose2_compose_260(nargout, out, nargin-1, in+1);
      break;
    case 261:
      gtsamPose2_equals_261(nargout, out, nargin-1, in+1);
      break;
    case 262:
      gtsamPose2_inverse_262(nargout, out, nargin-1, in+1);
      break;
    case 263:
      gtsamPose2_localCoordinates_263(nargout, out, nargin-1, in+1);
      break;
    case 264:
      gtsamPose2_matrix_264(nargout, out, nargin-1, in+1);
      break;
    case 265:
      gtsamPose2_print_265(nargout, out, nargin-1, in+1);
      break;
    case 266:
      gtsamPose2_range_266(nargout, out, nargin-1, in+1);
      break;
    case 267:
      gtsamPose2_retract_267(nargout, out, nargin-1, in+1);
      break;
    case 268:
      gtsamPose2_rotation_268(nargout, out, nargin-1, in+1);
      break;
    case 269:
      gtsamPose2_theta_269(nargout, out, nargin-1, in+1);
      break;
    case 270:
      gtsamPose2_transform_from_270(nargout, out, nargin-1, in+1);
      break;
    case 271:
      gtsamPose2_transform_to_271(nargout, out, nargin-1, in+1);
      break;
    case 272:
      gtsamPose2_translation_272(nargout, out, nargin-1, in+1);
      break;
    case 273:
      gtsamPose2_x_273(nargout, out, nargin-1, in+1);
      break;
    case 274:
      gtsamPose2_y_274(nargout, out, nargin-1, in+1);
      break;
    case 275:
      gtsamPose2_string_serialize_275(nargout, out, nargin-1, in+1);
      break;
    case 276:
      gtsamPose2_Expmap_276(nargout, out, nargin-1, in+1);
      break;
    case 277:
      gtsamPose2_Logmap_277(nargout, out, nargin-1, in+1);
      break;
    case 278:
      gtsamPose2_identity_278(nargout, out, nargin-1, in+1);
      break;
    case 279:
      gtsamPose2_wedge_279(nargout, out, nargin-1, in+1);
      break;
    case 280:
      gtsamPose2_string_deserialize_280(nargout, out, nargin-1, in+1);
      break;
    case 281:
      gtsamPose3_collectorInsertAndMakeBase_281(nargout, out, nargin-1, in+1);
      break;
    case 282:
      gtsamPose3_constructor_282(nargout, out, nargin-1, in+1);
      break;
    case 283:
      gtsamPose3_constructor_283(nargout, out, nargin-1, in+1);
      break;
    case 284:
      gtsamPose3_constructor_284(nargout, out, nargin-1, in+1);
      break;
    case 285:
      gtsamPose3_constructor_285(nargout, out, nargin-1, in+1);
      break;
    case 286:
      gtsamPose3_constructor_286(nargout, out, nargin-1, in+1);
      break;
    case 287:
      gtsamPose3_deconstructor_287(nargout, out, nargin-1, in+1);
      break;
    case 288:
      gtsamPose3_Adjoint_288(nargout, out, nargin-1, in+1);
      break;
    case 289:
      gtsamPose3_AdjointMap_289(nargout, out, nargin-1, in+1);
      break;
    case 290:
      gtsamPose3_between_290(nargout, out, nargin-1, in+1);
      break;
    case 291:
      gtsamPose3_compose_291(nargout, out, nargin-1, in+1);
      break;
    case 292:
      gtsamPose3_equals_292(nargout, out, nargin-1, in+1);
      break;
    case 293:
      gtsamPose3_inverse_293(nargout, out, nargin-1, in+1);
      break;
    case 294:
      gtsamPose3_localCoordinates_294(nargout, out, nargin-1, in+1);
      break;
    case 295:
      gtsamPose3_matrix_295(nargout, out, nargin-1, in+1);
      break;
    case 296:
      gtsamPose3_print_296(nargout, out, nargin-1, in+1);
      break;
    case 297:
      gtsamPose3_range_297(nargout, out, nargin-1, in+1);
      break;
    case 298:
      gtsamPose3_range_298(nargout, out, nargin-1, in+1);
      break;
    case 299:
      gtsamPose3_retract_299(nargout, out, nargin-1, in+1);
      break;
    case 300:
      gtsamPose3_rotation_300(nargout, out, nargin-1, in+1);
      break;
    case 301:
      gtsamPose3_transform_from_301(nargout, out, nargin-1, in+1);
      break;
    case 302:
      gtsamPose3_transform_to_302(nargout, out, nargin-1, in+1);
      break;
    case 303:
      gtsamPose3_transform_to_303(nargout, out, nargin-1, in+1);
      break;
    case 304:
      gtsamPose3_translation_304(nargout, out, nargin-1, in+1);
      break;
    case 305:
      gtsamPose3_x_305(nargout, out, nargin-1, in+1);
      break;
    case 306:
      gtsamPose3_y_306(nargout, out, nargin-1, in+1);
      break;
    case 307:
      gtsamPose3_z_307(nargout, out, nargin-1, in+1);
      break;
    case 308:
      gtsamPose3_string_serialize_308(nargout, out, nargin-1, in+1);
      break;
    case 309:
      gtsamPose3_Expmap_309(nargout, out, nargin-1, in+1);
      break;
    case 310:
      gtsamPose3_Logmap_310(nargout, out, nargin-1, in+1);
      break;
    case 311:
      gtsamPose3_identity_311(nargout, out, nargin-1, in+1);
      break;
    case 312:
      gtsamPose3_wedge_312(nargout, out, nargin-1, in+1);
      break;
    case 313:
      gtsamPose3_string_deserialize_313(nargout, out, nargin-1, in+1);
      break;
    case 314:
      gtsamPose3Vector_collectorInsertAndMakeBase_314(nargout, out, nargin-1, in+1);
      break;
    case 315:
      gtsamPose3Vector_constructor_315(nargout, out, nargin-1, in+1);
      break;
    case 316:
      gtsamPose3Vector_deconstructor_316(nargout, out, nargin-1, in+1);
      break;
    case 317:
      gtsamPose3Vector_at_317(nargout, out, nargin-1, in+1);
      break;
    case 318:
      gtsamPose3Vector_empty_318(nargout, out, nargin-1, in+1);
      break;
    case 319:
      gtsamPose3Vector_push_back_319(nargout, out, nargin-1, in+1);
      break;
    case 320:
      gtsamPose3Vector_size_320(nargout, out, nargin-1, in+1);
      break;
    case 321:
      gtsamUnit3_collectorInsertAndMakeBase_321(nargout, out, nargin-1, in+1);
      break;
    case 322:
      gtsamUnit3_constructor_322(nargout, out, nargin-1, in+1);
      break;
    case 323:
      gtsamUnit3_constructor_323(nargout, out, nargin-1, in+1);
      break;
    case 324:
      gtsamUnit3_deconstructor_324(nargout, out, nargin-1, in+1);
      break;
    case 325:
      gtsamUnit3_basis_325(nargout, out, nargin-1, in+1);
      break;
    case 326:
      gtsamUnit3_dim_326(nargout, out, nargin-1, in+1);
      break;
    case 327:
      gtsamUnit3_equals_327(nargout, out, nargin-1, in+1);
      break;
    case 328:
      gtsamUnit3_localCoordinates_328(nargout, out, nargin-1, in+1);
      break;
    case 329:
      gtsamUnit3_print_329(nargout, out, nargin-1, in+1);
      break;
    case 330:
      gtsamUnit3_retract_330(nargout, out, nargin-1, in+1);
      break;
    case 331:
      gtsamUnit3_skew_331(nargout, out, nargin-1, in+1);
      break;
    case 332:
      gtsamUnit3_Dim_332(nargout, out, nargin-1, in+1);
      break;
    case 333:
      gtsamEssentialMatrix_collectorInsertAndMakeBase_333(nargout, out, nargin-1, in+1);
      break;
    case 334:
      gtsamEssentialMatrix_constructor_334(nargout, out, nargin-1, in+1);
      break;
    case 335:
      gtsamEssentialMatrix_deconstructor_335(nargout, out, nargin-1, in+1);
      break;
    case 336:
      gtsamEssentialMatrix_dim_336(nargout, out, nargin-1, in+1);
      break;
    case 337:
      gtsamEssentialMatrix_direction_337(nargout, out, nargin-1, in+1);
      break;
    case 338:
      gtsamEssentialMatrix_equals_338(nargout, out, nargin-1, in+1);
      break;
    case 339:
      gtsamEssentialMatrix_error_339(nargout, out, nargin-1, in+1);
      break;
    case 340:
      gtsamEssentialMatrix_localCoordinates_340(nargout, out, nargin-1, in+1);
      break;
    case 341:
      gtsamEssentialMatrix_matrix_341(nargout, out, nargin-1, in+1);
      break;
    case 342:
      gtsamEssentialMatrix_print_342(nargout, out, nargin-1, in+1);
      break;
    case 343:
      gtsamEssentialMatrix_retract_343(nargout, out, nargin-1, in+1);
      break;
    case 344:
      gtsamEssentialMatrix_rotation_344(nargout, out, nargin-1, in+1);
      break;
    case 345:
      gtsamEssentialMatrix_Dim_345(nargout, out, nargin-1, in+1);
      break;
    case 346:
      gtsamCal3_S2_collectorInsertAndMakeBase_346(nargout, out, nargin-1, in+1);
      break;
    case 347:
      gtsamCal3_S2_constructor_347(nargout, out, nargin-1, in+1);
      break;
    case 348:
      gtsamCal3_S2_constructor_348(nargout, out, nargin-1, in+1);
      break;
    case 349:
      gtsamCal3_S2_constructor_349(nargout, out, nargin-1, in+1);
      break;
    case 350:
      gtsamCal3_S2_constructor_350(nargout, out, nargin-1, in+1);
      break;
    case 351:
      gtsamCal3_S2_deconstructor_351(nargout, out, nargin-1, in+1);
      break;
    case 352:
      gtsamCal3_S2_calibrate_352(nargout, out, nargin-1, in+1);
      break;
    case 353:
      gtsamCal3_S2_dim_353(nargout, out, nargin-1, in+1);
      break;
    case 354:
      gtsamCal3_S2_equals_354(nargout, out, nargin-1, in+1);
      break;
    case 355:
      gtsamCal3_S2_fx_355(nargout, out, nargin-1, in+1);
      break;
    case 356:
      gtsamCal3_S2_fy_356(nargout, out, nargin-1, in+1);
      break;
    case 357:
      gtsamCal3_S2_localCoordinates_357(nargout, out, nargin-1, in+1);
      break;
    case 358:
      gtsamCal3_S2_matrix_358(nargout, out, nargin-1, in+1);
      break;
    case 359:
      gtsamCal3_S2_matrix_inverse_359(nargout, out, nargin-1, in+1);
      break;
    case 360:
      gtsamCal3_S2_principalPoint_360(nargout, out, nargin-1, in+1);
      break;
    case 361:
      gtsamCal3_S2_print_361(nargout, out, nargin-1, in+1);
      break;
    case 362:
      gtsamCal3_S2_px_362(nargout, out, nargin-1, in+1);
      break;
    case 363:
      gtsamCal3_S2_py_363(nargout, out, nargin-1, in+1);
      break;
    case 364:
      gtsamCal3_S2_retract_364(nargout, out, nargin-1, in+1);
      break;
    case 365:
      gtsamCal3_S2_skew_365(nargout, out, nargin-1, in+1);
      break;
    case 366:
      gtsamCal3_S2_uncalibrate_366(nargout, out, nargin-1, in+1);
      break;
    case 367:
      gtsamCal3_S2_vector_367(nargout, out, nargin-1, in+1);
      break;
    case 368:
      gtsamCal3_S2_string_serialize_368(nargout, out, nargin-1, in+1);
      break;
    case 369:
      gtsamCal3_S2_Dim_369(nargout, out, nargin-1, in+1);
      break;
    case 370:
      gtsamCal3_S2_string_deserialize_370(nargout, out, nargin-1, in+1);
      break;
    case 371:
      gtsamCal3DS2_Base_collectorInsertAndMakeBase_371(nargout, out, nargin-1, in+1);
      break;
    case 372:
      gtsamCal3DS2_Base_upcastFromVoid_372(nargout, out, nargin-1, in+1);
      break;
    case 373:
      gtsamCal3DS2_Base_constructor_373(nargout, out, nargin-1, in+1);
      break;
    case 374:
      gtsamCal3DS2_Base_deconstructor_374(nargout, out, nargin-1, in+1);
      break;
    case 375:
      gtsamCal3DS2_Base_K_375(nargout, out, nargin-1, in+1);
      break;
    case 376:
      gtsamCal3DS2_Base_calibrate_376(nargout, out, nargin-1, in+1);
      break;
    case 377:
      gtsamCal3DS2_Base_fx_377(nargout, out, nargin-1, in+1);
      break;
    case 378:
      gtsamCal3DS2_Base_fy_378(nargout, out, nargin-1, in+1);
      break;
    case 379:
      gtsamCal3DS2_Base_k_379(nargout, out, nargin-1, in+1);
      break;
    case 380:
      gtsamCal3DS2_Base_k1_380(nargout, out, nargin-1, in+1);
      break;
    case 381:
      gtsamCal3DS2_Base_k2_381(nargout, out, nargin-1, in+1);
      break;
    case 382:
      gtsamCal3DS2_Base_print_382(nargout, out, nargin-1, in+1);
      break;
    case 383:
      gtsamCal3DS2_Base_px_383(nargout, out, nargin-1, in+1);
      break;
    case 384:
      gtsamCal3DS2_Base_py_384(nargout, out, nargin-1, in+1);
      break;
    case 385:
      gtsamCal3DS2_Base_skew_385(nargout, out, nargin-1, in+1);
      break;
    case 386:
      gtsamCal3DS2_Base_uncalibrate_386(nargout, out, nargin-1, in+1);
      break;
    case 387:
      gtsamCal3DS2_Base_vector_387(nargout, out, nargin-1, in+1);
      break;
    case 388:
      gtsamCal3DS2_Base_string_serialize_388(nargout, out, nargin-1, in+1);
      break;
    case 389:
      gtsamCal3DS2_Base_string_deserialize_389(nargout, out, nargin-1, in+1);
      break;
    case 390:
      gtsamCal3DS2_collectorInsertAndMakeBase_390(nargout, out, nargin-1, in+1);
      break;
    case 391:
      gtsamCal3DS2_upcastFromVoid_391(nargout, out, nargin-1, in+1);
      break;
    case 392:
      gtsamCal3DS2_constructor_392(nargout, out, nargin-1, in+1);
      break;
    case 393:
      gtsamCal3DS2_constructor_393(nargout, out, nargin-1, in+1);
      break;
    case 394:
      gtsamCal3DS2_constructor_394(nargout, out, nargin-1, in+1);
      break;
    case 395:
      gtsamCal3DS2_constructor_395(nargout, out, nargin-1, in+1);
      break;
    case 396:
      gtsamCal3DS2_deconstructor_396(nargout, out, nargin-1, in+1);
      break;
    case 397:
      gtsamCal3DS2_K_397(nargout, out, nargin-1, in+1);
      break;
    case 398:
      gtsamCal3DS2_calibrate_398(nargout, out, nargin-1, in+1);
      break;
    case 399:
      gtsamCal3DS2_dim_399(nargout, out, nargin-1, in+1);
      break;
    case 400:
      gtsamCal3DS2_equals_400(nargout, out, nargin-1, in+1);
      break;
    case 401:
      gtsamCal3DS2_fx_401(nargout, out, nargin-1, in+1);
      break;
    case 402:
      gtsamCal3DS2_fy_402(nargout, out, nargin-1, in+1);
      break;
    case 403:
      gtsamCal3DS2_k_403(nargout, out, nargin-1, in+1);
      break;
    case 404:
      gtsamCal3DS2_k1_404(nargout, out, nargin-1, in+1);
      break;
    case 405:
      gtsamCal3DS2_k2_405(nargout, out, nargin-1, in+1);
      break;
    case 406:
      gtsamCal3DS2_localCoordinates_406(nargout, out, nargin-1, in+1);
      break;
    case 407:
      gtsamCal3DS2_print_407(nargout, out, nargin-1, in+1);
      break;
    case 408:
      gtsamCal3DS2_px_408(nargout, out, nargin-1, in+1);
      break;
    case 409:
      gtsamCal3DS2_py_409(nargout, out, nargin-1, in+1);
      break;
    case 410:
      gtsamCal3DS2_retract_410(nargout, out, nargin-1, in+1);
      break;
    case 411:
      gtsamCal3DS2_skew_411(nargout, out, nargin-1, in+1);
      break;
    case 412:
      gtsamCal3DS2_uncalibrate_412(nargout, out, nargin-1, in+1);
      break;
    case 413:
      gtsamCal3DS2_vector_413(nargout, out, nargin-1, in+1);
      break;
    case 414:
      gtsamCal3DS2_string_serialize_414(nargout, out, nargin-1, in+1);
      break;
    case 415:
      gtsamCal3DS2_Dim_415(nargout, out, nargin-1, in+1);
      break;
    case 416:
      gtsamCal3DS2_string_deserialize_416(nargout, out, nargin-1, in+1);
      break;
    case 417:
      gtsamCal3Unified_collectorInsertAndMakeBase_417(nargout, out, nargin-1, in+1);
      break;
    case 418:
      gtsamCal3Unified_upcastFromVoid_418(nargout, out, nargin-1, in+1);
      break;
    case 419:
      gtsamCal3Unified_constructor_419(nargout, out, nargin-1, in+1);
      break;
    case 420:
      gtsamCal3Unified_constructor_420(nargout, out, nargin-1, in+1);
      break;
    case 421:
      gtsamCal3Unified_constructor_421(nargout, out, nargin-1, in+1);
      break;
    case 422:
      gtsamCal3Unified_constructor_422(nargout, out, nargin-1, in+1);
      break;
    case 423:
      gtsamCal3Unified_deconstructor_423(nargout, out, nargin-1, in+1);
      break;
    case 424:
      gtsamCal3Unified_K_424(nargout, out, nargin-1, in+1);
      break;
    case 425:
      gtsamCal3Unified_calibrate_425(nargout, out, nargin-1, in+1);
      break;
    case 426:
      gtsamCal3Unified_dim_426(nargout, out, nargin-1, in+1);
      break;
    case 427:
      gtsamCal3Unified_equals_427(nargout, out, nargin-1, in+1);
      break;
    case 428:
      gtsamCal3Unified_fx_428(nargout, out, nargin-1, in+1);
      break;
    case 429:
      gtsamCal3Unified_fy_429(nargout, out, nargin-1, in+1);
      break;
    case 430:
      gtsamCal3Unified_k_430(nargout, out, nargin-1, in+1);
      break;
    case 431:
      gtsamCal3Unified_k1_431(nargout, out, nargin-1, in+1);
      break;
    case 432:
      gtsamCal3Unified_k2_432(nargout, out, nargin-1, in+1);
      break;
    case 433:
      gtsamCal3Unified_localCoordinates_433(nargout, out, nargin-1, in+1);
      break;
    case 434:
      gtsamCal3Unified_nPlaneToSpace_434(nargout, out, nargin-1, in+1);
      break;
    case 435:
      gtsamCal3Unified_print_435(nargout, out, nargin-1, in+1);
      break;
    case 436:
      gtsamCal3Unified_px_436(nargout, out, nargin-1, in+1);
      break;
    case 437:
      gtsamCal3Unified_py_437(nargout, out, nargin-1, in+1);
      break;
    case 438:
      gtsamCal3Unified_retract_438(nargout, out, nargin-1, in+1);
      break;
    case 439:
      gtsamCal3Unified_skew_439(nargout, out, nargin-1, in+1);
      break;
    case 440:
      gtsamCal3Unified_spaceToNPlane_440(nargout, out, nargin-1, in+1);
      break;
    case 441:
      gtsamCal3Unified_uncalibrate_441(nargout, out, nargin-1, in+1);
      break;
    case 442:
      gtsamCal3Unified_vector_442(nargout, out, nargin-1, in+1);
      break;
    case 443:
      gtsamCal3Unified_xi_443(nargout, out, nargin-1, in+1);
      break;
    case 444:
      gtsamCal3Unified_string_serialize_444(nargout, out, nargin-1, in+1);
      break;
    case 445:
      gtsamCal3Unified_Dim_445(nargout, out, nargin-1, in+1);
      break;
    case 446:
      gtsamCal3Unified_string_deserialize_446(nargout, out, nargin-1, in+1);
      break;
    case 447:
      gtsamCal3_S2Stereo_collectorInsertAndMakeBase_447(nargout, out, nargin-1, in+1);
      break;
    case 448:
      gtsamCal3_S2Stereo_constructor_448(nargout, out, nargin-1, in+1);
      break;
    case 449:
      gtsamCal3_S2Stereo_constructor_449(nargout, out, nargin-1, in+1);
      break;
    case 450:
      gtsamCal3_S2Stereo_constructor_450(nargout, out, nargin-1, in+1);
      break;
    case 451:
      gtsamCal3_S2Stereo_deconstructor_451(nargout, out, nargin-1, in+1);
      break;
    case 452:
      gtsamCal3_S2Stereo_baseline_452(nargout, out, nargin-1, in+1);
      break;
    case 453:
      gtsamCal3_S2Stereo_equals_453(nargout, out, nargin-1, in+1);
      break;
    case 454:
      gtsamCal3_S2Stereo_fx_454(nargout, out, nargin-1, in+1);
      break;
    case 455:
      gtsamCal3_S2Stereo_fy_455(nargout, out, nargin-1, in+1);
      break;
    case 456:
      gtsamCal3_S2Stereo_principalPoint_456(nargout, out, nargin-1, in+1);
      break;
    case 457:
      gtsamCal3_S2Stereo_print_457(nargout, out, nargin-1, in+1);
      break;
    case 458:
      gtsamCal3_S2Stereo_px_458(nargout, out, nargin-1, in+1);
      break;
    case 459:
      gtsamCal3_S2Stereo_py_459(nargout, out, nargin-1, in+1);
      break;
    case 460:
      gtsamCal3_S2Stereo_skew_460(nargout, out, nargin-1, in+1);
      break;
    case 461:
      gtsamCal3Bundler_collectorInsertAndMakeBase_461(nargout, out, nargin-1, in+1);
      break;
    case 462:
      gtsamCal3Bundler_constructor_462(nargout, out, nargin-1, in+1);
      break;
    case 463:
      gtsamCal3Bundler_constructor_463(nargout, out, nargin-1, in+1);
      break;
    case 464:
      gtsamCal3Bundler_deconstructor_464(nargout, out, nargin-1, in+1);
      break;
    case 465:
      gtsamCal3Bundler_calibrate_465(nargout, out, nargin-1, in+1);
      break;
    case 466:
      gtsamCal3Bundler_dim_466(nargout, out, nargin-1, in+1);
      break;
    case 467:
      gtsamCal3Bundler_equals_467(nargout, out, nargin-1, in+1);
      break;
    case 468:
      gtsamCal3Bundler_fx_468(nargout, out, nargin-1, in+1);
      break;
    case 469:
      gtsamCal3Bundler_fy_469(nargout, out, nargin-1, in+1);
      break;
    case 470:
      gtsamCal3Bundler_k_470(nargout, out, nargin-1, in+1);
      break;
    case 471:
      gtsamCal3Bundler_k1_471(nargout, out, nargin-1, in+1);
      break;
    case 472:
      gtsamCal3Bundler_k2_472(nargout, out, nargin-1, in+1);
      break;
    case 473:
      gtsamCal3Bundler_localCoordinates_473(nargout, out, nargin-1, in+1);
      break;
    case 474:
      gtsamCal3Bundler_print_474(nargout, out, nargin-1, in+1);
      break;
    case 475:
      gtsamCal3Bundler_retract_475(nargout, out, nargin-1, in+1);
      break;
    case 476:
      gtsamCal3Bundler_u0_476(nargout, out, nargin-1, in+1);
      break;
    case 477:
      gtsamCal3Bundler_uncalibrate_477(nargout, out, nargin-1, in+1);
      break;
    case 478:
      gtsamCal3Bundler_v0_478(nargout, out, nargin-1, in+1);
      break;
    case 479:
      gtsamCal3Bundler_vector_479(nargout, out, nargin-1, in+1);
      break;
    case 480:
      gtsamCal3Bundler_string_serialize_480(nargout, out, nargin-1, in+1);
      break;
    case 481:
      gtsamCal3Bundler_Dim_481(nargout, out, nargin-1, in+1);
      break;
    case 482:
      gtsamCal3Bundler_string_deserialize_482(nargout, out, nargin-1, in+1);
      break;
    case 483:
      gtsamCalibratedCamera_collectorInsertAndMakeBase_483(nargout, out, nargin-1, in+1);
      break;
    case 484:
      gtsamCalibratedCamera_constructor_484(nargout, out, nargin-1, in+1);
      break;
    case 485:
      gtsamCalibratedCamera_constructor_485(nargout, out, nargin-1, in+1);
      break;
    case 486:
      gtsamCalibratedCamera_constructor_486(nargout, out, nargin-1, in+1);
      break;
    case 487:
      gtsamCalibratedCamera_deconstructor_487(nargout, out, nargin-1, in+1);
      break;
    case 488:
      gtsamCalibratedCamera_dim_488(nargout, out, nargin-1, in+1);
      break;
    case 489:
      gtsamCalibratedCamera_equals_489(nargout, out, nargin-1, in+1);
      break;
    case 490:
      gtsamCalibratedCamera_localCoordinates_490(nargout, out, nargin-1, in+1);
      break;
    case 491:
      gtsamCalibratedCamera_pose_491(nargout, out, nargin-1, in+1);
      break;
    case 492:
      gtsamCalibratedCamera_print_492(nargout, out, nargin-1, in+1);
      break;
    case 493:
      gtsamCalibratedCamera_project_493(nargout, out, nargin-1, in+1);
      break;
    case 494:
      gtsamCalibratedCamera_range_494(nargout, out, nargin-1, in+1);
      break;
    case 495:
      gtsamCalibratedCamera_retract_495(nargout, out, nargin-1, in+1);
      break;
    case 496:
      gtsamCalibratedCamera_string_serialize_496(nargout, out, nargin-1, in+1);
      break;
    case 497:
      gtsamCalibratedCamera_Dim_497(nargout, out, nargin-1, in+1);
      break;
    case 498:
      gtsamCalibratedCamera_Level_498(nargout, out, nargin-1, in+1);
      break;
    case 499:
      gtsamCalibratedCamera_Project_499(nargout, out, nargin-1, in+1);
      break;
    case 500:
      gtsamCalibratedCamera_string_deserialize_500(nargout, out, nargin-1, in+1);
      break;
    case 501:
      gtsamSimpleCamera_collectorInsertAndMakeBase_501(nargout, out, nargin-1, in+1);
      break;
    case 502:
      gtsamSimpleCamera_upcastFromVoid_502(nargout, out, nargin-1, in+1);
      break;
    case 503:
      gtsamSimpleCamera_constructor_503(nargout, out, nargin-1, in+1);
      break;
    case 504:
      gtsamSimpleCamera_constructor_504(nargout, out, nargin-1, in+1);
      break;
    case 505:
      gtsamSimpleCamera_constructor_505(nargout, out, nargin-1, in+1);
      break;
    case 506:
      gtsamSimpleCamera_deconstructor_506(nargout, out, nargin-1, in+1);
      break;
    case 507:
      gtsamSimpleCamera_backproject_507(nargout, out, nargin-1, in+1);
      break;
    case 508:
      gtsamSimpleCamera_calibration_508(nargout, out, nargin-1, in+1);
      break;
    case 509:
      gtsamSimpleCamera_dim_509(nargout, out, nargin-1, in+1);
      break;
    case 510:
      gtsamSimpleCamera_equals_510(nargout, out, nargin-1, in+1);
      break;
    case 511:
      gtsamSimpleCamera_localCoordinates_511(nargout, out, nargin-1, in+1);
      break;
    case 512:
      gtsamSimpleCamera_pose_512(nargout, out, nargin-1, in+1);
      break;
    case 513:
      gtsamSimpleCamera_print_513(nargout, out, nargin-1, in+1);
      break;
    case 514:
      gtsamSimpleCamera_project_514(nargout, out, nargin-1, in+1);
      break;
    case 515:
      gtsamSimpleCamera_projectSafe_515(nargout, out, nargin-1, in+1);
      break;
    case 516:
      gtsamSimpleCamera_range_516(nargout, out, nargin-1, in+1);
      break;
    case 517:
      gtsamSimpleCamera_range_517(nargout, out, nargin-1, in+1);
      break;
    case 518:
      gtsamSimpleCamera_retract_518(nargout, out, nargin-1, in+1);
      break;
    case 519:
      gtsamSimpleCamera_string_serialize_519(nargout, out, nargin-1, in+1);
      break;
    case 520:
      gtsamSimpleCamera_Dim_520(nargout, out, nargin-1, in+1);
      break;
    case 521:
      gtsamSimpleCamera_Level_521(nargout, out, nargin-1, in+1);
      break;
    case 522:
      gtsamSimpleCamera_Level_522(nargout, out, nargin-1, in+1);
      break;
    case 523:
      gtsamSimpleCamera_Lookat_523(nargout, out, nargin-1, in+1);
      break;
    case 524:
      gtsamSimpleCamera_Project_524(nargout, out, nargin-1, in+1);
      break;
    case 525:
      gtsamSimpleCamera_string_deserialize_525(nargout, out, nargin-1, in+1);
      break;
    case 526:
      gtsamStereoCamera_collectorInsertAndMakeBase_526(nargout, out, nargin-1, in+1);
      break;
    case 527:
      gtsamStereoCamera_constructor_527(nargout, out, nargin-1, in+1);
      break;
    case 528:
      gtsamStereoCamera_constructor_528(nargout, out, nargin-1, in+1);
      break;
    case 529:
      gtsamStereoCamera_deconstructor_529(nargout, out, nargin-1, in+1);
      break;
    case 530:
      gtsamStereoCamera_backproject_530(nargout, out, nargin-1, in+1);
      break;
    case 531:
      gtsamStereoCamera_baseline_531(nargout, out, nargin-1, in+1);
      break;
    case 532:
      gtsamStereoCamera_calibration_532(nargout, out, nargin-1, in+1);
      break;
    case 533:
      gtsamStereoCamera_dim_533(nargout, out, nargin-1, in+1);
      break;
    case 534:
      gtsamStereoCamera_equals_534(nargout, out, nargin-1, in+1);
      break;
    case 535:
      gtsamStereoCamera_localCoordinates_535(nargout, out, nargin-1, in+1);
      break;
    case 536:
      gtsamStereoCamera_pose_536(nargout, out, nargin-1, in+1);
      break;
    case 537:
      gtsamStereoCamera_print_537(nargout, out, nargin-1, in+1);
      break;
    case 538:
      gtsamStereoCamera_project_538(nargout, out, nargin-1, in+1);
      break;
    case 539:
      gtsamStereoCamera_retract_539(nargout, out, nargin-1, in+1);
      break;
    case 540:
      gtsamStereoCamera_string_serialize_540(nargout, out, nargin-1, in+1);
      break;
    case 541:
      gtsamStereoCamera_Dim_541(nargout, out, nargin-1, in+1);
      break;
    case 542:
      gtsamStereoCamera_string_deserialize_542(nargout, out, nargin-1, in+1);
      break;
    case 543:
      gtsamSymbolicFactor_collectorInsertAndMakeBase_543(nargout, out, nargin-1, in+1);
      break;
    case 544:
      gtsamSymbolicFactor_upcastFromVoid_544(nargout, out, nargin-1, in+1);
      break;
    case 545:
      gtsamSymbolicFactor_constructor_545(nargout, out, nargin-1, in+1);
      break;
    case 546:
      gtsamSymbolicFactor_constructor_546(nargout, out, nargin-1, in+1);
      break;
    case 547:
      gtsamSymbolicFactor_constructor_547(nargout, out, nargin-1, in+1);
      break;
    case 548:
      gtsamSymbolicFactor_constructor_548(nargout, out, nargin-1, in+1);
      break;
    case 549:
      gtsamSymbolicFactor_constructor_549(nargout, out, nargin-1, in+1);
      break;
    case 550:
      gtsamSymbolicFactor_constructor_550(nargout, out, nargin-1, in+1);
      break;
    case 551:
      gtsamSymbolicFactor_constructor_551(nargout, out, nargin-1, in+1);
      break;
    case 552:
      gtsamSymbolicFactor_constructor_552(nargout, out, nargin-1, in+1);
      break;
    case 553:
      gtsamSymbolicFactor_deconstructor_553(nargout, out, nargin-1, in+1);
      break;
    case 554:
      gtsamSymbolicFactor_equals_554(nargout, out, nargin-1, in+1);
      break;
    case 555:
      gtsamSymbolicFactor_keys_555(nargout, out, nargin-1, in+1);
      break;
    case 556:
      gtsamSymbolicFactor_print_556(nargout, out, nargin-1, in+1);
      break;
    case 557:
      gtsamSymbolicFactor_size_557(nargout, out, nargin-1, in+1);
      break;
    case 558:
      gtsamSymbolicFactor_FromKeys_558(nargout, out, nargin-1, in+1);
      break;
    case 559:
      gtsamSymbolicFactorGraph_collectorInsertAndMakeBase_559(nargout, out, nargin-1, in+1);
      break;
    case 560:
      gtsamSymbolicFactorGraph_upcastFromVoid_560(nargout, out, nargin-1, in+1);
      break;
    case 561:
      gtsamSymbolicFactorGraph_constructor_561(nargout, out, nargin-1, in+1);
      break;
    case 562:
      gtsamSymbolicFactorGraph_constructor_562(nargout, out, nargin-1, in+1);
      break;
    case 563:
      gtsamSymbolicFactorGraph_constructor_563(nargout, out, nargin-1, in+1);
      break;
    case 564:
      gtsamSymbolicFactorGraph_deconstructor_564(nargout, out, nargin-1, in+1);
      break;
    case 565:
      gtsamSymbolicFactorGraph_eliminateMultifrontal_565(nargout, out, nargin-1, in+1);
      break;
    case 566:
      gtsamSymbolicFactorGraph_eliminateMultifrontal_566(nargout, out, nargin-1, in+1);
      break;
    case 567:
      gtsamSymbolicFactorGraph_eliminatePartialMultifrontal_567(nargout, out, nargin-1, in+1);
      break;
    case 568:
      gtsamSymbolicFactorGraph_eliminatePartialMultifrontal_568(nargout, out, nargin-1, in+1);
      break;
    case 569:
      gtsamSymbolicFactorGraph_eliminatePartialSequential_569(nargout, out, nargin-1, in+1);
      break;
    case 570:
      gtsamSymbolicFactorGraph_eliminatePartialSequential_570(nargout, out, nargin-1, in+1);
      break;
    case 571:
      gtsamSymbolicFactorGraph_eliminateSequential_571(nargout, out, nargin-1, in+1);
      break;
    case 572:
      gtsamSymbolicFactorGraph_eliminateSequential_572(nargout, out, nargin-1, in+1);
      break;
    case 573:
      gtsamSymbolicFactorGraph_equals_573(nargout, out, nargin-1, in+1);
      break;
    case 574:
      gtsamSymbolicFactorGraph_exists_574(nargout, out, nargin-1, in+1);
      break;
    case 575:
      gtsamSymbolicFactorGraph_keys_575(nargout, out, nargin-1, in+1);
      break;
    case 576:
      gtsamSymbolicFactorGraph_marginal_576(nargout, out, nargin-1, in+1);
      break;
    case 577:
      gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_577(nargout, out, nargin-1, in+1);
      break;
    case 578:
      gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_578(nargout, out, nargin-1, in+1);
      break;
    case 579:
      gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_579(nargout, out, nargin-1, in+1);
      break;
    case 580:
      gtsamSymbolicFactorGraph_marginalMultifrontalBayesNet_580(nargout, out, nargin-1, in+1);
      break;
    case 581:
      gtsamSymbolicFactorGraph_print_581(nargout, out, nargin-1, in+1);
      break;
    case 582:
      gtsamSymbolicFactorGraph_push_back_582(nargout, out, nargin-1, in+1);
      break;
    case 583:
      gtsamSymbolicFactorGraph_push_back_583(nargout, out, nargin-1, in+1);
      break;
    case 584:
      gtsamSymbolicFactorGraph_push_back_584(nargout, out, nargin-1, in+1);
      break;
    case 585:
      gtsamSymbolicFactorGraph_push_back_585(nargout, out, nargin-1, in+1);
      break;
    case 586:
      gtsamSymbolicFactorGraph_push_factor_586(nargout, out, nargin-1, in+1);
      break;
    case 587:
      gtsamSymbolicFactorGraph_push_factor_587(nargout, out, nargin-1, in+1);
      break;
    case 588:
      gtsamSymbolicFactorGraph_push_factor_588(nargout, out, nargin-1, in+1);
      break;
    case 589:
      gtsamSymbolicFactorGraph_push_factor_589(nargout, out, nargin-1, in+1);
      break;
    case 590:
      gtsamSymbolicFactorGraph_size_590(nargout, out, nargin-1, in+1);
      break;
    case 591:
      gtsamSymbolicConditional_collectorInsertAndMakeBase_591(nargout, out, nargin-1, in+1);
      break;
    case 592:
      gtsamSymbolicConditional_upcastFromVoid_592(nargout, out, nargin-1, in+1);
      break;
    case 593:
      gtsamSymbolicConditional_constructor_593(nargout, out, nargin-1, in+1);
      break;
    case 594:
      gtsamSymbolicConditional_constructor_594(nargout, out, nargin-1, in+1);
      break;
    case 595:
      gtsamSymbolicConditional_constructor_595(nargout, out, nargin-1, in+1);
      break;
    case 596:
      gtsamSymbolicConditional_constructor_596(nargout, out, nargin-1, in+1);
      break;
    case 597:
      gtsamSymbolicConditional_constructor_597(nargout, out, nargin-1, in+1);
      break;
    case 598:
      gtsamSymbolicConditional_constructor_598(nargout, out, nargin-1, in+1);
      break;
    case 599:
      gtsamSymbolicConditional_deconstructor_599(nargout, out, nargin-1, in+1);
      break;
    case 600:
      gtsamSymbolicConditional_equals_600(nargout, out, nargin-1, in+1);
      break;
    case 601:
      gtsamSymbolicConditional_keys_601(nargout, out, nargin-1, in+1);
      break;
    case 602:
      gtsamSymbolicConditional_nrFrontals_602(nargout, out, nargin-1, in+1);
      break;
    case 603:
      gtsamSymbolicConditional_nrParents_603(nargout, out, nargin-1, in+1);
      break;
    case 604:
      gtsamSymbolicConditional_print_604(nargout, out, nargin-1, in+1);
      break;
    case 605:
      gtsamSymbolicConditional_size_605(nargout, out, nargin-1, in+1);
      break;
    case 606:
      gtsamSymbolicConditional_FromKeys_606(nargout, out, nargin-1, in+1);
      break;
    case 607:
      gtsamSymbolicBayesNet_collectorInsertAndMakeBase_607(nargout, out, nargin-1, in+1);
      break;
    case 608:
      gtsamSymbolicBayesNet_constructor_608(nargout, out, nargin-1, in+1);
      break;
    case 609:
      gtsamSymbolicBayesNet_constructor_609(nargout, out, nargin-1, in+1);
      break;
    case 610:
      gtsamSymbolicBayesNet_deconstructor_610(nargout, out, nargin-1, in+1);
      break;
    case 611:
      gtsamSymbolicBayesNet_at_611(nargout, out, nargin-1, in+1);
      break;
    case 612:
      gtsamSymbolicBayesNet_back_612(nargout, out, nargin-1, in+1);
      break;
    case 613:
      gtsamSymbolicBayesNet_equals_613(nargout, out, nargin-1, in+1);
      break;
    case 614:
      gtsamSymbolicBayesNet_front_614(nargout, out, nargin-1, in+1);
      break;
    case 615:
      gtsamSymbolicBayesNet_print_615(nargout, out, nargin-1, in+1);
      break;
    case 616:
      gtsamSymbolicBayesNet_push_back_616(nargout, out, nargin-1, in+1);
      break;
    case 617:
      gtsamSymbolicBayesNet_push_back_617(nargout, out, nargin-1, in+1);
      break;
    case 618:
      gtsamSymbolicBayesNet_saveGraph_618(nargout, out, nargin-1, in+1);
      break;
    case 619:
      gtsamSymbolicBayesNet_size_619(nargout, out, nargin-1, in+1);
      break;
    case 620:
      gtsamSymbolicBayesTree_collectorInsertAndMakeBase_620(nargout, out, nargin-1, in+1);
      break;
    case 621:
      gtsamSymbolicBayesTree_constructor_621(nargout, out, nargin-1, in+1);
      break;
    case 622:
      gtsamSymbolicBayesTree_constructor_622(nargout, out, nargin-1, in+1);
      break;
    case 623:
      gtsamSymbolicBayesTree_deconstructor_623(nargout, out, nargin-1, in+1);
      break;
    case 624:
      gtsamSymbolicBayesTree_clear_624(nargout, out, nargin-1, in+1);
      break;
    case 625:
      gtsamSymbolicBayesTree_deleteCachedShortcuts_625(nargout, out, nargin-1, in+1);
      break;
    case 626:
      gtsamSymbolicBayesTree_equals_626(nargout, out, nargin-1, in+1);
      break;
    case 627:
      gtsamSymbolicBayesTree_joint_627(nargout, out, nargin-1, in+1);
      break;
    case 628:
      gtsamSymbolicBayesTree_jointBayesNet_628(nargout, out, nargin-1, in+1);
      break;
    case 629:
      gtsamSymbolicBayesTree_marginalFactor_629(nargout, out, nargin-1, in+1);
      break;
    case 630:
      gtsamSymbolicBayesTree_numCachedSeparatorMarginals_630(nargout, out, nargin-1, in+1);
      break;
    case 631:
      gtsamSymbolicBayesTree_print_631(nargout, out, nargin-1, in+1);
      break;
    case 632:
      gtsamSymbolicBayesTree_saveGraph_632(nargout, out, nargin-1, in+1);
      break;
    case 633:
      gtsamSymbolicBayesTree_size_633(nargout, out, nargin-1, in+1);
      break;
    case 634:
      gtsamVariableIndex_collectorInsertAndMakeBase_634(nargout, out, nargin-1, in+1);
      break;
    case 635:
      gtsamVariableIndex_constructor_635(nargout, out, nargin-1, in+1);
      break;
    case 636:
      gtsamVariableIndex_constructor_636(nargout, out, nargin-1, in+1);
      break;
    case 637:
      gtsamVariableIndex_constructor_637(nargout, out, nargin-1, in+1);
      break;
    case 638:
      gtsamVariableIndex_constructor_638(nargout, out, nargin-1, in+1);
      break;
    case 639:
      gtsamVariableIndex_constructor_639(nargout, out, nargin-1, in+1);
      break;
    case 640:
      gtsamVariableIndex_deconstructor_640(nargout, out, nargin-1, in+1);
      break;
    case 641:
      gtsamVariableIndex_equals_641(nargout, out, nargin-1, in+1);
      break;
    case 642:
      gtsamVariableIndex_nEntries_642(nargout, out, nargin-1, in+1);
      break;
    case 643:
      gtsamVariableIndex_nFactors_643(nargout, out, nargin-1, in+1);
      break;
    case 644:
      gtsamVariableIndex_print_644(nargout, out, nargin-1, in+1);
      break;
    case 645:
      gtsamVariableIndex_size_645(nargout, out, nargin-1, in+1);
      break;
    case 646:
      gtsamnoiseModelBase_collectorInsertAndMakeBase_646(nargout, out, nargin-1, in+1);
      break;
    case 647:
      gtsamnoiseModelBase_upcastFromVoid_647(nargout, out, nargin-1, in+1);
      break;
    case 648:
      gtsamnoiseModelBase_deconstructor_648(nargout, out, nargin-1, in+1);
      break;
    case 649:
      gtsamnoiseModelGaussian_collectorInsertAndMakeBase_649(nargout, out, nargin-1, in+1);
      break;
    case 650:
      gtsamnoiseModelGaussian_upcastFromVoid_650(nargout, out, nargin-1, in+1);
      break;
    case 651:
      gtsamnoiseModelGaussian_deconstructor_651(nargout, out, nargin-1, in+1);
      break;
    case 652:
      gtsamnoiseModelGaussian_R_652(nargout, out, nargin-1, in+1);
      break;
    case 653:
      gtsamnoiseModelGaussian_equals_653(nargout, out, nargin-1, in+1);
      break;
    case 654:
      gtsamnoiseModelGaussian_print_654(nargout, out, nargin-1, in+1);
      break;
    case 655:
      gtsamnoiseModelGaussian_Covariance_655(nargout, out, nargin-1, in+1);
      break;
    case 656:
      gtsamnoiseModelGaussian_SqrtInformation_656(nargout, out, nargin-1, in+1);
      break;
    case 657:
      gtsamnoiseModelDiagonal_collectorInsertAndMakeBase_657(nargout, out, nargin-1, in+1);
      break;
    case 658:
      gtsamnoiseModelDiagonal_upcastFromVoid_658(nargout, out, nargin-1, in+1);
      break;
    case 659:
      gtsamnoiseModelDiagonal_deconstructor_659(nargout, out, nargin-1, in+1);
      break;
    case 660:
      gtsamnoiseModelDiagonal_R_660(nargout, out, nargin-1, in+1);
      break;
    case 661:
      gtsamnoiseModelDiagonal_equals_661(nargout, out, nargin-1, in+1);
      break;
    case 662:
      gtsamnoiseModelDiagonal_print_662(nargout, out, nargin-1, in+1);
      break;
    case 663:
      gtsamnoiseModelDiagonal_Precisions_663(nargout, out, nargin-1, in+1);
      break;
    case 664:
      gtsamnoiseModelDiagonal_Sigmas_664(nargout, out, nargin-1, in+1);
      break;
    case 665:
      gtsamnoiseModelDiagonal_Variances_665(nargout, out, nargin-1, in+1);
      break;
    case 666:
      gtsamnoiseModelConstrained_collectorInsertAndMakeBase_666(nargout, out, nargin-1, in+1);
      break;
    case 667:
      gtsamnoiseModelConstrained_upcastFromVoid_667(nargout, out, nargin-1, in+1);
      break;
    case 668:
      gtsamnoiseModelConstrained_deconstructor_668(nargout, out, nargin-1, in+1);
      break;
    case 669:
      gtsamnoiseModelConstrained_R_669(nargout, out, nargin-1, in+1);
      break;
    case 670:
      gtsamnoiseModelConstrained_equals_670(nargout, out, nargin-1, in+1);
      break;
    case 671:
      gtsamnoiseModelConstrained_print_671(nargout, out, nargin-1, in+1);
      break;
    case 672:
      gtsamnoiseModelConstrained_unit_672(nargout, out, nargin-1, in+1);
      break;
    case 673:
      gtsamnoiseModelConstrained_All_673(nargout, out, nargin-1, in+1);
      break;
    case 674:
      gtsamnoiseModelConstrained_All_674(nargout, out, nargin-1, in+1);
      break;
    case 675:
      gtsamnoiseModelConstrained_MixedPrecisions_675(nargout, out, nargin-1, in+1);
      break;
    case 676:
      gtsamnoiseModelConstrained_MixedPrecisions_676(nargout, out, nargin-1, in+1);
      break;
    case 677:
      gtsamnoiseModelConstrained_MixedSigmas_677(nargout, out, nargin-1, in+1);
      break;
    case 678:
      gtsamnoiseModelConstrained_MixedSigmas_678(nargout, out, nargin-1, in+1);
      break;
    case 679:
      gtsamnoiseModelConstrained_MixedVariances_679(nargout, out, nargin-1, in+1);
      break;
    case 680:
      gtsamnoiseModelConstrained_MixedVariances_680(nargout, out, nargin-1, in+1);
      break;
    case 681:
      gtsamnoiseModelIsotropic_collectorInsertAndMakeBase_681(nargout, out, nargin-1, in+1);
      break;
    case 682:
      gtsamnoiseModelIsotropic_upcastFromVoid_682(nargout, out, nargin-1, in+1);
      break;
    case 683:
      gtsamnoiseModelIsotropic_deconstructor_683(nargout, out, nargin-1, in+1);
      break;
    case 684:
      gtsamnoiseModelIsotropic_R_684(nargout, out, nargin-1, in+1);
      break;
    case 685:
      gtsamnoiseModelIsotropic_equals_685(nargout, out, nargin-1, in+1);
      break;
    case 686:
      gtsamnoiseModelIsotropic_print_686(nargout, out, nargin-1, in+1);
      break;
    case 687:
      gtsamnoiseModelIsotropic_Precision_687(nargout, out, nargin-1, in+1);
      break;
    case 688:
      gtsamnoiseModelIsotropic_Sigma_688(nargout, out, nargin-1, in+1);
      break;
    case 689:
      gtsamnoiseModelIsotropic_Variance_689(nargout, out, nargin-1, in+1);
      break;
    case 690:
      gtsamnoiseModelUnit_collectorInsertAndMakeBase_690(nargout, out, nargin-1, in+1);
      break;
    case 691:
      gtsamnoiseModelUnit_upcastFromVoid_691(nargout, out, nargin-1, in+1);
      break;
    case 692:
      gtsamnoiseModelUnit_deconstructor_692(nargout, out, nargin-1, in+1);
      break;
    case 693:
      gtsamnoiseModelUnit_R_693(nargout, out, nargin-1, in+1);
      break;
    case 694:
      gtsamnoiseModelUnit_equals_694(nargout, out, nargin-1, in+1);
      break;
    case 695:
      gtsamnoiseModelUnit_print_695(nargout, out, nargin-1, in+1);
      break;
    case 696:
      gtsamnoiseModelUnit_Create_696(nargout, out, nargin-1, in+1);
      break;
    case 697:
      gtsamnoiseModelmEstimatorBase_collectorInsertAndMakeBase_697(nargout, out, nargin-1, in+1);
      break;
    case 698:
      gtsamnoiseModelmEstimatorBase_upcastFromVoid_698(nargout, out, nargin-1, in+1);
      break;
    case 699:
      gtsamnoiseModelmEstimatorBase_deconstructor_699(nargout, out, nargin-1, in+1);
      break;
    case 700:
      gtsamnoiseModelmEstimatorNull_collectorInsertAndMakeBase_700(nargout, out, nargin-1, in+1);
      break;
    case 701:
      gtsamnoiseModelmEstimatorNull_upcastFromVoid_701(nargout, out, nargin-1, in+1);
      break;
    case 702:
      gtsamnoiseModelmEstimatorNull_constructor_702(nargout, out, nargin-1, in+1);
      break;
    case 703:
      gtsamnoiseModelmEstimatorNull_deconstructor_703(nargout, out, nargin-1, in+1);
      break;
    case 704:
      gtsamnoiseModelmEstimatorNull_print_704(nargout, out, nargin-1, in+1);
      break;
    case 705:
      gtsamnoiseModelmEstimatorNull_Create_705(nargout, out, nargin-1, in+1);
      break;
    case 706:
      gtsamnoiseModelmEstimatorFair_collectorInsertAndMakeBase_706(nargout, out, nargin-1, in+1);
      break;
    case 707:
      gtsamnoiseModelmEstimatorFair_upcastFromVoid_707(nargout, out, nargin-1, in+1);
      break;
    case 708:
      gtsamnoiseModelmEstimatorFair_constructor_708(nargout, out, nargin-1, in+1);
      break;
    case 709:
      gtsamnoiseModelmEstimatorFair_deconstructor_709(nargout, out, nargin-1, in+1);
      break;
    case 710:
      gtsamnoiseModelmEstimatorFair_print_710(nargout, out, nargin-1, in+1);
      break;
    case 711:
      gtsamnoiseModelmEstimatorFair_Create_711(nargout, out, nargin-1, in+1);
      break;
    case 712:
      gtsamnoiseModelmEstimatorHuber_collectorInsertAndMakeBase_712(nargout, out, nargin-1, in+1);
      break;
    case 713:
      gtsamnoiseModelmEstimatorHuber_upcastFromVoid_713(nargout, out, nargin-1, in+1);
      break;
    case 714:
      gtsamnoiseModelmEstimatorHuber_constructor_714(nargout, out, nargin-1, in+1);
      break;
    case 715:
      gtsamnoiseModelmEstimatorHuber_deconstructor_715(nargout, out, nargin-1, in+1);
      break;
    case 716:
      gtsamnoiseModelmEstimatorHuber_print_716(nargout, out, nargin-1, in+1);
      break;
    case 717:
      gtsamnoiseModelmEstimatorHuber_Create_717(nargout, out, nargin-1, in+1);
      break;
    case 718:
      gtsamnoiseModelmEstimatorTukey_collectorInsertAndMakeBase_718(nargout, out, nargin-1, in+1);
      break;
    case 719:
      gtsamnoiseModelmEstimatorTukey_upcastFromVoid_719(nargout, out, nargin-1, in+1);
      break;
    case 720:
      gtsamnoiseModelmEstimatorTukey_constructor_720(nargout, out, nargin-1, in+1);
      break;
    case 721:
      gtsamnoiseModelmEstimatorTukey_deconstructor_721(nargout, out, nargin-1, in+1);
      break;
    case 722:
      gtsamnoiseModelmEstimatorTukey_print_722(nargout, out, nargin-1, in+1);
      break;
    case 723:
      gtsamnoiseModelmEstimatorTukey_Create_723(nargout, out, nargin-1, in+1);
      break;
    case 724:
      gtsamnoiseModelRobust_collectorInsertAndMakeBase_724(nargout, out, nargin-1, in+1);
      break;
    case 725:
      gtsamnoiseModelRobust_upcastFromVoid_725(nargout, out, nargin-1, in+1);
      break;
    case 726:
      gtsamnoiseModelRobust_constructor_726(nargout, out, nargin-1, in+1);
      break;
    case 727:
      gtsamnoiseModelRobust_deconstructor_727(nargout, out, nargin-1, in+1);
      break;
    case 728:
      gtsamnoiseModelRobust_print_728(nargout, out, nargin-1, in+1);
      break;
    case 729:
      gtsamnoiseModelRobust_Create_729(nargout, out, nargin-1, in+1);
      break;
    case 730:
      gtsamSampler_collectorInsertAndMakeBase_730(nargout, out, nargin-1, in+1);
      break;
    case 731:
      gtsamSampler_constructor_731(nargout, out, nargin-1, in+1);
      break;
    case 732:
      gtsamSampler_constructor_732(nargout, out, nargin-1, in+1);
      break;
    case 733:
      gtsamSampler_constructor_733(nargout, out, nargin-1, in+1);
      break;
    case 734:
      gtsamSampler_deconstructor_734(nargout, out, nargin-1, in+1);
      break;
    case 735:
      gtsamSampler_dim_735(nargout, out, nargin-1, in+1);
      break;
    case 736:
      gtsamSampler_model_736(nargout, out, nargin-1, in+1);
      break;
    case 737:
      gtsamSampler_sample_737(nargout, out, nargin-1, in+1);
      break;
    case 738:
      gtsamSampler_sampleNewModel_738(nargout, out, nargin-1, in+1);
      break;
    case 739:
      gtsamSampler_sigmas_739(nargout, out, nargin-1, in+1);
      break;
    case 740:
      gtsamVectorValues_collectorInsertAndMakeBase_740(nargout, out, nargin-1, in+1);
      break;
    case 741:
      gtsamVectorValues_constructor_741(nargout, out, nargin-1, in+1);
      break;
    case 742:
      gtsamVectorValues_constructor_742(nargout, out, nargin-1, in+1);
      break;
    case 743:
      gtsamVectorValues_deconstructor_743(nargout, out, nargin-1, in+1);
      break;
    case 744:
      gtsamVectorValues_add_744(nargout, out, nargin-1, in+1);
      break;
    case 745:
      gtsamVectorValues_addInPlace_745(nargout, out, nargin-1, in+1);
      break;
    case 746:
      gtsamVectorValues_at_746(nargout, out, nargin-1, in+1);
      break;
    case 747:
      gtsamVectorValues_dim_747(nargout, out, nargin-1, in+1);
      break;
    case 748:
      gtsamVectorValues_dot_748(nargout, out, nargin-1, in+1);
      break;
    case 749:
      gtsamVectorValues_equals_749(nargout, out, nargin-1, in+1);
      break;
    case 750:
      gtsamVectorValues_exists_750(nargout, out, nargin-1, in+1);
      break;
    case 751:
      gtsamVectorValues_hasSameStructure_751(nargout, out, nargin-1, in+1);
      break;
    case 752:
      gtsamVectorValues_insert_752(nargout, out, nargin-1, in+1);
      break;
    case 753:
      gtsamVectorValues_norm_753(nargout, out, nargin-1, in+1);
      break;
    case 754:
      gtsamVectorValues_print_754(nargout, out, nargin-1, in+1);
      break;
    case 755:
      gtsamVectorValues_scale_755(nargout, out, nargin-1, in+1);
      break;
    case 756:
      gtsamVectorValues_scaleInPlace_756(nargout, out, nargin-1, in+1);
      break;
    case 757:
      gtsamVectorValues_setZero_757(nargout, out, nargin-1, in+1);
      break;
    case 758:
      gtsamVectorValues_size_758(nargout, out, nargin-1, in+1);
      break;
    case 759:
      gtsamVectorValues_squaredNorm_759(nargout, out, nargin-1, in+1);
      break;
    case 760:
      gtsamVectorValues_subtract_760(nargout, out, nargin-1, in+1);
      break;
    case 761:
      gtsamVectorValues_update_761(nargout, out, nargin-1, in+1);
      break;
    case 762:
      gtsamVectorValues_vector_762(nargout, out, nargin-1, in+1);
      break;
    case 763:
      gtsamVectorValues_string_serialize_763(nargout, out, nargin-1, in+1);
      break;
    case 764:
      gtsamVectorValues_Zero_764(nargout, out, nargin-1, in+1);
      break;
    case 765:
      gtsamVectorValues_string_deserialize_765(nargout, out, nargin-1, in+1);
      break;
    case 766:
      gtsamGaussianFactor_collectorInsertAndMakeBase_766(nargout, out, nargin-1, in+1);
      break;
    case 767:
      gtsamGaussianFactor_upcastFromVoid_767(nargout, out, nargin-1, in+1);
      break;
    case 768:
      gtsamGaussianFactor_deconstructor_768(nargout, out, nargin-1, in+1);
      break;
    case 769:
      gtsamGaussianFactor_augmentedInformation_769(nargout, out, nargin-1, in+1);
      break;
    case 770:
      gtsamGaussianFactor_augmentedJacobian_770(nargout, out, nargin-1, in+1);
      break;
    case 771:
      gtsamGaussianFactor_clone_771(nargout, out, nargin-1, in+1);
      break;
    case 772:
      gtsamGaussianFactor_empty_772(nargout, out, nargin-1, in+1);
      break;
    case 773:
      gtsamGaussianFactor_equals_773(nargout, out, nargin-1, in+1);
      break;
    case 774:
      gtsamGaussianFactor_error_774(nargout, out, nargin-1, in+1);
      break;
    case 775:
      gtsamGaussianFactor_information_775(nargout, out, nargin-1, in+1);
      break;
    case 776:
      gtsamGaussianFactor_jacobian_776(nargout, out, nargin-1, in+1);
      break;
    case 777:
      gtsamGaussianFactor_keys_777(nargout, out, nargin-1, in+1);
      break;
    case 778:
      gtsamGaussianFactor_negate_778(nargout, out, nargin-1, in+1);
      break;
    case 779:
      gtsamGaussianFactor_print_779(nargout, out, nargin-1, in+1);
      break;
    case 780:
      gtsamGaussianFactor_size_780(nargout, out, nargin-1, in+1);
      break;
    case 781:
      gtsamJacobianFactor_collectorInsertAndMakeBase_781(nargout, out, nargin-1, in+1);
      break;
    case 782:
      gtsamJacobianFactor_upcastFromVoid_782(nargout, out, nargin-1, in+1);
      break;
    case 783:
      gtsamJacobianFactor_constructor_783(nargout, out, nargin-1, in+1);
      break;
    case 784:
      gtsamJacobianFactor_constructor_784(nargout, out, nargin-1, in+1);
      break;
    case 785:
      gtsamJacobianFactor_constructor_785(nargout, out, nargin-1, in+1);
      break;
    case 786:
      gtsamJacobianFactor_constructor_786(nargout, out, nargin-1, in+1);
      break;
    case 787:
      gtsamJacobianFactor_constructor_787(nargout, out, nargin-1, in+1);
      break;
    case 788:
      gtsamJacobianFactor_constructor_788(nargout, out, nargin-1, in+1);
      break;
    case 789:
      gtsamJacobianFactor_constructor_789(nargout, out, nargin-1, in+1);
      break;
    case 790:
      gtsamJacobianFactor_deconstructor_790(nargout, out, nargin-1, in+1);
      break;
    case 791:
      gtsamJacobianFactor_augmentedInformation_791(nargout, out, nargin-1, in+1);
      break;
    case 792:
      gtsamJacobianFactor_augmentedJacobian_792(nargout, out, nargin-1, in+1);
      break;
    case 793:
      gtsamJacobianFactor_augmentedJacobianUnweighted_793(nargout, out, nargin-1, in+1);
      break;
    case 794:
      gtsamJacobianFactor_clone_794(nargout, out, nargin-1, in+1);
      break;
    case 795:
      gtsamJacobianFactor_cols_795(nargout, out, nargin-1, in+1);
      break;
    case 796:
      gtsamJacobianFactor_eliminate_796(nargout, out, nargin-1, in+1);
      break;
    case 797:
      gtsamJacobianFactor_empty_797(nargout, out, nargin-1, in+1);
      break;
    case 798:
      gtsamJacobianFactor_equals_798(nargout, out, nargin-1, in+1);
      break;
    case 799:
      gtsamJacobianFactor_error_799(nargout, out, nargin-1, in+1);
      break;
    case 800:
      gtsamJacobianFactor_error_vector_800(nargout, out, nargin-1, in+1);
      break;
    case 801:
      gtsamJacobianFactor_getA_801(nargout, out, nargin-1, in+1);
      break;
    case 802:
      gtsamJacobianFactor_get_model_802(nargout, out, nargin-1, in+1);
      break;
    case 803:
      gtsamJacobianFactor_getb_803(nargout, out, nargin-1, in+1);
      break;
    case 804:
      gtsamJacobianFactor_information_804(nargout, out, nargin-1, in+1);
      break;
    case 805:
      gtsamJacobianFactor_isConstrained_805(nargout, out, nargin-1, in+1);
      break;
    case 806:
      gtsamJacobianFactor_jacobian_806(nargout, out, nargin-1, in+1);
      break;
    case 807:
      gtsamJacobianFactor_jacobianUnweighted_807(nargout, out, nargin-1, in+1);
      break;
    case 808:
      gtsamJacobianFactor_keys_808(nargout, out, nargin-1, in+1);
      break;
    case 809:
      gtsamJacobianFactor_negate_809(nargout, out, nargin-1, in+1);
      break;
    case 810:
      gtsamJacobianFactor_print_810(nargout, out, nargin-1, in+1);
      break;
    case 811:
      gtsamJacobianFactor_printKeys_811(nargout, out, nargin-1, in+1);
      break;
    case 812:
      gtsamJacobianFactor_rows_812(nargout, out, nargin-1, in+1);
      break;
    case 813:
      gtsamJacobianFactor_setModel_813(nargout, out, nargin-1, in+1);
      break;
    case 814:
      gtsamJacobianFactor_size_814(nargout, out, nargin-1, in+1);
      break;
    case 815:
      gtsamJacobianFactor_transposeMultiplyAdd_815(nargout, out, nargin-1, in+1);
      break;
    case 816:
      gtsamJacobianFactor_unweighted_error_816(nargout, out, nargin-1, in+1);
      break;
    case 817:
      gtsamJacobianFactor_whiten_817(nargout, out, nargin-1, in+1);
      break;
    case 818:
      gtsamJacobianFactor_string_serialize_818(nargout, out, nargin-1, in+1);
      break;
    case 819:
      gtsamJacobianFactor_string_deserialize_819(nargout, out, nargin-1, in+1);
      break;
    case 820:
      gtsamHessianFactor_collectorInsertAndMakeBase_820(nargout, out, nargin-1, in+1);
      break;
    case 821:
      gtsamHessianFactor_upcastFromVoid_821(nargout, out, nargin-1, in+1);
      break;
    case 822:
      gtsamHessianFactor_constructor_822(nargout, out, nargin-1, in+1);
      break;
    case 823:
      gtsamHessianFactor_constructor_823(nargout, out, nargin-1, in+1);
      break;
    case 824:
      gtsamHessianFactor_constructor_824(nargout, out, nargin-1, in+1);
      break;
    case 825:
      gtsamHessianFactor_constructor_825(nargout, out, nargin-1, in+1);
      break;
    case 826:
      gtsamHessianFactor_constructor_826(nargout, out, nargin-1, in+1);
      break;
    case 827:
      gtsamHessianFactor_constructor_827(nargout, out, nargin-1, in+1);
      break;
    case 828:
      gtsamHessianFactor_constructor_828(nargout, out, nargin-1, in+1);
      break;
    case 829:
      gtsamHessianFactor_deconstructor_829(nargout, out, nargin-1, in+1);
      break;
    case 830:
      gtsamHessianFactor_augmentedInformation_830(nargout, out, nargin-1, in+1);
      break;
    case 831:
      gtsamHessianFactor_augmentedJacobian_831(nargout, out, nargin-1, in+1);
      break;
    case 832:
      gtsamHessianFactor_clone_832(nargout, out, nargin-1, in+1);
      break;
    case 833:
      gtsamHessianFactor_constantTerm_833(nargout, out, nargin-1, in+1);
      break;
    case 834:
      gtsamHessianFactor_empty_834(nargout, out, nargin-1, in+1);
      break;
    case 835:
      gtsamHessianFactor_equals_835(nargout, out, nargin-1, in+1);
      break;
    case 836:
      gtsamHessianFactor_error_836(nargout, out, nargin-1, in+1);
      break;
    case 837:
      gtsamHessianFactor_information_837(nargout, out, nargin-1, in+1);
      break;
    case 838:
      gtsamHessianFactor_jacobian_838(nargout, out, nargin-1, in+1);
      break;
    case 839:
      gtsamHessianFactor_keys_839(nargout, out, nargin-1, in+1);
      break;
    case 840:
      gtsamHessianFactor_linearTerm_840(nargout, out, nargin-1, in+1);
      break;
    case 841:
      gtsamHessianFactor_negate_841(nargout, out, nargin-1, in+1);
      break;
    case 842:
      gtsamHessianFactor_print_842(nargout, out, nargin-1, in+1);
      break;
    case 843:
      gtsamHessianFactor_printKeys_843(nargout, out, nargin-1, in+1);
      break;
    case 844:
      gtsamHessianFactor_rows_844(nargout, out, nargin-1, in+1);
      break;
    case 845:
      gtsamHessianFactor_size_845(nargout, out, nargin-1, in+1);
      break;
    case 846:
      gtsamHessianFactor_string_serialize_846(nargout, out, nargin-1, in+1);
      break;
    case 847:
      gtsamHessianFactor_string_deserialize_847(nargout, out, nargin-1, in+1);
      break;
    case 848:
      gtsamGaussianFactorGraph_collectorInsertAndMakeBase_848(nargout, out, nargin-1, in+1);
      break;
    case 849:
      gtsamGaussianFactorGraph_constructor_849(nargout, out, nargin-1, in+1);
      break;
    case 850:
      gtsamGaussianFactorGraph_constructor_850(nargout, out, nargin-1, in+1);
      break;
    case 851:
      gtsamGaussianFactorGraph_constructor_851(nargout, out, nargin-1, in+1);
      break;
    case 852:
      gtsamGaussianFactorGraph_deconstructor_852(nargout, out, nargin-1, in+1);
      break;
    case 853:
      gtsamGaussianFactorGraph_add_853(nargout, out, nargin-1, in+1);
      break;
    case 854:
      gtsamGaussianFactorGraph_add_854(nargout, out, nargin-1, in+1);
      break;
    case 855:
      gtsamGaussianFactorGraph_add_855(nargout, out, nargin-1, in+1);
      break;
    case 856:
      gtsamGaussianFactorGraph_add_856(nargout, out, nargin-1, in+1);
      break;
    case 857:
      gtsamGaussianFactorGraph_add_857(nargout, out, nargin-1, in+1);
      break;
    case 858:
      gtsamGaussianFactorGraph_at_858(nargout, out, nargin-1, in+1);
      break;
    case 859:
      gtsamGaussianFactorGraph_augmentedHessian_859(nargout, out, nargin-1, in+1);
      break;
    case 860:
      gtsamGaussianFactorGraph_augmentedHessian_860(nargout, out, nargin-1, in+1);
      break;
    case 861:
      gtsamGaussianFactorGraph_augmentedJacobian_861(nargout, out, nargin-1, in+1);
      break;
    case 862:
      gtsamGaussianFactorGraph_augmentedJacobian_862(nargout, out, nargin-1, in+1);
      break;
    case 863:
      gtsamGaussianFactorGraph_clone_863(nargout, out, nargin-1, in+1);
      break;
    case 864:
      gtsamGaussianFactorGraph_eliminateMultifrontal_864(nargout, out, nargin-1, in+1);
      break;
    case 865:
      gtsamGaussianFactorGraph_eliminateMultifrontal_865(nargout, out, nargin-1, in+1);
      break;
    case 866:
      gtsamGaussianFactorGraph_eliminatePartialMultifrontal_866(nargout, out, nargin-1, in+1);
      break;
    case 867:
      gtsamGaussianFactorGraph_eliminatePartialMultifrontal_867(nargout, out, nargin-1, in+1);
      break;
    case 868:
      gtsamGaussianFactorGraph_eliminatePartialSequential_868(nargout, out, nargin-1, in+1);
      break;
    case 869:
      gtsamGaussianFactorGraph_eliminatePartialSequential_869(nargout, out, nargin-1, in+1);
      break;
    case 870:
      gtsamGaussianFactorGraph_eliminateSequential_870(nargout, out, nargin-1, in+1);
      break;
    case 871:
      gtsamGaussianFactorGraph_eliminateSequential_871(nargout, out, nargin-1, in+1);
      break;
    case 872:
      gtsamGaussianFactorGraph_equals_872(nargout, out, nargin-1, in+1);
      break;
    case 873:
      gtsamGaussianFactorGraph_error_873(nargout, out, nargin-1, in+1);
      break;
    case 874:
      gtsamGaussianFactorGraph_exists_874(nargout, out, nargin-1, in+1);
      break;
    case 875:
      gtsamGaussianFactorGraph_gradient_875(nargout, out, nargin-1, in+1);
      break;
    case 876:
      gtsamGaussianFactorGraph_gradientAtZero_876(nargout, out, nargin-1, in+1);
      break;
    case 877:
      gtsamGaussianFactorGraph_hessian_877(nargout, out, nargin-1, in+1);
      break;
    case 878:
      gtsamGaussianFactorGraph_hessian_878(nargout, out, nargin-1, in+1);
      break;
    case 879:
      gtsamGaussianFactorGraph_jacobian_879(nargout, out, nargin-1, in+1);
      break;
    case 880:
      gtsamGaussianFactorGraph_jacobian_880(nargout, out, nargin-1, in+1);
      break;
    case 881:
      gtsamGaussianFactorGraph_keyVector_881(nargout, out, nargin-1, in+1);
      break;
    case 882:
      gtsamGaussianFactorGraph_keys_882(nargout, out, nargin-1, in+1);
      break;
    case 883:
      gtsamGaussianFactorGraph_marginal_883(nargout, out, nargin-1, in+1);
      break;
    case 884:
      gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_884(nargout, out, nargin-1, in+1);
      break;
    case 885:
      gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_885(nargout, out, nargin-1, in+1);
      break;
    case 886:
      gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_886(nargout, out, nargin-1, in+1);
      break;
    case 887:
      gtsamGaussianFactorGraph_marginalMultifrontalBayesNet_887(nargout, out, nargin-1, in+1);
      break;
    case 888:
      gtsamGaussianFactorGraph_negate_888(nargout, out, nargin-1, in+1);
      break;
    case 889:
      gtsamGaussianFactorGraph_optimize_889(nargout, out, nargin-1, in+1);
      break;
    case 890:
      gtsamGaussianFactorGraph_optimize_890(nargout, out, nargin-1, in+1);
      break;
    case 891:
      gtsamGaussianFactorGraph_optimizeGradientSearch_891(nargout, out, nargin-1, in+1);
      break;
    case 892:
      gtsamGaussianFactorGraph_print_892(nargout, out, nargin-1, in+1);
      break;
    case 893:
      gtsamGaussianFactorGraph_probPrime_893(nargout, out, nargin-1, in+1);
      break;
    case 894:
      gtsamGaussianFactorGraph_push_back_894(nargout, out, nargin-1, in+1);
      break;
    case 895:
      gtsamGaussianFactorGraph_push_back_895(nargout, out, nargin-1, in+1);
      break;
    case 896:
      gtsamGaussianFactorGraph_push_back_896(nargout, out, nargin-1, in+1);
      break;
    case 897:
      gtsamGaussianFactorGraph_push_back_897(nargout, out, nargin-1, in+1);
      break;
    case 898:
      gtsamGaussianFactorGraph_push_back_898(nargout, out, nargin-1, in+1);
      break;
    case 899:
      gtsamGaussianFactorGraph_size_899(nargout, out, nargin-1, in+1);
      break;
    case 900:
      gtsamGaussianFactorGraph_sparseJacobian__900(nargout, out, nargin-1, in+1);
      break;
    case 901:
      gtsamGaussianFactorGraph_string_serialize_901(nargout, out, nargin-1, in+1);
      break;
    case 902:
      gtsamGaussianFactorGraph_string_deserialize_902(nargout, out, nargin-1, in+1);
      break;
    case 903:
      gtsamGaussianConditional_collectorInsertAndMakeBase_903(nargout, out, nargin-1, in+1);
      break;
    case 904:
      gtsamGaussianConditional_upcastFromVoid_904(nargout, out, nargin-1, in+1);
      break;
    case 905:
      gtsamGaussianConditional_constructor_905(nargout, out, nargin-1, in+1);
      break;
    case 906:
      gtsamGaussianConditional_constructor_906(nargout, out, nargin-1, in+1);
      break;
    case 907:
      gtsamGaussianConditional_constructor_907(nargout, out, nargin-1, in+1);
      break;
    case 908:
      gtsamGaussianConditional_constructor_908(nargout, out, nargin-1, in+1);
      break;
    case 909:
      gtsamGaussianConditional_constructor_909(nargout, out, nargin-1, in+1);
      break;
    case 910:
      gtsamGaussianConditional_constructor_910(nargout, out, nargin-1, in+1);
      break;
    case 911:
      gtsamGaussianConditional_deconstructor_911(nargout, out, nargin-1, in+1);
      break;
    case 912:
      gtsamGaussianConditional_augmentedInformation_912(nargout, out, nargin-1, in+1);
      break;
    case 913:
      gtsamGaussianConditional_augmentedJacobian_913(nargout, out, nargin-1, in+1);
      break;
    case 914:
      gtsamGaussianConditional_clone_914(nargout, out, nargin-1, in+1);
      break;
    case 915:
      gtsamGaussianConditional_empty_915(nargout, out, nargin-1, in+1);
      break;
    case 916:
      gtsamGaussianConditional_equals_916(nargout, out, nargin-1, in+1);
      break;
    case 917:
      gtsamGaussianConditional_error_917(nargout, out, nargin-1, in+1);
      break;
    case 918:
      gtsamGaussianConditional_information_918(nargout, out, nargin-1, in+1);
      break;
    case 919:
      gtsamGaussianConditional_jacobian_919(nargout, out, nargin-1, in+1);
      break;
    case 920:
      gtsamGaussianConditional_keys_920(nargout, out, nargin-1, in+1);
      break;
    case 921:
      gtsamGaussianConditional_negate_921(nargout, out, nargin-1, in+1);
      break;
    case 922:
      gtsamGaussianConditional_print_922(nargout, out, nargin-1, in+1);
      break;
    case 923:
      gtsamGaussianConditional_scaleFrontalsBySigma_923(nargout, out, nargin-1, in+1);
      break;
    case 924:
      gtsamGaussianConditional_size_924(nargout, out, nargin-1, in+1);
      break;
    case 925:
      gtsamGaussianConditional_solve_925(nargout, out, nargin-1, in+1);
      break;
    case 926:
      gtsamGaussianConditional_solveOtherRHS_926(nargout, out, nargin-1, in+1);
      break;
    case 927:
      gtsamGaussianConditional_solveTransposeInPlace_927(nargout, out, nargin-1, in+1);
      break;
    case 928:
      gtsamGaussianConditional_string_serialize_928(nargout, out, nargin-1, in+1);
      break;
    case 929:
      gtsamGaussianConditional_string_deserialize_929(nargout, out, nargin-1, in+1);
      break;
    case 930:
      gtsamGaussianDensity_collectorInsertAndMakeBase_930(nargout, out, nargin-1, in+1);
      break;
    case 931:
      gtsamGaussianDensity_upcastFromVoid_931(nargout, out, nargin-1, in+1);
      break;
    case 932:
      gtsamGaussianDensity_constructor_932(nargout, out, nargin-1, in+1);
      break;
    case 933:
      gtsamGaussianDensity_deconstructor_933(nargout, out, nargin-1, in+1);
      break;
    case 934:
      gtsamGaussianDensity_augmentedInformation_934(nargout, out, nargin-1, in+1);
      break;
    case 935:
      gtsamGaussianDensity_augmentedJacobian_935(nargout, out, nargin-1, in+1);
      break;
    case 936:
      gtsamGaussianDensity_clone_936(nargout, out, nargin-1, in+1);
      break;
    case 937:
      gtsamGaussianDensity_covariance_937(nargout, out, nargin-1, in+1);
      break;
    case 938:
      gtsamGaussianDensity_empty_938(nargout, out, nargin-1, in+1);
      break;
    case 939:
      gtsamGaussianDensity_equals_939(nargout, out, nargin-1, in+1);
      break;
    case 940:
      gtsamGaussianDensity_error_940(nargout, out, nargin-1, in+1);
      break;
    case 941:
      gtsamGaussianDensity_information_941(nargout, out, nargin-1, in+1);
      break;
    case 942:
      gtsamGaussianDensity_jacobian_942(nargout, out, nargin-1, in+1);
      break;
    case 943:
      gtsamGaussianDensity_keys_943(nargout, out, nargin-1, in+1);
      break;
    case 944:
      gtsamGaussianDensity_mean_944(nargout, out, nargin-1, in+1);
      break;
    case 945:
      gtsamGaussianDensity_negate_945(nargout, out, nargin-1, in+1);
      break;
    case 946:
      gtsamGaussianDensity_print_946(nargout, out, nargin-1, in+1);
      break;
    case 947:
      gtsamGaussianDensity_scaleFrontalsBySigma_947(nargout, out, nargin-1, in+1);
      break;
    case 948:
      gtsamGaussianDensity_size_948(nargout, out, nargin-1, in+1);
      break;
    case 949:
      gtsamGaussianDensity_solve_949(nargout, out, nargin-1, in+1);
      break;
    case 950:
      gtsamGaussianDensity_solveOtherRHS_950(nargout, out, nargin-1, in+1);
      break;
    case 951:
      gtsamGaussianDensity_solveTransposeInPlace_951(nargout, out, nargin-1, in+1);
      break;
    case 952:
      gtsamGaussianBayesNet_collectorInsertAndMakeBase_952(nargout, out, nargin-1, in+1);
      break;
    case 953:
      gtsamGaussianBayesNet_upcastFromVoid_953(nargout, out, nargin-1, in+1);
      break;
    case 954:
      gtsamGaussianBayesNet_constructor_954(nargout, out, nargin-1, in+1);
      break;
    case 955:
      gtsamGaussianBayesNet_constructor_955(nargout, out, nargin-1, in+1);
      break;
    case 956:
      gtsamGaussianBayesNet_deconstructor_956(nargout, out, nargin-1, in+1);
      break;
    case 957:
      gtsamGaussianBayesNet_at_957(nargout, out, nargin-1, in+1);
      break;
    case 958:
      gtsamGaussianBayesNet_back_958(nargout, out, nargin-1, in+1);
      break;
    case 959:
      gtsamGaussianBayesNet_backSubstitute_959(nargout, out, nargin-1, in+1);
      break;
    case 960:
      gtsamGaussianBayesNet_backSubstituteTranspose_960(nargout, out, nargin-1, in+1);
      break;
    case 961:
      gtsamGaussianBayesNet_determinant_961(nargout, out, nargin-1, in+1);
      break;
    case 962:
      gtsamGaussianBayesNet_equals_962(nargout, out, nargin-1, in+1);
      break;
    case 963:
      gtsamGaussianBayesNet_error_963(nargout, out, nargin-1, in+1);
      break;
    case 964:
      gtsamGaussianBayesNet_exists_964(nargout, out, nargin-1, in+1);
      break;
    case 965:
      gtsamGaussianBayesNet_front_965(nargout, out, nargin-1, in+1);
      break;
    case 966:
      gtsamGaussianBayesNet_gradient_966(nargout, out, nargin-1, in+1);
      break;
    case 967:
      gtsamGaussianBayesNet_gradientAtZero_967(nargout, out, nargin-1, in+1);
      break;
    case 968:
      gtsamGaussianBayesNet_keys_968(nargout, out, nargin-1, in+1);
      break;
    case 969:
      gtsamGaussianBayesNet_logDeterminant_969(nargout, out, nargin-1, in+1);
      break;
    case 970:
      gtsamGaussianBayesNet_optimize_970(nargout, out, nargin-1, in+1);
      break;
    case 971:
      gtsamGaussianBayesNet_optimize_971(nargout, out, nargin-1, in+1);
      break;
    case 972:
      gtsamGaussianBayesNet_optimizeGradientSearch_972(nargout, out, nargin-1, in+1);
      break;
    case 973:
      gtsamGaussianBayesNet_print_973(nargout, out, nargin-1, in+1);
      break;
    case 974:
      gtsamGaussianBayesNet_push_back_974(nargout, out, nargin-1, in+1);
      break;
    case 975:
      gtsamGaussianBayesNet_push_back_975(nargout, out, nargin-1, in+1);
      break;
    case 976:
      gtsamGaussianBayesNet_size_976(nargout, out, nargin-1, in+1);
      break;
    case 977:
      gtsamGaussianBayesTree_collectorInsertAndMakeBase_977(nargout, out, nargin-1, in+1);
      break;
    case 978:
      gtsamGaussianBayesTree_upcastFromVoid_978(nargout, out, nargin-1, in+1);
      break;
    case 979:
      gtsamGaussianBayesTree_constructor_979(nargout, out, nargin-1, in+1);
      break;
    case 980:
      gtsamGaussianBayesTree_constructor_980(nargout, out, nargin-1, in+1);
      break;
    case 981:
      gtsamGaussianBayesTree_deconstructor_981(nargout, out, nargin-1, in+1);
      break;
    case 982:
      gtsamGaussianBayesTree_determinant_982(nargout, out, nargin-1, in+1);
      break;
    case 983:
      gtsamGaussianBayesTree_empty_983(nargout, out, nargin-1, in+1);
      break;
    case 984:
      gtsamGaussianBayesTree_equals_984(nargout, out, nargin-1, in+1);
      break;
    case 985:
      gtsamGaussianBayesTree_error_985(nargout, out, nargin-1, in+1);
      break;
    case 986:
      gtsamGaussianBayesTree_gradient_986(nargout, out, nargin-1, in+1);
      break;
    case 987:
      gtsamGaussianBayesTree_gradientAtZero_987(nargout, out, nargin-1, in+1);
      break;
    case 988:
      gtsamGaussianBayesTree_joint_988(nargout, out, nargin-1, in+1);
      break;
    case 989:
      gtsamGaussianBayesTree_jointBayesNet_989(nargout, out, nargin-1, in+1);
      break;
    case 990:
      gtsamGaussianBayesTree_logDeterminant_990(nargout, out, nargin-1, in+1);
      break;
    case 991:
      gtsamGaussianBayesTree_marginalCovariance_991(nargout, out, nargin-1, in+1);
      break;
    case 992:
      gtsamGaussianBayesTree_marginalFactor_992(nargout, out, nargin-1, in+1);
      break;
    case 993:
      gtsamGaussianBayesTree_numCachedSeparatorMarginals_993(nargout, out, nargin-1, in+1);
      break;
    case 994:
      gtsamGaussianBayesTree_optimize_994(nargout, out, nargin-1, in+1);
      break;
    case 995:
      gtsamGaussianBayesTree_optimizeGradientSearch_995(nargout, out, nargin-1, in+1);
      break;
    case 996:
      gtsamGaussianBayesTree_print_996(nargout, out, nargin-1, in+1);
      break;
    case 997:
      gtsamGaussianBayesTree_saveGraph_997(nargout, out, nargin-1, in+1);
      break;
    case 998:
      gtsamGaussianBayesTree_size_998(nargout, out, nargin-1, in+1);
      break;
    case 999:
      gtsamErrors_collectorInsertAndMakeBase_999(nargout, out, nargin-1, in+1);
      break;
    case 1000:
      gtsamErrors_constructor_1000(nargout, out, nargin-1, in+1);
      break;
    case 1001:
      gtsamErrors_constructor_1001(nargout, out, nargin-1, in+1);
      break;
    case 1002:
      gtsamErrors_deconstructor_1002(nargout, out, nargin-1, in+1);
      break;
    case 1003:
      gtsamErrors_equals_1003(nargout, out, nargin-1, in+1);
      break;
    case 1004:
      gtsamErrors_print_1004(nargout, out, nargin-1, in+1);
      break;
    case 1005:
      gtsamGaussianISAM_collectorInsertAndMakeBase_1005(nargout, out, nargin-1, in+1);
      break;
    case 1006:
      gtsamGaussianISAM_constructor_1006(nargout, out, nargin-1, in+1);
      break;
    case 1007:
      gtsamGaussianISAM_deconstructor_1007(nargout, out, nargin-1, in+1);
      break;
    case 1008:
      gtsamGaussianISAM_clear_1008(nargout, out, nargin-1, in+1);
      break;
    case 1009:
      gtsamGaussianISAM_saveGraph_1009(nargout, out, nargin-1, in+1);
      break;
    case 1010:
      gtsamGaussianISAM_update_1010(nargout, out, nargin-1, in+1);
      break;
    case 1011:
      gtsamIterativeOptimizationParameters_collectorInsertAndMakeBase_1011(nargout, out, nargin-1, in+1);
      break;
    case 1012:
      gtsamIterativeOptimizationParameters_upcastFromVoid_1012(nargout, out, nargin-1, in+1);
      break;
    case 1013:
      gtsamIterativeOptimizationParameters_deconstructor_1013(nargout, out, nargin-1, in+1);
      break;
    case 1014:
      gtsamIterativeOptimizationParameters_getVerbosity_1014(nargout, out, nargin-1, in+1);
      break;
    case 1015:
      gtsamIterativeOptimizationParameters_print_1015(nargout, out, nargin-1, in+1);
      break;
    case 1016:
      gtsamIterativeOptimizationParameters_setVerbosity_1016(nargout, out, nargin-1, in+1);
      break;
    case 1017:
      gtsamConjugateGradientParameters_collectorInsertAndMakeBase_1017(nargout, out, nargin-1, in+1);
      break;
    case 1018:
      gtsamConjugateGradientParameters_upcastFromVoid_1018(nargout, out, nargin-1, in+1);
      break;
    case 1019:
      gtsamConjugateGradientParameters_constructor_1019(nargout, out, nargin-1, in+1);
      break;
    case 1020:
      gtsamConjugateGradientParameters_deconstructor_1020(nargout, out, nargin-1, in+1);
      break;
    case 1021:
      gtsamConjugateGradientParameters_getEpsilon_abs_1021(nargout, out, nargin-1, in+1);
      break;
    case 1022:
      gtsamConjugateGradientParameters_getEpsilon_rel_1022(nargout, out, nargin-1, in+1);
      break;
    case 1023:
      gtsamConjugateGradientParameters_getMaxIterations_1023(nargout, out, nargin-1, in+1);
      break;
    case 1024:
      gtsamConjugateGradientParameters_getMinIterations_1024(nargout, out, nargin-1, in+1);
      break;
    case 1025:
      gtsamConjugateGradientParameters_getReset_1025(nargout, out, nargin-1, in+1);
      break;
    case 1026:
      gtsamConjugateGradientParameters_getVerbosity_1026(nargout, out, nargin-1, in+1);
      break;
    case 1027:
      gtsamConjugateGradientParameters_print_1027(nargout, out, nargin-1, in+1);
      break;
    case 1028:
      gtsamConjugateGradientParameters_setEpsilon_abs_1028(nargout, out, nargin-1, in+1);
      break;
    case 1029:
      gtsamConjugateGradientParameters_setEpsilon_rel_1029(nargout, out, nargin-1, in+1);
      break;
    case 1030:
      gtsamConjugateGradientParameters_setMaxIterations_1030(nargout, out, nargin-1, in+1);
      break;
    case 1031:
      gtsamConjugateGradientParameters_setMinIterations_1031(nargout, out, nargin-1, in+1);
      break;
    case 1032:
      gtsamConjugateGradientParameters_setReset_1032(nargout, out, nargin-1, in+1);
      break;
    case 1033:
      gtsamConjugateGradientParameters_setVerbosity_1033(nargout, out, nargin-1, in+1);
      break;
    case 1034:
      gtsamSubgraphSolverParameters_collectorInsertAndMakeBase_1034(nargout, out, nargin-1, in+1);
      break;
    case 1035:
      gtsamSubgraphSolverParameters_upcastFromVoid_1035(nargout, out, nargin-1, in+1);
      break;
    case 1036:
      gtsamSubgraphSolverParameters_constructor_1036(nargout, out, nargin-1, in+1);
      break;
    case 1037:
      gtsamSubgraphSolverParameters_deconstructor_1037(nargout, out, nargin-1, in+1);
      break;
    case 1038:
      gtsamSubgraphSolverParameters_getEpsilon_abs_1038(nargout, out, nargin-1, in+1);
      break;
    case 1039:
      gtsamSubgraphSolverParameters_getEpsilon_rel_1039(nargout, out, nargin-1, in+1);
      break;
    case 1040:
      gtsamSubgraphSolverParameters_getMaxIterations_1040(nargout, out, nargin-1, in+1);
      break;
    case 1041:
      gtsamSubgraphSolverParameters_getMinIterations_1041(nargout, out, nargin-1, in+1);
      break;
    case 1042:
      gtsamSubgraphSolverParameters_getReset_1042(nargout, out, nargin-1, in+1);
      break;
    case 1043:
      gtsamSubgraphSolverParameters_getVerbosity_1043(nargout, out, nargin-1, in+1);
      break;
    case 1044:
      gtsamSubgraphSolverParameters_print_1044(nargout, out, nargin-1, in+1);
      break;
    case 1045:
      gtsamSubgraphSolverParameters_setEpsilon_abs_1045(nargout, out, nargin-1, in+1);
      break;
    case 1046:
      gtsamSubgraphSolverParameters_setEpsilon_rel_1046(nargout, out, nargin-1, in+1);
      break;
    case 1047:
      gtsamSubgraphSolverParameters_setMaxIterations_1047(nargout, out, nargin-1, in+1);
      break;
    case 1048:
      gtsamSubgraphSolverParameters_setMinIterations_1048(nargout, out, nargin-1, in+1);
      break;
    case 1049:
      gtsamSubgraphSolverParameters_setReset_1049(nargout, out, nargin-1, in+1);
      break;
    case 1050:
      gtsamSubgraphSolverParameters_setVerbosity_1050(nargout, out, nargin-1, in+1);
      break;
    case 1051:
      gtsamSubgraphSolver_collectorInsertAndMakeBase_1051(nargout, out, nargin-1, in+1);
      break;
    case 1052:
      gtsamSubgraphSolver_upcastFromVoid_1052(nargout, out, nargin-1, in+1);
      break;
    case 1053:
      gtsamSubgraphSolver_constructor_1053(nargout, out, nargin-1, in+1);
      break;
    case 1054:
      gtsamSubgraphSolver_constructor_1054(nargout, out, nargin-1, in+1);
      break;
    case 1055:
      gtsamSubgraphSolver_deconstructor_1055(nargout, out, nargin-1, in+1);
      break;
    case 1056:
      gtsamSubgraphSolver_optimize_1056(nargout, out, nargin-1, in+1);
      break;
    case 1057:
      gtsamKalmanFilter_collectorInsertAndMakeBase_1057(nargout, out, nargin-1, in+1);
      break;
    case 1058:
      gtsamKalmanFilter_constructor_1058(nargout, out, nargin-1, in+1);
      break;
    case 1059:
      gtsamKalmanFilter_deconstructor_1059(nargout, out, nargin-1, in+1);
      break;
    case 1060:
      gtsamKalmanFilter_init_1060(nargout, out, nargin-1, in+1);
      break;
    case 1061:
      gtsamKalmanFilter_predict_1061(nargout, out, nargin-1, in+1);
      break;
    case 1062:
      gtsamKalmanFilter_predict2_1062(nargout, out, nargin-1, in+1);
      break;
    case 1063:
      gtsamKalmanFilter_predictQ_1063(nargout, out, nargin-1, in+1);
      break;
    case 1064:
      gtsamKalmanFilter_print_1064(nargout, out, nargin-1, in+1);
      break;
    case 1065:
      gtsamKalmanFilter_update_1065(nargout, out, nargin-1, in+1);
      break;
    case 1066:
      gtsamKalmanFilter_updateQ_1066(nargout, out, nargin-1, in+1);
      break;
    case 1067:
      gtsamKalmanFilter_step_1067(nargout, out, nargin-1, in+1);
      break;
    case 1068:
      gtsamLabeledSymbol_collectorInsertAndMakeBase_1068(nargout, out, nargin-1, in+1);
      break;
    case 1069:
      gtsamLabeledSymbol_constructor_1069(nargout, out, nargin-1, in+1);
      break;
    case 1070:
      gtsamLabeledSymbol_constructor_1070(nargout, out, nargin-1, in+1);
      break;
    case 1071:
      gtsamLabeledSymbol_constructor_1071(nargout, out, nargin-1, in+1);
      break;
    case 1072:
      gtsamLabeledSymbol_deconstructor_1072(nargout, out, nargin-1, in+1);
      break;
    case 1073:
      gtsamLabeledSymbol_chr_1073(nargout, out, nargin-1, in+1);
      break;
    case 1074:
      gtsamLabeledSymbol_index_1074(nargout, out, nargin-1, in+1);
      break;
    case 1075:
      gtsamLabeledSymbol_key_1075(nargout, out, nargin-1, in+1);
      break;
    case 1076:
      gtsamLabeledSymbol_label_1076(nargout, out, nargin-1, in+1);
      break;
    case 1077:
      gtsamLabeledSymbol_lower_1077(nargout, out, nargin-1, in+1);
      break;
    case 1078:
      gtsamLabeledSymbol_newChr_1078(nargout, out, nargin-1, in+1);
      break;
    case 1079:
      gtsamLabeledSymbol_newLabel_1079(nargout, out, nargin-1, in+1);
      break;
    case 1080:
      gtsamLabeledSymbol_print_1080(nargout, out, nargin-1, in+1);
      break;
    case 1081:
      gtsamLabeledSymbol_upper_1081(nargout, out, nargin-1, in+1);
      break;
    case 1082:
      gtsamOrdering_collectorInsertAndMakeBase_1082(nargout, out, nargin-1, in+1);
      break;
    case 1083:
      gtsamOrdering_constructor_1083(nargout, out, nargin-1, in+1);
      break;
    case 1084:
      gtsamOrdering_constructor_1084(nargout, out, nargin-1, in+1);
      break;
    case 1085:
      gtsamOrdering_deconstructor_1085(nargout, out, nargin-1, in+1);
      break;
    case 1086:
      gtsamOrdering_at_1086(nargout, out, nargin-1, in+1);
      break;
    case 1087:
      gtsamOrdering_equals_1087(nargout, out, nargin-1, in+1);
      break;
    case 1088:
      gtsamOrdering_print_1088(nargout, out, nargin-1, in+1);
      break;
    case 1089:
      gtsamOrdering_push_back_1089(nargout, out, nargin-1, in+1);
      break;
    case 1090:
      gtsamOrdering_size_1090(nargout, out, nargin-1, in+1);
      break;
    case 1091:
      gtsamOrdering_string_serialize_1091(nargout, out, nargin-1, in+1);
      break;
    case 1092:
      gtsamOrdering_string_deserialize_1092(nargout, out, nargin-1, in+1);
      break;
    case 1093:
      gtsamNonlinearFactorGraph_collectorInsertAndMakeBase_1093(nargout, out, nargin-1, in+1);
      break;
    case 1094:
      gtsamNonlinearFactorGraph_constructor_1094(nargout, out, nargin-1, in+1);
      break;
    case 1095:
      gtsamNonlinearFactorGraph_constructor_1095(nargout, out, nargin-1, in+1);
      break;
    case 1096:
      gtsamNonlinearFactorGraph_deconstructor_1096(nargout, out, nargin-1, in+1);
      break;
    case 1097:
      gtsamNonlinearFactorGraph_add_1097(nargout, out, nargin-1, in+1);
      break;
    case 1098:
      gtsamNonlinearFactorGraph_at_1098(nargout, out, nargin-1, in+1);
      break;
    case 1099:
      gtsamNonlinearFactorGraph_clone_1099(nargout, out, nargin-1, in+1);
      break;
    case 1100:
      gtsamNonlinearFactorGraph_empty_1100(nargout, out, nargin-1, in+1);
      break;
    case 1101:
      gtsamNonlinearFactorGraph_equals_1101(nargout, out, nargin-1, in+1);
      break;
    case 1102:
      gtsamNonlinearFactorGraph_error_1102(nargout, out, nargin-1, in+1);
      break;
    case 1103:
      gtsamNonlinearFactorGraph_exists_1103(nargout, out, nargin-1, in+1);
      break;
    case 1104:
      gtsamNonlinearFactorGraph_keyVector_1104(nargout, out, nargin-1, in+1);
      break;
    case 1105:
      gtsamNonlinearFactorGraph_keys_1105(nargout, out, nargin-1, in+1);
      break;
    case 1106:
      gtsamNonlinearFactorGraph_linearize_1106(nargout, out, nargin-1, in+1);
      break;
    case 1107:
      gtsamNonlinearFactorGraph_nrFactors_1107(nargout, out, nargin-1, in+1);
      break;
    case 1108:
      gtsamNonlinearFactorGraph_orderingCOLAMD_1108(nargout, out, nargin-1, in+1);
      break;
    case 1109:
      gtsamNonlinearFactorGraph_print_1109(nargout, out, nargin-1, in+1);
      break;
    case 1110:
      gtsamNonlinearFactorGraph_probPrime_1110(nargout, out, nargin-1, in+1);
      break;
    case 1111:
      gtsamNonlinearFactorGraph_push_back_1111(nargout, out, nargin-1, in+1);
      break;
    case 1112:
      gtsamNonlinearFactorGraph_push_back_1112(nargout, out, nargin-1, in+1);
      break;
    case 1113:
      gtsamNonlinearFactorGraph_remove_1113(nargout, out, nargin-1, in+1);
      break;
    case 1114:
      gtsamNonlinearFactorGraph_replace_1114(nargout, out, nargin-1, in+1);
      break;
    case 1115:
      gtsamNonlinearFactorGraph_resize_1115(nargout, out, nargin-1, in+1);
      break;
    case 1116:
      gtsamNonlinearFactorGraph_size_1116(nargout, out, nargin-1, in+1);
      break;
    case 1117:
      gtsamNonlinearFactorGraph_string_serialize_1117(nargout, out, nargin-1, in+1);
      break;
    case 1118:
      gtsamNonlinearFactorGraph_string_deserialize_1118(nargout, out, nargin-1, in+1);
      break;
    case 1119:
      gtsamNonlinearFactor_collectorInsertAndMakeBase_1119(nargout, out, nargin-1, in+1);
      break;
    case 1120:
      gtsamNonlinearFactor_upcastFromVoid_1120(nargout, out, nargin-1, in+1);
      break;
    case 1121:
      gtsamNonlinearFactor_deconstructor_1121(nargout, out, nargin-1, in+1);
      break;
    case 1122:
      gtsamNonlinearFactor_active_1122(nargout, out, nargin-1, in+1);
      break;
    case 1123:
      gtsamNonlinearFactor_clone_1123(nargout, out, nargin-1, in+1);
      break;
    case 1124:
      gtsamNonlinearFactor_dim_1124(nargout, out, nargin-1, in+1);
      break;
    case 1125:
      gtsamNonlinearFactor_equals_1125(nargout, out, nargin-1, in+1);
      break;
    case 1126:
      gtsamNonlinearFactor_error_1126(nargout, out, nargin-1, in+1);
      break;
    case 1127:
      gtsamNonlinearFactor_keys_1127(nargout, out, nargin-1, in+1);
      break;
    case 1128:
      gtsamNonlinearFactor_linearize_1128(nargout, out, nargin-1, in+1);
      break;
    case 1129:
      gtsamNonlinearFactor_print_1129(nargout, out, nargin-1, in+1);
      break;
    case 1130:
      gtsamNonlinearFactor_printKeys_1130(nargout, out, nargin-1, in+1);
      break;
    case 1131:
      gtsamNonlinearFactor_size_1131(nargout, out, nargin-1, in+1);
      break;
    case 1132:
      gtsamNoiseModelFactor_collectorInsertAndMakeBase_1132(nargout, out, nargin-1, in+1);
      break;
    case 1133:
      gtsamNoiseModelFactor_upcastFromVoid_1133(nargout, out, nargin-1, in+1);
      break;
    case 1134:
      gtsamNoiseModelFactor_deconstructor_1134(nargout, out, nargin-1, in+1);
      break;
    case 1135:
      gtsamNoiseModelFactor_active_1135(nargout, out, nargin-1, in+1);
      break;
    case 1136:
      gtsamNoiseModelFactor_clone_1136(nargout, out, nargin-1, in+1);
      break;
    case 1137:
      gtsamNoiseModelFactor_dim_1137(nargout, out, nargin-1, in+1);
      break;
    case 1138:
      gtsamNoiseModelFactor_equals_1138(nargout, out, nargin-1, in+1);
      break;
    case 1139:
      gtsamNoiseModelFactor_error_1139(nargout, out, nargin-1, in+1);
      break;
    case 1140:
      gtsamNoiseModelFactor_get_noiseModel_1140(nargout, out, nargin-1, in+1);
      break;
    case 1141:
      gtsamNoiseModelFactor_keys_1141(nargout, out, nargin-1, in+1);
      break;
    case 1142:
      gtsamNoiseModelFactor_linearize_1142(nargout, out, nargin-1, in+1);
      break;
    case 1143:
      gtsamNoiseModelFactor_noiseModel_1143(nargout, out, nargin-1, in+1);
      break;
    case 1144:
      gtsamNoiseModelFactor_print_1144(nargout, out, nargin-1, in+1);
      break;
    case 1145:
      gtsamNoiseModelFactor_printKeys_1145(nargout, out, nargin-1, in+1);
      break;
    case 1146:
      gtsamNoiseModelFactor_size_1146(nargout, out, nargin-1, in+1);
      break;
    case 1147:
      gtsamNoiseModelFactor_unwhitenedError_1147(nargout, out, nargin-1, in+1);
      break;
    case 1148:
      gtsamNoiseModelFactor_whitenedError_1148(nargout, out, nargin-1, in+1);
      break;
    case 1149:
      gtsamValues_collectorInsertAndMakeBase_1149(nargout, out, nargin-1, in+1);
      break;
    case 1150:
      gtsamValues_constructor_1150(nargout, out, nargin-1, in+1);
      break;
    case 1151:
      gtsamValues_constructor_1151(nargout, out, nargin-1, in+1);
      break;
    case 1152:
      gtsamValues_deconstructor_1152(nargout, out, nargin-1, in+1);
      break;
    case 1153:
      gtsamValues_at_1153(nargout, out, nargin-1, in+1);
      break;
    case 1154:
      gtsamValues_at_1154(nargout, out, nargin-1, in+1);
      break;
    case 1155:
      gtsamValues_at_1155(nargout, out, nargin-1, in+1);
      break;
    case 1156:
      gtsamValues_at_1156(nargout, out, nargin-1, in+1);
      break;
    case 1157:
      gtsamValues_atDouble_1157(nargout, out, nargin-1, in+1);
      break;
    case 1158:
      gtsamValues_at_1158(nargout, out, nargin-1, in+1);
      break;
    case 1159:
      gtsamValues_at_1159(nargout, out, nargin-1, in+1);
      break;
    case 1160:
      gtsamValues_at_1160(nargout, out, nargin-1, in+1);
      break;
    case 1161:
      gtsamValues_at_1161(nargout, out, nargin-1, in+1);
      break;
    case 1162:
      gtsamValues_at_1162(nargout, out, nargin-1, in+1);
      break;
    case 1163:
      gtsamValues_at_1163(nargout, out, nargin-1, in+1);
      break;
    case 1164:
      gtsamValues_at_1164(nargout, out, nargin-1, in+1);
      break;
    case 1165:
      gtsamValues_at_1165(nargout, out, nargin-1, in+1);
      break;
    case 1166:
      gtsamValues_at_1166(nargout, out, nargin-1, in+1);
      break;
    case 1167:
      gtsamValues_clear_1167(nargout, out, nargin-1, in+1);
      break;
    case 1168:
      gtsamValues_dim_1168(nargout, out, nargin-1, in+1);
      break;
    case 1169:
      gtsamValues_empty_1169(nargout, out, nargin-1, in+1);
      break;
    case 1170:
      gtsamValues_equals_1170(nargout, out, nargin-1, in+1);
      break;
    case 1171:
      gtsamValues_erase_1171(nargout, out, nargin-1, in+1);
      break;
    case 1172:
      gtsamValues_exists_1172(nargout, out, nargin-1, in+1);
      break;
    case 1173:
      gtsamValues_insert_1173(nargout, out, nargin-1, in+1);
      break;
    case 1174:
      gtsamValues_insert_1174(nargout, out, nargin-1, in+1);
      break;
    case 1175:
      gtsamValues_insert_1175(nargout, out, nargin-1, in+1);
      break;
    case 1176:
      gtsamValues_insert_1176(nargout, out, nargin-1, in+1);
      break;
    case 1177:
      gtsamValues_insert_1177(nargout, out, nargin-1, in+1);
      break;
    case 1178:
      gtsamValues_insert_1178(nargout, out, nargin-1, in+1);
      break;
    case 1179:
      gtsamValues_insert_1179(nargout, out, nargin-1, in+1);
      break;
    case 1180:
      gtsamValues_insert_1180(nargout, out, nargin-1, in+1);
      break;
    case 1181:
      gtsamValues_insert_1181(nargout, out, nargin-1, in+1);
      break;
    case 1182:
      gtsamValues_insert_1182(nargout, out, nargin-1, in+1);
      break;
    case 1183:
      gtsamValues_insert_1183(nargout, out, nargin-1, in+1);
      break;
    case 1184:
      gtsamValues_insert_1184(nargout, out, nargin-1, in+1);
      break;
    case 1185:
      gtsamValues_insert_1185(nargout, out, nargin-1, in+1);
      break;
    case 1186:
      gtsamValues_insert_1186(nargout, out, nargin-1, in+1);
      break;
    case 1187:
      gtsamValues_insert_1187(nargout, out, nargin-1, in+1);
      break;
    case 1188:
      gtsamValues_insertDouble_1188(nargout, out, nargin-1, in+1);
      break;
    case 1189:
      gtsamValues_keys_1189(nargout, out, nargin-1, in+1);
      break;
    case 1190:
      gtsamValues_localCoordinates_1190(nargout, out, nargin-1, in+1);
      break;
    case 1191:
      gtsamValues_print_1191(nargout, out, nargin-1, in+1);
      break;
    case 1192:
      gtsamValues_retract_1192(nargout, out, nargin-1, in+1);
      break;
    case 1193:
      gtsamValues_size_1193(nargout, out, nargin-1, in+1);
      break;
    case 1194:
      gtsamValues_swap_1194(nargout, out, nargin-1, in+1);
      break;
    case 1195:
      gtsamValues_update_1195(nargout, out, nargin-1, in+1);
      break;
    case 1196:
      gtsamValues_update_1196(nargout, out, nargin-1, in+1);
      break;
    case 1197:
      gtsamValues_update_1197(nargout, out, nargin-1, in+1);
      break;
    case 1198:
      gtsamValues_update_1198(nargout, out, nargin-1, in+1);
      break;
    case 1199:
      gtsamValues_update_1199(nargout, out, nargin-1, in+1);
      break;
    case 1200:
      gtsamValues_update_1200(nargout, out, nargin-1, in+1);
      break;
    case 1201:
      gtsamValues_update_1201(nargout, out, nargin-1, in+1);
      break;
    case 1202:
      gtsamValues_update_1202(nargout, out, nargin-1, in+1);
      break;
    case 1203:
      gtsamValues_update_1203(nargout, out, nargin-1, in+1);
      break;
    case 1204:
      gtsamValues_update_1204(nargout, out, nargin-1, in+1);
      break;
    case 1205:
      gtsamValues_update_1205(nargout, out, nargin-1, in+1);
      break;
    case 1206:
      gtsamValues_update_1206(nargout, out, nargin-1, in+1);
      break;
    case 1207:
      gtsamValues_update_1207(nargout, out, nargin-1, in+1);
      break;
    case 1208:
      gtsamValues_update_1208(nargout, out, nargin-1, in+1);
      break;
    case 1209:
      gtsamValues_zeroVectors_1209(nargout, out, nargin-1, in+1);
      break;
    case 1210:
      gtsamValues_string_serialize_1210(nargout, out, nargin-1, in+1);
      break;
    case 1211:
      gtsamValues_string_deserialize_1211(nargout, out, nargin-1, in+1);
      break;
    case 1212:
      gtsamMarginals_collectorInsertAndMakeBase_1212(nargout, out, nargin-1, in+1);
      break;
    case 1213:
      gtsamMarginals_constructor_1213(nargout, out, nargin-1, in+1);
      break;
    case 1214:
      gtsamMarginals_deconstructor_1214(nargout, out, nargin-1, in+1);
      break;
    case 1215:
      gtsamMarginals_jointMarginalCovariance_1215(nargout, out, nargin-1, in+1);
      break;
    case 1216:
      gtsamMarginals_jointMarginalInformation_1216(nargout, out, nargin-1, in+1);
      break;
    case 1217:
      gtsamMarginals_marginalCovariance_1217(nargout, out, nargin-1, in+1);
      break;
    case 1218:
      gtsamMarginals_marginalInformation_1218(nargout, out, nargin-1, in+1);
      break;
    case 1219:
      gtsamMarginals_print_1219(nargout, out, nargin-1, in+1);
      break;
    case 1220:
      gtsamJointMarginal_collectorInsertAndMakeBase_1220(nargout, out, nargin-1, in+1);
      break;
    case 1221:
      gtsamJointMarginal_deconstructor_1221(nargout, out, nargin-1, in+1);
      break;
    case 1222:
      gtsamJointMarginal_at_1222(nargout, out, nargin-1, in+1);
      break;
    case 1223:
      gtsamJointMarginal_fullMatrix_1223(nargout, out, nargin-1, in+1);
      break;
    case 1224:
      gtsamJointMarginal_print_1224(nargout, out, nargin-1, in+1);
      break;
    case 1225:
      gtsamJointMarginal_print_1225(nargout, out, nargin-1, in+1);
      break;
    case 1226:
      gtsamLinearContainerFactor_collectorInsertAndMakeBase_1226(nargout, out, nargin-1, in+1);
      break;
    case 1227:
      gtsamLinearContainerFactor_upcastFromVoid_1227(nargout, out, nargin-1, in+1);
      break;
    case 1228:
      gtsamLinearContainerFactor_constructor_1228(nargout, out, nargin-1, in+1);
      break;
    case 1229:
      gtsamLinearContainerFactor_constructor_1229(nargout, out, nargin-1, in+1);
      break;
    case 1230:
      gtsamLinearContainerFactor_deconstructor_1230(nargout, out, nargin-1, in+1);
      break;
    case 1231:
      gtsamLinearContainerFactor_active_1231(nargout, out, nargin-1, in+1);
      break;
    case 1232:
      gtsamLinearContainerFactor_clone_1232(nargout, out, nargin-1, in+1);
      break;
    case 1233:
      gtsamLinearContainerFactor_dim_1233(nargout, out, nargin-1, in+1);
      break;
    case 1234:
      gtsamLinearContainerFactor_equals_1234(nargout, out, nargin-1, in+1);
      break;
    case 1235:
      gtsamLinearContainerFactor_error_1235(nargout, out, nargin-1, in+1);
      break;
    case 1236:
      gtsamLinearContainerFactor_factor_1236(nargout, out, nargin-1, in+1);
      break;
    case 1237:
      gtsamLinearContainerFactor_isJacobian_1237(nargout, out, nargin-1, in+1);
      break;
    case 1238:
      gtsamLinearContainerFactor_keys_1238(nargout, out, nargin-1, in+1);
      break;
    case 1239:
      gtsamLinearContainerFactor_linearize_1239(nargout, out, nargin-1, in+1);
      break;
    case 1240:
      gtsamLinearContainerFactor_print_1240(nargout, out, nargin-1, in+1);
      break;
    case 1241:
      gtsamLinearContainerFactor_printKeys_1241(nargout, out, nargin-1, in+1);
      break;
    case 1242:
      gtsamLinearContainerFactor_size_1242(nargout, out, nargin-1, in+1);
      break;
    case 1243:
      gtsamLinearContainerFactor_toHessian_1243(nargout, out, nargin-1, in+1);
      break;
    case 1244:
      gtsamLinearContainerFactor_toJacobian_1244(nargout, out, nargin-1, in+1);
      break;
    case 1245:
      gtsamLinearContainerFactor_ConvertLinearGraph_1245(nargout, out, nargin-1, in+1);
      break;
    case 1246:
      gtsamLinearContainerFactor_ConvertLinearGraph_1246(nargout, out, nargin-1, in+1);
      break;
    case 1247:
      gtsamNonlinearOptimizerParams_collectorInsertAndMakeBase_1247(nargout, out, nargin-1, in+1);
      break;
    case 1248:
      gtsamNonlinearOptimizerParams_upcastFromVoid_1248(nargout, out, nargin-1, in+1);
      break;
    case 1249:
      gtsamNonlinearOptimizerParams_constructor_1249(nargout, out, nargin-1, in+1);
      break;
    case 1250:
      gtsamNonlinearOptimizerParams_deconstructor_1250(nargout, out, nargin-1, in+1);
      break;
    case 1251:
      gtsamNonlinearOptimizerParams_getAbsoluteErrorTol_1251(nargout, out, nargin-1, in+1);
      break;
    case 1252:
      gtsamNonlinearOptimizerParams_getErrorTol_1252(nargout, out, nargin-1, in+1);
      break;
    case 1253:
      gtsamNonlinearOptimizerParams_getLinearSolverType_1253(nargout, out, nargin-1, in+1);
      break;
    case 1254:
      gtsamNonlinearOptimizerParams_getMaxIterations_1254(nargout, out, nargin-1, in+1);
      break;
    case 1255:
      gtsamNonlinearOptimizerParams_getRelativeErrorTol_1255(nargout, out, nargin-1, in+1);
      break;
    case 1256:
      gtsamNonlinearOptimizerParams_getVerbosity_1256(nargout, out, nargin-1, in+1);
      break;
    case 1257:
      gtsamNonlinearOptimizerParams_isCholmod_1257(nargout, out, nargin-1, in+1);
      break;
    case 1258:
      gtsamNonlinearOptimizerParams_isIterative_1258(nargout, out, nargin-1, in+1);
      break;
    case 1259:
      gtsamNonlinearOptimizerParams_isMultifrontal_1259(nargout, out, nargin-1, in+1);
      break;
    case 1260:
      gtsamNonlinearOptimizerParams_isSequential_1260(nargout, out, nargin-1, in+1);
      break;
    case 1261:
      gtsamNonlinearOptimizerParams_print_1261(nargout, out, nargin-1, in+1);
      break;
    case 1262:
      gtsamNonlinearOptimizerParams_setAbsoluteErrorTol_1262(nargout, out, nargin-1, in+1);
      break;
    case 1263:
      gtsamNonlinearOptimizerParams_setErrorTol_1263(nargout, out, nargin-1, in+1);
      break;
    case 1264:
      gtsamNonlinearOptimizerParams_setIterativeParams_1264(nargout, out, nargin-1, in+1);
      break;
    case 1265:
      gtsamNonlinearOptimizerParams_setLinearSolverType_1265(nargout, out, nargin-1, in+1);
      break;
    case 1266:
      gtsamNonlinearOptimizerParams_setMaxIterations_1266(nargout, out, nargin-1, in+1);
      break;
    case 1267:
      gtsamNonlinearOptimizerParams_setOrdering_1267(nargout, out, nargin-1, in+1);
      break;
    case 1268:
      gtsamNonlinearOptimizerParams_setRelativeErrorTol_1268(nargout, out, nargin-1, in+1);
      break;
    case 1269:
      gtsamNonlinearOptimizerParams_setVerbosity_1269(nargout, out, nargin-1, in+1);
      break;
    case 1270:
      gtsamGaussNewtonParams_collectorInsertAndMakeBase_1270(nargout, out, nargin-1, in+1);
      break;
    case 1271:
      gtsamGaussNewtonParams_upcastFromVoid_1271(nargout, out, nargin-1, in+1);
      break;
    case 1272:
      gtsamGaussNewtonParams_constructor_1272(nargout, out, nargin-1, in+1);
      break;
    case 1273:
      gtsamGaussNewtonParams_deconstructor_1273(nargout, out, nargin-1, in+1);
      break;
    case 1274:
      gtsamGaussNewtonParams_getAbsoluteErrorTol_1274(nargout, out, nargin-1, in+1);
      break;
    case 1275:
      gtsamGaussNewtonParams_getErrorTol_1275(nargout, out, nargin-1, in+1);
      break;
    case 1276:
      gtsamGaussNewtonParams_getLinearSolverType_1276(nargout, out, nargin-1, in+1);
      break;
    case 1277:
      gtsamGaussNewtonParams_getMaxIterations_1277(nargout, out, nargin-1, in+1);
      break;
    case 1278:
      gtsamGaussNewtonParams_getRelativeErrorTol_1278(nargout, out, nargin-1, in+1);
      break;
    case 1279:
      gtsamGaussNewtonParams_getVerbosity_1279(nargout, out, nargin-1, in+1);
      break;
    case 1280:
      gtsamGaussNewtonParams_isCholmod_1280(nargout, out, nargin-1, in+1);
      break;
    case 1281:
      gtsamGaussNewtonParams_isIterative_1281(nargout, out, nargin-1, in+1);
      break;
    case 1282:
      gtsamGaussNewtonParams_isMultifrontal_1282(nargout, out, nargin-1, in+1);
      break;
    case 1283:
      gtsamGaussNewtonParams_isSequential_1283(nargout, out, nargin-1, in+1);
      break;
    case 1284:
      gtsamGaussNewtonParams_print_1284(nargout, out, nargin-1, in+1);
      break;
    case 1285:
      gtsamGaussNewtonParams_setAbsoluteErrorTol_1285(nargout, out, nargin-1, in+1);
      break;
    case 1286:
      gtsamGaussNewtonParams_setErrorTol_1286(nargout, out, nargin-1, in+1);
      break;
    case 1287:
      gtsamGaussNewtonParams_setIterativeParams_1287(nargout, out, nargin-1, in+1);
      break;
    case 1288:
      gtsamGaussNewtonParams_setLinearSolverType_1288(nargout, out, nargin-1, in+1);
      break;
    case 1289:
      gtsamGaussNewtonParams_setMaxIterations_1289(nargout, out, nargin-1, in+1);
      break;
    case 1290:
      gtsamGaussNewtonParams_setOrdering_1290(nargout, out, nargin-1, in+1);
      break;
    case 1291:
      gtsamGaussNewtonParams_setRelativeErrorTol_1291(nargout, out, nargin-1, in+1);
      break;
    case 1292:
      gtsamGaussNewtonParams_setVerbosity_1292(nargout, out, nargin-1, in+1);
      break;
    case 1293:
      gtsamLevenbergMarquardtParams_collectorInsertAndMakeBase_1293(nargout, out, nargin-1, in+1);
      break;
    case 1294:
      gtsamLevenbergMarquardtParams_upcastFromVoid_1294(nargout, out, nargin-1, in+1);
      break;
    case 1295:
      gtsamLevenbergMarquardtParams_constructor_1295(nargout, out, nargin-1, in+1);
      break;
    case 1296:
      gtsamLevenbergMarquardtParams_deconstructor_1296(nargout, out, nargin-1, in+1);
      break;
    case 1297:
      gtsamLevenbergMarquardtParams_getAbsoluteErrorTol_1297(nargout, out, nargin-1, in+1);
      break;
    case 1298:
      gtsamLevenbergMarquardtParams_getErrorTol_1298(nargout, out, nargin-1, in+1);
      break;
    case 1299:
      gtsamLevenbergMarquardtParams_getLinearSolverType_1299(nargout, out, nargin-1, in+1);
      break;
    case 1300:
      gtsamLevenbergMarquardtParams_getMaxIterations_1300(nargout, out, nargin-1, in+1);
      break;
    case 1301:
      gtsamLevenbergMarquardtParams_getRelativeErrorTol_1301(nargout, out, nargin-1, in+1);
      break;
    case 1302:
      gtsamLevenbergMarquardtParams_getVerbosity_1302(nargout, out, nargin-1, in+1);
      break;
    case 1303:
      gtsamLevenbergMarquardtParams_getVerbosityLM_1303(nargout, out, nargin-1, in+1);
      break;
    case 1304:
      gtsamLevenbergMarquardtParams_getlambdaFactor_1304(nargout, out, nargin-1, in+1);
      break;
    case 1305:
      gtsamLevenbergMarquardtParams_getlambdaInitial_1305(nargout, out, nargin-1, in+1);
      break;
    case 1306:
      gtsamLevenbergMarquardtParams_getlambdaUpperBound_1306(nargout, out, nargin-1, in+1);
      break;
    case 1307:
      gtsamLevenbergMarquardtParams_isCholmod_1307(nargout, out, nargin-1, in+1);
      break;
    case 1308:
      gtsamLevenbergMarquardtParams_isIterative_1308(nargout, out, nargin-1, in+1);
      break;
    case 1309:
      gtsamLevenbergMarquardtParams_isMultifrontal_1309(nargout, out, nargin-1, in+1);
      break;
    case 1310:
      gtsamLevenbergMarquardtParams_isSequential_1310(nargout, out, nargin-1, in+1);
      break;
    case 1311:
      gtsamLevenbergMarquardtParams_print_1311(nargout, out, nargin-1, in+1);
      break;
    case 1312:
      gtsamLevenbergMarquardtParams_setAbsoluteErrorTol_1312(nargout, out, nargin-1, in+1);
      break;
    case 1313:
      gtsamLevenbergMarquardtParams_setErrorTol_1313(nargout, out, nargin-1, in+1);
      break;
    case 1314:
      gtsamLevenbergMarquardtParams_setIterativeParams_1314(nargout, out, nargin-1, in+1);
      break;
    case 1315:
      gtsamLevenbergMarquardtParams_setLinearSolverType_1315(nargout, out, nargin-1, in+1);
      break;
    case 1316:
      gtsamLevenbergMarquardtParams_setMaxIterations_1316(nargout, out, nargin-1, in+1);
      break;
    case 1317:
      gtsamLevenbergMarquardtParams_setOrdering_1317(nargout, out, nargin-1, in+1);
      break;
    case 1318:
      gtsamLevenbergMarquardtParams_setRelativeErrorTol_1318(nargout, out, nargin-1, in+1);
      break;
    case 1319:
      gtsamLevenbergMarquardtParams_setVerbosity_1319(nargout, out, nargin-1, in+1);
      break;
    case 1320:
      gtsamLevenbergMarquardtParams_setVerbosityLM_1320(nargout, out, nargin-1, in+1);
      break;
    case 1321:
      gtsamLevenbergMarquardtParams_setlambdaFactor_1321(nargout, out, nargin-1, in+1);
      break;
    case 1322:
      gtsamLevenbergMarquardtParams_setlambdaInitial_1322(nargout, out, nargin-1, in+1);
      break;
    case 1323:
      gtsamLevenbergMarquardtParams_setlambdaUpperBound_1323(nargout, out, nargin-1, in+1);
      break;
    case 1324:
      gtsamDoglegParams_collectorInsertAndMakeBase_1324(nargout, out, nargin-1, in+1);
      break;
    case 1325:
      gtsamDoglegParams_upcastFromVoid_1325(nargout, out, nargin-1, in+1);
      break;
    case 1326:
      gtsamDoglegParams_constructor_1326(nargout, out, nargin-1, in+1);
      break;
    case 1327:
      gtsamDoglegParams_deconstructor_1327(nargout, out, nargin-1, in+1);
      break;
    case 1328:
      gtsamDoglegParams_getAbsoluteErrorTol_1328(nargout, out, nargin-1, in+1);
      break;
    case 1329:
      gtsamDoglegParams_getDeltaInitial_1329(nargout, out, nargin-1, in+1);
      break;
    case 1330:
      gtsamDoglegParams_getErrorTol_1330(nargout, out, nargin-1, in+1);
      break;
    case 1331:
      gtsamDoglegParams_getLinearSolverType_1331(nargout, out, nargin-1, in+1);
      break;
    case 1332:
      gtsamDoglegParams_getMaxIterations_1332(nargout, out, nargin-1, in+1);
      break;
    case 1333:
      gtsamDoglegParams_getRelativeErrorTol_1333(nargout, out, nargin-1, in+1);
      break;
    case 1334:
      gtsamDoglegParams_getVerbosity_1334(nargout, out, nargin-1, in+1);
      break;
    case 1335:
      gtsamDoglegParams_getVerbosityDL_1335(nargout, out, nargin-1, in+1);
      break;
    case 1336:
      gtsamDoglegParams_isCholmod_1336(nargout, out, nargin-1, in+1);
      break;
    case 1337:
      gtsamDoglegParams_isIterative_1337(nargout, out, nargin-1, in+1);
      break;
    case 1338:
      gtsamDoglegParams_isMultifrontal_1338(nargout, out, nargin-1, in+1);
      break;
    case 1339:
      gtsamDoglegParams_isSequential_1339(nargout, out, nargin-1, in+1);
      break;
    case 1340:
      gtsamDoglegParams_print_1340(nargout, out, nargin-1, in+1);
      break;
    case 1341:
      gtsamDoglegParams_setAbsoluteErrorTol_1341(nargout, out, nargin-1, in+1);
      break;
    case 1342:
      gtsamDoglegParams_setDeltaInitial_1342(nargout, out, nargin-1, in+1);
      break;
    case 1343:
      gtsamDoglegParams_setErrorTol_1343(nargout, out, nargin-1, in+1);
      break;
    case 1344:
      gtsamDoglegParams_setIterativeParams_1344(nargout, out, nargin-1, in+1);
      break;
    case 1345:
      gtsamDoglegParams_setLinearSolverType_1345(nargout, out, nargin-1, in+1);
      break;
    case 1346:
      gtsamDoglegParams_setMaxIterations_1346(nargout, out, nargin-1, in+1);
      break;
    case 1347:
      gtsamDoglegParams_setOrdering_1347(nargout, out, nargin-1, in+1);
      break;
    case 1348:
      gtsamDoglegParams_setRelativeErrorTol_1348(nargout, out, nargin-1, in+1);
      break;
    case 1349:
      gtsamDoglegParams_setVerbosity_1349(nargout, out, nargin-1, in+1);
      break;
    case 1350:
      gtsamDoglegParams_setVerbosityDL_1350(nargout, out, nargin-1, in+1);
      break;
    case 1351:
      gtsamNonlinearOptimizer_collectorInsertAndMakeBase_1351(nargout, out, nargin-1, in+1);
      break;
    case 1352:
      gtsamNonlinearOptimizer_upcastFromVoid_1352(nargout, out, nargin-1, in+1);
      break;
    case 1353:
      gtsamNonlinearOptimizer_deconstructor_1353(nargout, out, nargin-1, in+1);
      break;
    case 1354:
      gtsamNonlinearOptimizer_error_1354(nargout, out, nargin-1, in+1);
      break;
    case 1355:
      gtsamNonlinearOptimizer_iterate_1355(nargout, out, nargin-1, in+1);
      break;
    case 1356:
      gtsamNonlinearOptimizer_iterations_1356(nargout, out, nargin-1, in+1);
      break;
    case 1357:
      gtsamNonlinearOptimizer_optimize_1357(nargout, out, nargin-1, in+1);
      break;
    case 1358:
      gtsamNonlinearOptimizer_optimizeSafely_1358(nargout, out, nargin-1, in+1);
      break;
    case 1359:
      gtsamNonlinearOptimizer_values_1359(nargout, out, nargin-1, in+1);
      break;
    case 1360:
      gtsamGaussNewtonOptimizer_collectorInsertAndMakeBase_1360(nargout, out, nargin-1, in+1);
      break;
    case 1361:
      gtsamGaussNewtonOptimizer_upcastFromVoid_1361(nargout, out, nargin-1, in+1);
      break;
    case 1362:
      gtsamGaussNewtonOptimizer_constructor_1362(nargout, out, nargin-1, in+1);
      break;
    case 1363:
      gtsamGaussNewtonOptimizer_constructor_1363(nargout, out, nargin-1, in+1);
      break;
    case 1364:
      gtsamGaussNewtonOptimizer_deconstructor_1364(nargout, out, nargin-1, in+1);
      break;
    case 1365:
      gtsamGaussNewtonOptimizer_error_1365(nargout, out, nargin-1, in+1);
      break;
    case 1366:
      gtsamGaussNewtonOptimizer_iterate_1366(nargout, out, nargin-1, in+1);
      break;
    case 1367:
      gtsamGaussNewtonOptimizer_iterations_1367(nargout, out, nargin-1, in+1);
      break;
    case 1368:
      gtsamGaussNewtonOptimizer_optimize_1368(nargout, out, nargin-1, in+1);
      break;
    case 1369:
      gtsamGaussNewtonOptimizer_optimizeSafely_1369(nargout, out, nargin-1, in+1);
      break;
    case 1370:
      gtsamGaussNewtonOptimizer_values_1370(nargout, out, nargin-1, in+1);
      break;
    case 1371:
      gtsamDoglegOptimizer_collectorInsertAndMakeBase_1371(nargout, out, nargin-1, in+1);
      break;
    case 1372:
      gtsamDoglegOptimizer_upcastFromVoid_1372(nargout, out, nargin-1, in+1);
      break;
    case 1373:
      gtsamDoglegOptimizer_constructor_1373(nargout, out, nargin-1, in+1);
      break;
    case 1374:
      gtsamDoglegOptimizer_constructor_1374(nargout, out, nargin-1, in+1);
      break;
    case 1375:
      gtsamDoglegOptimizer_deconstructor_1375(nargout, out, nargin-1, in+1);
      break;
    case 1376:
      gtsamDoglegOptimizer_error_1376(nargout, out, nargin-1, in+1);
      break;
    case 1377:
      gtsamDoglegOptimizer_getDelta_1377(nargout, out, nargin-1, in+1);
      break;
    case 1378:
      gtsamDoglegOptimizer_iterate_1378(nargout, out, nargin-1, in+1);
      break;
    case 1379:
      gtsamDoglegOptimizer_iterations_1379(nargout, out, nargin-1, in+1);
      break;
    case 1380:
      gtsamDoglegOptimizer_optimize_1380(nargout, out, nargin-1, in+1);
      break;
    case 1381:
      gtsamDoglegOptimizer_optimizeSafely_1381(nargout, out, nargin-1, in+1);
      break;
    case 1382:
      gtsamDoglegOptimizer_values_1382(nargout, out, nargin-1, in+1);
      break;
    case 1383:
      gtsamLevenbergMarquardtOptimizer_collectorInsertAndMakeBase_1383(nargout, out, nargin-1, in+1);
      break;
    case 1384:
      gtsamLevenbergMarquardtOptimizer_upcastFromVoid_1384(nargout, out, nargin-1, in+1);
      break;
    case 1385:
      gtsamLevenbergMarquardtOptimizer_constructor_1385(nargout, out, nargin-1, in+1);
      break;
    case 1386:
      gtsamLevenbergMarquardtOptimizer_constructor_1386(nargout, out, nargin-1, in+1);
      break;
    case 1387:
      gtsamLevenbergMarquardtOptimizer_deconstructor_1387(nargout, out, nargin-1, in+1);
      break;
    case 1388:
      gtsamLevenbergMarquardtOptimizer_error_1388(nargout, out, nargin-1, in+1);
      break;
    case 1389:
      gtsamLevenbergMarquardtOptimizer_iterate_1389(nargout, out, nargin-1, in+1);
      break;
    case 1390:
      gtsamLevenbergMarquardtOptimizer_iterations_1390(nargout, out, nargin-1, in+1);
      break;
    case 1391:
      gtsamLevenbergMarquardtOptimizer_lambda_1391(nargout, out, nargin-1, in+1);
      break;
    case 1392:
      gtsamLevenbergMarquardtOptimizer_optimize_1392(nargout, out, nargin-1, in+1);
      break;
    case 1393:
      gtsamLevenbergMarquardtOptimizer_optimizeSafely_1393(nargout, out, nargin-1, in+1);
      break;
    case 1394:
      gtsamLevenbergMarquardtOptimizer_print_1394(nargout, out, nargin-1, in+1);
      break;
    case 1395:
      gtsamLevenbergMarquardtOptimizer_values_1395(nargout, out, nargin-1, in+1);
      break;
    case 1396:
      gtsamISAM2GaussNewtonParams_collectorInsertAndMakeBase_1396(nargout, out, nargin-1, in+1);
      break;
    case 1397:
      gtsamISAM2GaussNewtonParams_constructor_1397(nargout, out, nargin-1, in+1);
      break;
    case 1398:
      gtsamISAM2GaussNewtonParams_deconstructor_1398(nargout, out, nargin-1, in+1);
      break;
    case 1399:
      gtsamISAM2GaussNewtonParams_getWildfireThreshold_1399(nargout, out, nargin-1, in+1);
      break;
    case 1400:
      gtsamISAM2GaussNewtonParams_print_1400(nargout, out, nargin-1, in+1);
      break;
    case 1401:
      gtsamISAM2GaussNewtonParams_setWildfireThreshold_1401(nargout, out, nargin-1, in+1);
      break;
    case 1402:
      gtsamISAM2DoglegParams_collectorInsertAndMakeBase_1402(nargout, out, nargin-1, in+1);
      break;
    case 1403:
      gtsamISAM2DoglegParams_constructor_1403(nargout, out, nargin-1, in+1);
      break;
    case 1404:
      gtsamISAM2DoglegParams_deconstructor_1404(nargout, out, nargin-1, in+1);
      break;
    case 1405:
      gtsamISAM2DoglegParams_getAdaptationMode_1405(nargout, out, nargin-1, in+1);
      break;
    case 1406:
      gtsamISAM2DoglegParams_getInitialDelta_1406(nargout, out, nargin-1, in+1);
      break;
    case 1407:
      gtsamISAM2DoglegParams_getWildfireThreshold_1407(nargout, out, nargin-1, in+1);
      break;
    case 1408:
      gtsamISAM2DoglegParams_isVerbose_1408(nargout, out, nargin-1, in+1);
      break;
    case 1409:
      gtsamISAM2DoglegParams_print_1409(nargout, out, nargin-1, in+1);
      break;
    case 1410:
      gtsamISAM2DoglegParams_setAdaptationMode_1410(nargout, out, nargin-1, in+1);
      break;
    case 1411:
      gtsamISAM2DoglegParams_setInitialDelta_1411(nargout, out, nargin-1, in+1);
      break;
    case 1412:
      gtsamISAM2DoglegParams_setVerbose_1412(nargout, out, nargin-1, in+1);
      break;
    case 1413:
      gtsamISAM2DoglegParams_setWildfireThreshold_1413(nargout, out, nargin-1, in+1);
      break;
    case 1414:
      gtsamISAM2ThresholdMapValue_collectorInsertAndMakeBase_1414(nargout, out, nargin-1, in+1);
      break;
    case 1415:
      gtsamISAM2ThresholdMapValue_constructor_1415(nargout, out, nargin-1, in+1);
      break;
    case 1416:
      gtsamISAM2ThresholdMapValue_constructor_1416(nargout, out, nargin-1, in+1);
      break;
    case 1417:
      gtsamISAM2ThresholdMapValue_deconstructor_1417(nargout, out, nargin-1, in+1);
      break;
    case 1418:
      gtsamISAM2ThresholdMap_collectorInsertAndMakeBase_1418(nargout, out, nargin-1, in+1);
      break;
    case 1419:
      gtsamISAM2ThresholdMap_constructor_1419(nargout, out, nargin-1, in+1);
      break;
    case 1420:
      gtsamISAM2ThresholdMap_constructor_1420(nargout, out, nargin-1, in+1);
      break;
    case 1421:
      gtsamISAM2ThresholdMap_deconstructor_1421(nargout, out, nargin-1, in+1);
      break;
    case 1422:
      gtsamISAM2ThresholdMap_clear_1422(nargout, out, nargin-1, in+1);
      break;
    case 1423:
      gtsamISAM2ThresholdMap_empty_1423(nargout, out, nargin-1, in+1);
      break;
    case 1424:
      gtsamISAM2ThresholdMap_insert_1424(nargout, out, nargin-1, in+1);
      break;
    case 1425:
      gtsamISAM2ThresholdMap_size_1425(nargout, out, nargin-1, in+1);
      break;
    case 1426:
      gtsamISAM2Params_collectorInsertAndMakeBase_1426(nargout, out, nargin-1, in+1);
      break;
    case 1427:
      gtsamISAM2Params_constructor_1427(nargout, out, nargin-1, in+1);
      break;
    case 1428:
      gtsamISAM2Params_deconstructor_1428(nargout, out, nargin-1, in+1);
      break;
    case 1429:
      gtsamISAM2Params_getFactorization_1429(nargout, out, nargin-1, in+1);
      break;
    case 1430:
      gtsamISAM2Params_getRelinearizeSkip_1430(nargout, out, nargin-1, in+1);
      break;
    case 1431:
      gtsamISAM2Params_isCacheLinearizedFactors_1431(nargout, out, nargin-1, in+1);
      break;
    case 1432:
      gtsamISAM2Params_isEnableDetailedResults_1432(nargout, out, nargin-1, in+1);
      break;
    case 1433:
      gtsamISAM2Params_isEnablePartialRelinearizationCheck_1433(nargout, out, nargin-1, in+1);
      break;
    case 1434:
      gtsamISAM2Params_isEnableRelinearization_1434(nargout, out, nargin-1, in+1);
      break;
    case 1435:
      gtsamISAM2Params_isEvaluateNonlinearError_1435(nargout, out, nargin-1, in+1);
      break;
    case 1436:
      gtsamISAM2Params_print_1436(nargout, out, nargin-1, in+1);
      break;
    case 1437:
      gtsamISAM2Params_setCacheLinearizedFactors_1437(nargout, out, nargin-1, in+1);
      break;
    case 1438:
      gtsamISAM2Params_setEnableDetailedResults_1438(nargout, out, nargin-1, in+1);
      break;
    case 1439:
      gtsamISAM2Params_setEnablePartialRelinearizationCheck_1439(nargout, out, nargin-1, in+1);
      break;
    case 1440:
      gtsamISAM2Params_setEnableRelinearization_1440(nargout, out, nargin-1, in+1);
      break;
    case 1441:
      gtsamISAM2Params_setEvaluateNonlinearError_1441(nargout, out, nargin-1, in+1);
      break;
    case 1442:
      gtsamISAM2Params_setFactorization_1442(nargout, out, nargin-1, in+1);
      break;
    case 1443:
      gtsamISAM2Params_setOptimizationParams_1443(nargout, out, nargin-1, in+1);
      break;
    case 1444:
      gtsamISAM2Params_setOptimizationParams_1444(nargout, out, nargin-1, in+1);
      break;
    case 1445:
      gtsamISAM2Params_setRelinearizeSkip_1445(nargout, out, nargin-1, in+1);
      break;
    case 1446:
      gtsamISAM2Params_setRelinearizeThreshold_1446(nargout, out, nargin-1, in+1);
      break;
    case 1447:
      gtsamISAM2Params_setRelinearizeThreshold_1447(nargout, out, nargin-1, in+1);
      break;
    case 1448:
      gtsamISAM2Clique_collectorInsertAndMakeBase_1448(nargout, out, nargin-1, in+1);
      break;
    case 1449:
      gtsamISAM2Clique_constructor_1449(nargout, out, nargin-1, in+1);
      break;
    case 1450:
      gtsamISAM2Clique_deconstructor_1450(nargout, out, nargin-1, in+1);
      break;
    case 1451:
      gtsamISAM2Clique_gradientContribution_1451(nargout, out, nargin-1, in+1);
      break;
    case 1452:
      gtsamISAM2Clique_print_1452(nargout, out, nargin-1, in+1);
      break;
    case 1453:
      gtsamISAM2Result_collectorInsertAndMakeBase_1453(nargout, out, nargin-1, in+1);
      break;
    case 1454:
      gtsamISAM2Result_constructor_1454(nargout, out, nargin-1, in+1);
      break;
    case 1455:
      gtsamISAM2Result_deconstructor_1455(nargout, out, nargin-1, in+1);
      break;
    case 1456:
      gtsamISAM2Result_getCliques_1456(nargout, out, nargin-1, in+1);
      break;
    case 1457:
      gtsamISAM2Result_getVariablesReeliminated_1457(nargout, out, nargin-1, in+1);
      break;
    case 1458:
      gtsamISAM2Result_getVariablesRelinearized_1458(nargout, out, nargin-1, in+1);
      break;
    case 1459:
      gtsamISAM2Result_print_1459(nargout, out, nargin-1, in+1);
      break;
    case 1460:
      gtsamFactorIndices_collectorInsertAndMakeBase_1460(nargout, out, nargin-1, in+1);
      break;
    case 1461:
      gtsamFactorIndices_deconstructor_1461(nargout, out, nargin-1, in+1);
      break;
    case 1462:
      gtsamISAM2_collectorInsertAndMakeBase_1462(nargout, out, nargin-1, in+1);
      break;
    case 1463:
      gtsamISAM2_constructor_1463(nargout, out, nargin-1, in+1);
      break;
    case 1464:
      gtsamISAM2_constructor_1464(nargout, out, nargin-1, in+1);
      break;
    case 1465:
      gtsamISAM2_constructor_1465(nargout, out, nargin-1, in+1);
      break;
    case 1466:
      gtsamISAM2_deconstructor_1466(nargout, out, nargin-1, in+1);
      break;
    case 1467:
      gtsamISAM2_calculateBestEstimate_1467(nargout, out, nargin-1, in+1);
      break;
    case 1468:
      gtsamISAM2_calculateEstimate_1468(nargout, out, nargin-1, in+1);
      break;
    case 1469:
      gtsamISAM2_calculateEstimate_1469(nargout, out, nargin-1, in+1);
      break;
    case 1470:
      gtsamISAM2_calculateEstimate_1470(nargout, out, nargin-1, in+1);
      break;
    case 1471:
      gtsamISAM2_calculateEstimate_1471(nargout, out, nargin-1, in+1);
      break;
    case 1472:
      gtsamISAM2_calculateEstimate_1472(nargout, out, nargin-1, in+1);
      break;
    case 1473:
      gtsamISAM2_calculateEstimate_1473(nargout, out, nargin-1, in+1);
      break;
    case 1474:
      gtsamISAM2_calculateEstimate_1474(nargout, out, nargin-1, in+1);
      break;
    case 1475:
      gtsamISAM2_calculateEstimate_1475(nargout, out, nargin-1, in+1);
      break;
    case 1476:
      gtsamISAM2_calculateEstimate_1476(nargout, out, nargin-1, in+1);
      break;
    case 1477:
      gtsamISAM2_calculateEstimate_1477(nargout, out, nargin-1, in+1);
      break;
    case 1478:
      gtsamISAM2_calculateEstimate_1478(nargout, out, nargin-1, in+1);
      break;
    case 1479:
      gtsamISAM2_calculateEstimate_1479(nargout, out, nargin-1, in+1);
      break;
    case 1480:
      gtsamISAM2_calculateEstimate_1480(nargout, out, nargin-1, in+1);
      break;
    case 1481:
      gtsamISAM2_calculateEstimate_1481(nargout, out, nargin-1, in+1);
      break;
    case 1482:
      gtsamISAM2_equals_1482(nargout, out, nargin-1, in+1);
      break;
    case 1483:
      gtsamISAM2_getDelta_1483(nargout, out, nargin-1, in+1);
      break;
    case 1484:
      gtsamISAM2_getFactorsUnsafe_1484(nargout, out, nargin-1, in+1);
      break;
    case 1485:
      gtsamISAM2_getLinearizationPoint_1485(nargout, out, nargin-1, in+1);
      break;
    case 1486:
      gtsamISAM2_getVariableIndex_1486(nargout, out, nargin-1, in+1);
      break;
    case 1487:
      gtsamISAM2_marginalCovariance_1487(nargout, out, nargin-1, in+1);
      break;
    case 1488:
      gtsamISAM2_params_1488(nargout, out, nargin-1, in+1);
      break;
    case 1489:
      gtsamISAM2_print_1489(nargout, out, nargin-1, in+1);
      break;
    case 1490:
      gtsamISAM2_printStats_1490(nargout, out, nargin-1, in+1);
      break;
    case 1491:
      gtsamISAM2_saveGraph_1491(nargout, out, nargin-1, in+1);
      break;
    case 1492:
      gtsamISAM2_update_1492(nargout, out, nargin-1, in+1);
      break;
    case 1493:
      gtsamISAM2_update_1493(nargout, out, nargin-1, in+1);
      break;
    case 1494:
      gtsamISAM2_update_1494(nargout, out, nargin-1, in+1);
      break;
    case 1495:
      gtsamISAM2_update_1495(nargout, out, nargin-1, in+1);
      break;
    case 1496:
      gtsamNonlinearISAM_collectorInsertAndMakeBase_1496(nargout, out, nargin-1, in+1);
      break;
    case 1497:
      gtsamNonlinearISAM_constructor_1497(nargout, out, nargin-1, in+1);
      break;
    case 1498:
      gtsamNonlinearISAM_constructor_1498(nargout, out, nargin-1, in+1);
      break;
    case 1499:
      gtsamNonlinearISAM_deconstructor_1499(nargout, out, nargin-1, in+1);
      break;
    case 1500:
      gtsamNonlinearISAM_bayesTree_1500(nargout, out, nargin-1, in+1);
      break;
    case 1501:
      gtsamNonlinearISAM_estimate_1501(nargout, out, nargin-1, in+1);
      break;
    case 1502:
      gtsamNonlinearISAM_getFactorsUnsafe_1502(nargout, out, nargin-1, in+1);
      break;
    case 1503:
      gtsamNonlinearISAM_getLinearizationPoint_1503(nargout, out, nargin-1, in+1);
      break;
    case 1504:
      gtsamNonlinearISAM_marginalCovariance_1504(nargout, out, nargin-1, in+1);
      break;
    case 1505:
      gtsamNonlinearISAM_print_1505(nargout, out, nargin-1, in+1);
      break;
    case 1506:
      gtsamNonlinearISAM_printStats_1506(nargout, out, nargin-1, in+1);
      break;
    case 1507:
      gtsamNonlinearISAM_reorderCounter_1507(nargout, out, nargin-1, in+1);
      break;
    case 1508:
      gtsamNonlinearISAM_reorderInterval_1508(nargout, out, nargin-1, in+1);
      break;
    case 1509:
      gtsamNonlinearISAM_reorder_relinearize_1509(nargout, out, nargin-1, in+1);
      break;
    case 1510:
      gtsamNonlinearISAM_saveGraph_1510(nargout, out, nargin-1, in+1);
      break;
    case 1511:
      gtsamNonlinearISAM_update_1511(nargout, out, nargin-1, in+1);
      break;
    case 1512:
      gtsamPriorFactorVector_collectorInsertAndMakeBase_1512(nargout, out, nargin-1, in+1);
      break;
    case 1513:
      gtsamPriorFactorVector_upcastFromVoid_1513(nargout, out, nargin-1, in+1);
      break;
    case 1514:
      gtsamPriorFactorVector_constructor_1514(nargout, out, nargin-1, in+1);
      break;
    case 1515:
      gtsamPriorFactorVector_deconstructor_1515(nargout, out, nargin-1, in+1);
      break;
    case 1516:
      gtsamPriorFactorVector_active_1516(nargout, out, nargin-1, in+1);
      break;
    case 1517:
      gtsamPriorFactorVector_clone_1517(nargout, out, nargin-1, in+1);
      break;
    case 1518:
      gtsamPriorFactorVector_dim_1518(nargout, out, nargin-1, in+1);
      break;
    case 1519:
      gtsamPriorFactorVector_equals_1519(nargout, out, nargin-1, in+1);
      break;
    case 1520:
      gtsamPriorFactorVector_error_1520(nargout, out, nargin-1, in+1);
      break;
    case 1521:
      gtsamPriorFactorVector_get_noiseModel_1521(nargout, out, nargin-1, in+1);
      break;
    case 1522:
      gtsamPriorFactorVector_keys_1522(nargout, out, nargin-1, in+1);
      break;
    case 1523:
      gtsamPriorFactorVector_linearize_1523(nargout, out, nargin-1, in+1);
      break;
    case 1524:
      gtsamPriorFactorVector_noiseModel_1524(nargout, out, nargin-1, in+1);
      break;
    case 1525:
      gtsamPriorFactorVector_print_1525(nargout, out, nargin-1, in+1);
      break;
    case 1526:
      gtsamPriorFactorVector_printKeys_1526(nargout, out, nargin-1, in+1);
      break;
    case 1527:
      gtsamPriorFactorVector_prior_1527(nargout, out, nargin-1, in+1);
      break;
    case 1528:
      gtsamPriorFactorVector_size_1528(nargout, out, nargin-1, in+1);
      break;
    case 1529:
      gtsamPriorFactorVector_unwhitenedError_1529(nargout, out, nargin-1, in+1);
      break;
    case 1530:
      gtsamPriorFactorVector_whitenedError_1530(nargout, out, nargin-1, in+1);
      break;
    case 1531:
      gtsamPriorFactorVector_string_serialize_1531(nargout, out, nargin-1, in+1);
      break;
    case 1532:
      gtsamPriorFactorVector_string_deserialize_1532(nargout, out, nargin-1, in+1);
      break;
    case 1533:
      gtsamPriorFactorPoint2_collectorInsertAndMakeBase_1533(nargout, out, nargin-1, in+1);
      break;
    case 1534:
      gtsamPriorFactorPoint2_upcastFromVoid_1534(nargout, out, nargin-1, in+1);
      break;
    case 1535:
      gtsamPriorFactorPoint2_constructor_1535(nargout, out, nargin-1, in+1);
      break;
    case 1536:
      gtsamPriorFactorPoint2_deconstructor_1536(nargout, out, nargin-1, in+1);
      break;
    case 1537:
      gtsamPriorFactorPoint2_active_1537(nargout, out, nargin-1, in+1);
      break;
    case 1538:
      gtsamPriorFactorPoint2_clone_1538(nargout, out, nargin-1, in+1);
      break;
    case 1539:
      gtsamPriorFactorPoint2_dim_1539(nargout, out, nargin-1, in+1);
      break;
    case 1540:
      gtsamPriorFactorPoint2_equals_1540(nargout, out, nargin-1, in+1);
      break;
    case 1541:
      gtsamPriorFactorPoint2_error_1541(nargout, out, nargin-1, in+1);
      break;
    case 1542:
      gtsamPriorFactorPoint2_get_noiseModel_1542(nargout, out, nargin-1, in+1);
      break;
    case 1543:
      gtsamPriorFactorPoint2_keys_1543(nargout, out, nargin-1, in+1);
      break;
    case 1544:
      gtsamPriorFactorPoint2_linearize_1544(nargout, out, nargin-1, in+1);
      break;
    case 1545:
      gtsamPriorFactorPoint2_noiseModel_1545(nargout, out, nargin-1, in+1);
      break;
    case 1546:
      gtsamPriorFactorPoint2_print_1546(nargout, out, nargin-1, in+1);
      break;
    case 1547:
      gtsamPriorFactorPoint2_printKeys_1547(nargout, out, nargin-1, in+1);
      break;
    case 1548:
      gtsamPriorFactorPoint2_prior_1548(nargout, out, nargin-1, in+1);
      break;
    case 1549:
      gtsamPriorFactorPoint2_size_1549(nargout, out, nargin-1, in+1);
      break;
    case 1550:
      gtsamPriorFactorPoint2_unwhitenedError_1550(nargout, out, nargin-1, in+1);
      break;
    case 1551:
      gtsamPriorFactorPoint2_whitenedError_1551(nargout, out, nargin-1, in+1);
      break;
    case 1552:
      gtsamPriorFactorPoint2_string_serialize_1552(nargout, out, nargin-1, in+1);
      break;
    case 1553:
      gtsamPriorFactorPoint2_string_deserialize_1553(nargout, out, nargin-1, in+1);
      break;
    case 1554:
      gtsamPriorFactorStereoPoint2_collectorInsertAndMakeBase_1554(nargout, out, nargin-1, in+1);
      break;
    case 1555:
      gtsamPriorFactorStereoPoint2_upcastFromVoid_1555(nargout, out, nargin-1, in+1);
      break;
    case 1556:
      gtsamPriorFactorStereoPoint2_constructor_1556(nargout, out, nargin-1, in+1);
      break;
    case 1557:
      gtsamPriorFactorStereoPoint2_deconstructor_1557(nargout, out, nargin-1, in+1);
      break;
    case 1558:
      gtsamPriorFactorStereoPoint2_active_1558(nargout, out, nargin-1, in+1);
      break;
    case 1559:
      gtsamPriorFactorStereoPoint2_clone_1559(nargout, out, nargin-1, in+1);
      break;
    case 1560:
      gtsamPriorFactorStereoPoint2_dim_1560(nargout, out, nargin-1, in+1);
      break;
    case 1561:
      gtsamPriorFactorStereoPoint2_equals_1561(nargout, out, nargin-1, in+1);
      break;
    case 1562:
      gtsamPriorFactorStereoPoint2_error_1562(nargout, out, nargin-1, in+1);
      break;
    case 1563:
      gtsamPriorFactorStereoPoint2_get_noiseModel_1563(nargout, out, nargin-1, in+1);
      break;
    case 1564:
      gtsamPriorFactorStereoPoint2_keys_1564(nargout, out, nargin-1, in+1);
      break;
    case 1565:
      gtsamPriorFactorStereoPoint2_linearize_1565(nargout, out, nargin-1, in+1);
      break;
    case 1566:
      gtsamPriorFactorStereoPoint2_noiseModel_1566(nargout, out, nargin-1, in+1);
      break;
    case 1567:
      gtsamPriorFactorStereoPoint2_print_1567(nargout, out, nargin-1, in+1);
      break;
    case 1568:
      gtsamPriorFactorStereoPoint2_printKeys_1568(nargout, out, nargin-1, in+1);
      break;
    case 1569:
      gtsamPriorFactorStereoPoint2_prior_1569(nargout, out, nargin-1, in+1);
      break;
    case 1570:
      gtsamPriorFactorStereoPoint2_size_1570(nargout, out, nargin-1, in+1);
      break;
    case 1571:
      gtsamPriorFactorStereoPoint2_unwhitenedError_1571(nargout, out, nargin-1, in+1);
      break;
    case 1572:
      gtsamPriorFactorStereoPoint2_whitenedError_1572(nargout, out, nargin-1, in+1);
      break;
    case 1573:
      gtsamPriorFactorStereoPoint2_string_serialize_1573(nargout, out, nargin-1, in+1);
      break;
    case 1574:
      gtsamPriorFactorStereoPoint2_string_deserialize_1574(nargout, out, nargin-1, in+1);
      break;
    case 1575:
      gtsamPriorFactorPoint3_collectorInsertAndMakeBase_1575(nargout, out, nargin-1, in+1);
      break;
    case 1576:
      gtsamPriorFactorPoint3_upcastFromVoid_1576(nargout, out, nargin-1, in+1);
      break;
    case 1577:
      gtsamPriorFactorPoint3_constructor_1577(nargout, out, nargin-1, in+1);
      break;
    case 1578:
      gtsamPriorFactorPoint3_deconstructor_1578(nargout, out, nargin-1, in+1);
      break;
    case 1579:
      gtsamPriorFactorPoint3_active_1579(nargout, out, nargin-1, in+1);
      break;
    case 1580:
      gtsamPriorFactorPoint3_clone_1580(nargout, out, nargin-1, in+1);
      break;
    case 1581:
      gtsamPriorFactorPoint3_dim_1581(nargout, out, nargin-1, in+1);
      break;
    case 1582:
      gtsamPriorFactorPoint3_equals_1582(nargout, out, nargin-1, in+1);
      break;
    case 1583:
      gtsamPriorFactorPoint3_error_1583(nargout, out, nargin-1, in+1);
      break;
    case 1584:
      gtsamPriorFactorPoint3_get_noiseModel_1584(nargout, out, nargin-1, in+1);
      break;
    case 1585:
      gtsamPriorFactorPoint3_keys_1585(nargout, out, nargin-1, in+1);
      break;
    case 1586:
      gtsamPriorFactorPoint3_linearize_1586(nargout, out, nargin-1, in+1);
      break;
    case 1587:
      gtsamPriorFactorPoint3_noiseModel_1587(nargout, out, nargin-1, in+1);
      break;
    case 1588:
      gtsamPriorFactorPoint3_print_1588(nargout, out, nargin-1, in+1);
      break;
    case 1589:
      gtsamPriorFactorPoint3_printKeys_1589(nargout, out, nargin-1, in+1);
      break;
    case 1590:
      gtsamPriorFactorPoint3_prior_1590(nargout, out, nargin-1, in+1);
      break;
    case 1591:
      gtsamPriorFactorPoint3_size_1591(nargout, out, nargin-1, in+1);
      break;
    case 1592:
      gtsamPriorFactorPoint3_unwhitenedError_1592(nargout, out, nargin-1, in+1);
      break;
    case 1593:
      gtsamPriorFactorPoint3_whitenedError_1593(nargout, out, nargin-1, in+1);
      break;
    case 1594:
      gtsamPriorFactorPoint3_string_serialize_1594(nargout, out, nargin-1, in+1);
      break;
    case 1595:
      gtsamPriorFactorPoint3_string_deserialize_1595(nargout, out, nargin-1, in+1);
      break;
    case 1596:
      gtsamPriorFactorRot2_collectorInsertAndMakeBase_1596(nargout, out, nargin-1, in+1);
      break;
    case 1597:
      gtsamPriorFactorRot2_upcastFromVoid_1597(nargout, out, nargin-1, in+1);
      break;
    case 1598:
      gtsamPriorFactorRot2_constructor_1598(nargout, out, nargin-1, in+1);
      break;
    case 1599:
      gtsamPriorFactorRot2_deconstructor_1599(nargout, out, nargin-1, in+1);
      break;
    case 1600:
      gtsamPriorFactorRot2_active_1600(nargout, out, nargin-1, in+1);
      break;
    case 1601:
      gtsamPriorFactorRot2_clone_1601(nargout, out, nargin-1, in+1);
      break;
    case 1602:
      gtsamPriorFactorRot2_dim_1602(nargout, out, nargin-1, in+1);
      break;
    case 1603:
      gtsamPriorFactorRot2_equals_1603(nargout, out, nargin-1, in+1);
      break;
    case 1604:
      gtsamPriorFactorRot2_error_1604(nargout, out, nargin-1, in+1);
      break;
    case 1605:
      gtsamPriorFactorRot2_get_noiseModel_1605(nargout, out, nargin-1, in+1);
      break;
    case 1606:
      gtsamPriorFactorRot2_keys_1606(nargout, out, nargin-1, in+1);
      break;
    case 1607:
      gtsamPriorFactorRot2_linearize_1607(nargout, out, nargin-1, in+1);
      break;
    case 1608:
      gtsamPriorFactorRot2_noiseModel_1608(nargout, out, nargin-1, in+1);
      break;
    case 1609:
      gtsamPriorFactorRot2_print_1609(nargout, out, nargin-1, in+1);
      break;
    case 1610:
      gtsamPriorFactorRot2_printKeys_1610(nargout, out, nargin-1, in+1);
      break;
    case 1611:
      gtsamPriorFactorRot2_prior_1611(nargout, out, nargin-1, in+1);
      break;
    case 1612:
      gtsamPriorFactorRot2_size_1612(nargout, out, nargin-1, in+1);
      break;
    case 1613:
      gtsamPriorFactorRot2_unwhitenedError_1613(nargout, out, nargin-1, in+1);
      break;
    case 1614:
      gtsamPriorFactorRot2_whitenedError_1614(nargout, out, nargin-1, in+1);
      break;
    case 1615:
      gtsamPriorFactorRot2_string_serialize_1615(nargout, out, nargin-1, in+1);
      break;
    case 1616:
      gtsamPriorFactorRot2_string_deserialize_1616(nargout, out, nargin-1, in+1);
      break;
    case 1617:
      gtsamPriorFactorRot3_collectorInsertAndMakeBase_1617(nargout, out, nargin-1, in+1);
      break;
    case 1618:
      gtsamPriorFactorRot3_upcastFromVoid_1618(nargout, out, nargin-1, in+1);
      break;
    case 1619:
      gtsamPriorFactorRot3_constructor_1619(nargout, out, nargin-1, in+1);
      break;
    case 1620:
      gtsamPriorFactorRot3_deconstructor_1620(nargout, out, nargin-1, in+1);
      break;
    case 1621:
      gtsamPriorFactorRot3_active_1621(nargout, out, nargin-1, in+1);
      break;
    case 1622:
      gtsamPriorFactorRot3_clone_1622(nargout, out, nargin-1, in+1);
      break;
    case 1623:
      gtsamPriorFactorRot3_dim_1623(nargout, out, nargin-1, in+1);
      break;
    case 1624:
      gtsamPriorFactorRot3_equals_1624(nargout, out, nargin-1, in+1);
      break;
    case 1625:
      gtsamPriorFactorRot3_error_1625(nargout, out, nargin-1, in+1);
      break;
    case 1626:
      gtsamPriorFactorRot3_get_noiseModel_1626(nargout, out, nargin-1, in+1);
      break;
    case 1627:
      gtsamPriorFactorRot3_keys_1627(nargout, out, nargin-1, in+1);
      break;
    case 1628:
      gtsamPriorFactorRot3_linearize_1628(nargout, out, nargin-1, in+1);
      break;
    case 1629:
      gtsamPriorFactorRot3_noiseModel_1629(nargout, out, nargin-1, in+1);
      break;
    case 1630:
      gtsamPriorFactorRot3_print_1630(nargout, out, nargin-1, in+1);
      break;
    case 1631:
      gtsamPriorFactorRot3_printKeys_1631(nargout, out, nargin-1, in+1);
      break;
    case 1632:
      gtsamPriorFactorRot3_prior_1632(nargout, out, nargin-1, in+1);
      break;
    case 1633:
      gtsamPriorFactorRot3_size_1633(nargout, out, nargin-1, in+1);
      break;
    case 1634:
      gtsamPriorFactorRot3_unwhitenedError_1634(nargout, out, nargin-1, in+1);
      break;
    case 1635:
      gtsamPriorFactorRot3_whitenedError_1635(nargout, out, nargin-1, in+1);
      break;
    case 1636:
      gtsamPriorFactorRot3_string_serialize_1636(nargout, out, nargin-1, in+1);
      break;
    case 1637:
      gtsamPriorFactorRot3_string_deserialize_1637(nargout, out, nargin-1, in+1);
      break;
    case 1638:
      gtsamPriorFactorPose2_collectorInsertAndMakeBase_1638(nargout, out, nargin-1, in+1);
      break;
    case 1639:
      gtsamPriorFactorPose2_upcastFromVoid_1639(nargout, out, nargin-1, in+1);
      break;
    case 1640:
      gtsamPriorFactorPose2_constructor_1640(nargout, out, nargin-1, in+1);
      break;
    case 1641:
      gtsamPriorFactorPose2_deconstructor_1641(nargout, out, nargin-1, in+1);
      break;
    case 1642:
      gtsamPriorFactorPose2_active_1642(nargout, out, nargin-1, in+1);
      break;
    case 1643:
      gtsamPriorFactorPose2_clone_1643(nargout, out, nargin-1, in+1);
      break;
    case 1644:
      gtsamPriorFactorPose2_dim_1644(nargout, out, nargin-1, in+1);
      break;
    case 1645:
      gtsamPriorFactorPose2_equals_1645(nargout, out, nargin-1, in+1);
      break;
    case 1646:
      gtsamPriorFactorPose2_error_1646(nargout, out, nargin-1, in+1);
      break;
    case 1647:
      gtsamPriorFactorPose2_get_noiseModel_1647(nargout, out, nargin-1, in+1);
      break;
    case 1648:
      gtsamPriorFactorPose2_keys_1648(nargout, out, nargin-1, in+1);
      break;
    case 1649:
      gtsamPriorFactorPose2_linearize_1649(nargout, out, nargin-1, in+1);
      break;
    case 1650:
      gtsamPriorFactorPose2_noiseModel_1650(nargout, out, nargin-1, in+1);
      break;
    case 1651:
      gtsamPriorFactorPose2_print_1651(nargout, out, nargin-1, in+1);
      break;
    case 1652:
      gtsamPriorFactorPose2_printKeys_1652(nargout, out, nargin-1, in+1);
      break;
    case 1653:
      gtsamPriorFactorPose2_prior_1653(nargout, out, nargin-1, in+1);
      break;
    case 1654:
      gtsamPriorFactorPose2_size_1654(nargout, out, nargin-1, in+1);
      break;
    case 1655:
      gtsamPriorFactorPose2_unwhitenedError_1655(nargout, out, nargin-1, in+1);
      break;
    case 1656:
      gtsamPriorFactorPose2_whitenedError_1656(nargout, out, nargin-1, in+1);
      break;
    case 1657:
      gtsamPriorFactorPose2_string_serialize_1657(nargout, out, nargin-1, in+1);
      break;
    case 1658:
      gtsamPriorFactorPose2_string_deserialize_1658(nargout, out, nargin-1, in+1);
      break;
    case 1659:
      gtsamPriorFactorPose3_collectorInsertAndMakeBase_1659(nargout, out, nargin-1, in+1);
      break;
    case 1660:
      gtsamPriorFactorPose3_upcastFromVoid_1660(nargout, out, nargin-1, in+1);
      break;
    case 1661:
      gtsamPriorFactorPose3_constructor_1661(nargout, out, nargin-1, in+1);
      break;
    case 1662:
      gtsamPriorFactorPose3_deconstructor_1662(nargout, out, nargin-1, in+1);
      break;
    case 1663:
      gtsamPriorFactorPose3_active_1663(nargout, out, nargin-1, in+1);
      break;
    case 1664:
      gtsamPriorFactorPose3_clone_1664(nargout, out, nargin-1, in+1);
      break;
    case 1665:
      gtsamPriorFactorPose3_dim_1665(nargout, out, nargin-1, in+1);
      break;
    case 1666:
      gtsamPriorFactorPose3_equals_1666(nargout, out, nargin-1, in+1);
      break;
    case 1667:
      gtsamPriorFactorPose3_error_1667(nargout, out, nargin-1, in+1);
      break;
    case 1668:
      gtsamPriorFactorPose3_get_noiseModel_1668(nargout, out, nargin-1, in+1);
      break;
    case 1669:
      gtsamPriorFactorPose3_keys_1669(nargout, out, nargin-1, in+1);
      break;
    case 1670:
      gtsamPriorFactorPose3_linearize_1670(nargout, out, nargin-1, in+1);
      break;
    case 1671:
      gtsamPriorFactorPose3_noiseModel_1671(nargout, out, nargin-1, in+1);
      break;
    case 1672:
      gtsamPriorFactorPose3_print_1672(nargout, out, nargin-1, in+1);
      break;
    case 1673:
      gtsamPriorFactorPose3_printKeys_1673(nargout, out, nargin-1, in+1);
      break;
    case 1674:
      gtsamPriorFactorPose3_prior_1674(nargout, out, nargin-1, in+1);
      break;
    case 1675:
      gtsamPriorFactorPose3_size_1675(nargout, out, nargin-1, in+1);
      break;
    case 1676:
      gtsamPriorFactorPose3_unwhitenedError_1676(nargout, out, nargin-1, in+1);
      break;
    case 1677:
      gtsamPriorFactorPose3_whitenedError_1677(nargout, out, nargin-1, in+1);
      break;
    case 1678:
      gtsamPriorFactorPose3_string_serialize_1678(nargout, out, nargin-1, in+1);
      break;
    case 1679:
      gtsamPriorFactorPose3_string_deserialize_1679(nargout, out, nargin-1, in+1);
      break;
    case 1680:
      gtsamPriorFactorCal3_S2_collectorInsertAndMakeBase_1680(nargout, out, nargin-1, in+1);
      break;
    case 1681:
      gtsamPriorFactorCal3_S2_upcastFromVoid_1681(nargout, out, nargin-1, in+1);
      break;
    case 1682:
      gtsamPriorFactorCal3_S2_constructor_1682(nargout, out, nargin-1, in+1);
      break;
    case 1683:
      gtsamPriorFactorCal3_S2_deconstructor_1683(nargout, out, nargin-1, in+1);
      break;
    case 1684:
      gtsamPriorFactorCal3_S2_active_1684(nargout, out, nargin-1, in+1);
      break;
    case 1685:
      gtsamPriorFactorCal3_S2_clone_1685(nargout, out, nargin-1, in+1);
      break;
    case 1686:
      gtsamPriorFactorCal3_S2_dim_1686(nargout, out, nargin-1, in+1);
      break;
    case 1687:
      gtsamPriorFactorCal3_S2_equals_1687(nargout, out, nargin-1, in+1);
      break;
    case 1688:
      gtsamPriorFactorCal3_S2_error_1688(nargout, out, nargin-1, in+1);
      break;
    case 1689:
      gtsamPriorFactorCal3_S2_get_noiseModel_1689(nargout, out, nargin-1, in+1);
      break;
    case 1690:
      gtsamPriorFactorCal3_S2_keys_1690(nargout, out, nargin-1, in+1);
      break;
    case 1691:
      gtsamPriorFactorCal3_S2_linearize_1691(nargout, out, nargin-1, in+1);
      break;
    case 1692:
      gtsamPriorFactorCal3_S2_noiseModel_1692(nargout, out, nargin-1, in+1);
      break;
    case 1693:
      gtsamPriorFactorCal3_S2_print_1693(nargout, out, nargin-1, in+1);
      break;
    case 1694:
      gtsamPriorFactorCal3_S2_printKeys_1694(nargout, out, nargin-1, in+1);
      break;
    case 1695:
      gtsamPriorFactorCal3_S2_prior_1695(nargout, out, nargin-1, in+1);
      break;
    case 1696:
      gtsamPriorFactorCal3_S2_size_1696(nargout, out, nargin-1, in+1);
      break;
    case 1697:
      gtsamPriorFactorCal3_S2_unwhitenedError_1697(nargout, out, nargin-1, in+1);
      break;
    case 1698:
      gtsamPriorFactorCal3_S2_whitenedError_1698(nargout, out, nargin-1, in+1);
      break;
    case 1699:
      gtsamPriorFactorCal3_S2_string_serialize_1699(nargout, out, nargin-1, in+1);
      break;
    case 1700:
      gtsamPriorFactorCal3_S2_string_deserialize_1700(nargout, out, nargin-1, in+1);
      break;
    case 1701:
      gtsamPriorFactorCalibratedCamera_collectorInsertAndMakeBase_1701(nargout, out, nargin-1, in+1);
      break;
    case 1702:
      gtsamPriorFactorCalibratedCamera_upcastFromVoid_1702(nargout, out, nargin-1, in+1);
      break;
    case 1703:
      gtsamPriorFactorCalibratedCamera_constructor_1703(nargout, out, nargin-1, in+1);
      break;
    case 1704:
      gtsamPriorFactorCalibratedCamera_deconstructor_1704(nargout, out, nargin-1, in+1);
      break;
    case 1705:
      gtsamPriorFactorCalibratedCamera_active_1705(nargout, out, nargin-1, in+1);
      break;
    case 1706:
      gtsamPriorFactorCalibratedCamera_clone_1706(nargout, out, nargin-1, in+1);
      break;
    case 1707:
      gtsamPriorFactorCalibratedCamera_dim_1707(nargout, out, nargin-1, in+1);
      break;
    case 1708:
      gtsamPriorFactorCalibratedCamera_equals_1708(nargout, out, nargin-1, in+1);
      break;
    case 1709:
      gtsamPriorFactorCalibratedCamera_error_1709(nargout, out, nargin-1, in+1);
      break;
    case 1710:
      gtsamPriorFactorCalibratedCamera_get_noiseModel_1710(nargout, out, nargin-1, in+1);
      break;
    case 1711:
      gtsamPriorFactorCalibratedCamera_keys_1711(nargout, out, nargin-1, in+1);
      break;
    case 1712:
      gtsamPriorFactorCalibratedCamera_linearize_1712(nargout, out, nargin-1, in+1);
      break;
    case 1713:
      gtsamPriorFactorCalibratedCamera_noiseModel_1713(nargout, out, nargin-1, in+1);
      break;
    case 1714:
      gtsamPriorFactorCalibratedCamera_print_1714(nargout, out, nargin-1, in+1);
      break;
    case 1715:
      gtsamPriorFactorCalibratedCamera_printKeys_1715(nargout, out, nargin-1, in+1);
      break;
    case 1716:
      gtsamPriorFactorCalibratedCamera_prior_1716(nargout, out, nargin-1, in+1);
      break;
    case 1717:
      gtsamPriorFactorCalibratedCamera_size_1717(nargout, out, nargin-1, in+1);
      break;
    case 1718:
      gtsamPriorFactorCalibratedCamera_unwhitenedError_1718(nargout, out, nargin-1, in+1);
      break;
    case 1719:
      gtsamPriorFactorCalibratedCamera_whitenedError_1719(nargout, out, nargin-1, in+1);
      break;
    case 1720:
      gtsamPriorFactorCalibratedCamera_string_serialize_1720(nargout, out, nargin-1, in+1);
      break;
    case 1721:
      gtsamPriorFactorCalibratedCamera_string_deserialize_1721(nargout, out, nargin-1, in+1);
      break;
    case 1722:
      gtsamPriorFactorSimpleCamera_collectorInsertAndMakeBase_1722(nargout, out, nargin-1, in+1);
      break;
    case 1723:
      gtsamPriorFactorSimpleCamera_upcastFromVoid_1723(nargout, out, nargin-1, in+1);
      break;
    case 1724:
      gtsamPriorFactorSimpleCamera_constructor_1724(nargout, out, nargin-1, in+1);
      break;
    case 1725:
      gtsamPriorFactorSimpleCamera_deconstructor_1725(nargout, out, nargin-1, in+1);
      break;
    case 1726:
      gtsamPriorFactorSimpleCamera_active_1726(nargout, out, nargin-1, in+1);
      break;
    case 1727:
      gtsamPriorFactorSimpleCamera_clone_1727(nargout, out, nargin-1, in+1);
      break;
    case 1728:
      gtsamPriorFactorSimpleCamera_dim_1728(nargout, out, nargin-1, in+1);
      break;
    case 1729:
      gtsamPriorFactorSimpleCamera_equals_1729(nargout, out, nargin-1, in+1);
      break;
    case 1730:
      gtsamPriorFactorSimpleCamera_error_1730(nargout, out, nargin-1, in+1);
      break;
    case 1731:
      gtsamPriorFactorSimpleCamera_get_noiseModel_1731(nargout, out, nargin-1, in+1);
      break;
    case 1732:
      gtsamPriorFactorSimpleCamera_keys_1732(nargout, out, nargin-1, in+1);
      break;
    case 1733:
      gtsamPriorFactorSimpleCamera_linearize_1733(nargout, out, nargin-1, in+1);
      break;
    case 1734:
      gtsamPriorFactorSimpleCamera_noiseModel_1734(nargout, out, nargin-1, in+1);
      break;
    case 1735:
      gtsamPriorFactorSimpleCamera_print_1735(nargout, out, nargin-1, in+1);
      break;
    case 1736:
      gtsamPriorFactorSimpleCamera_printKeys_1736(nargout, out, nargin-1, in+1);
      break;
    case 1737:
      gtsamPriorFactorSimpleCamera_prior_1737(nargout, out, nargin-1, in+1);
      break;
    case 1738:
      gtsamPriorFactorSimpleCamera_size_1738(nargout, out, nargin-1, in+1);
      break;
    case 1739:
      gtsamPriorFactorSimpleCamera_unwhitenedError_1739(nargout, out, nargin-1, in+1);
      break;
    case 1740:
      gtsamPriorFactorSimpleCamera_whitenedError_1740(nargout, out, nargin-1, in+1);
      break;
    case 1741:
      gtsamPriorFactorSimpleCamera_string_serialize_1741(nargout, out, nargin-1, in+1);
      break;
    case 1742:
      gtsamPriorFactorSimpleCamera_string_deserialize_1742(nargout, out, nargin-1, in+1);
      break;
    case 1743:
      gtsamPriorFactorConstantBias_collectorInsertAndMakeBase_1743(nargout, out, nargin-1, in+1);
      break;
    case 1744:
      gtsamPriorFactorConstantBias_upcastFromVoid_1744(nargout, out, nargin-1, in+1);
      break;
    case 1745:
      gtsamPriorFactorConstantBias_constructor_1745(nargout, out, nargin-1, in+1);
      break;
    case 1746:
      gtsamPriorFactorConstantBias_deconstructor_1746(nargout, out, nargin-1, in+1);
      break;
    case 1747:
      gtsamPriorFactorConstantBias_active_1747(nargout, out, nargin-1, in+1);
      break;
    case 1748:
      gtsamPriorFactorConstantBias_clone_1748(nargout, out, nargin-1, in+1);
      break;
    case 1749:
      gtsamPriorFactorConstantBias_dim_1749(nargout, out, nargin-1, in+1);
      break;
    case 1750:
      gtsamPriorFactorConstantBias_equals_1750(nargout, out, nargin-1, in+1);
      break;
    case 1751:
      gtsamPriorFactorConstantBias_error_1751(nargout, out, nargin-1, in+1);
      break;
    case 1752:
      gtsamPriorFactorConstantBias_get_noiseModel_1752(nargout, out, nargin-1, in+1);
      break;
    case 1753:
      gtsamPriorFactorConstantBias_keys_1753(nargout, out, nargin-1, in+1);
      break;
    case 1754:
      gtsamPriorFactorConstantBias_linearize_1754(nargout, out, nargin-1, in+1);
      break;
    case 1755:
      gtsamPriorFactorConstantBias_noiseModel_1755(nargout, out, nargin-1, in+1);
      break;
    case 1756:
      gtsamPriorFactorConstantBias_print_1756(nargout, out, nargin-1, in+1);
      break;
    case 1757:
      gtsamPriorFactorConstantBias_printKeys_1757(nargout, out, nargin-1, in+1);
      break;
    case 1758:
      gtsamPriorFactorConstantBias_prior_1758(nargout, out, nargin-1, in+1);
      break;
    case 1759:
      gtsamPriorFactorConstantBias_size_1759(nargout, out, nargin-1, in+1);
      break;
    case 1760:
      gtsamPriorFactorConstantBias_unwhitenedError_1760(nargout, out, nargin-1, in+1);
      break;
    case 1761:
      gtsamPriorFactorConstantBias_whitenedError_1761(nargout, out, nargin-1, in+1);
      break;
    case 1762:
      gtsamPriorFactorConstantBias_string_serialize_1762(nargout, out, nargin-1, in+1);
      break;
    case 1763:
      gtsamPriorFactorConstantBias_string_deserialize_1763(nargout, out, nargin-1, in+1);
      break;
    case 1764:
      gtsamBetweenFactorPoint2_collectorInsertAndMakeBase_1764(nargout, out, nargin-1, in+1);
      break;
    case 1765:
      gtsamBetweenFactorPoint2_upcastFromVoid_1765(nargout, out, nargin-1, in+1);
      break;
    case 1766:
      gtsamBetweenFactorPoint2_constructor_1766(nargout, out, nargin-1, in+1);
      break;
    case 1767:
      gtsamBetweenFactorPoint2_deconstructor_1767(nargout, out, nargin-1, in+1);
      break;
    case 1768:
      gtsamBetweenFactorPoint2_active_1768(nargout, out, nargin-1, in+1);
      break;
    case 1769:
      gtsamBetweenFactorPoint2_clone_1769(nargout, out, nargin-1, in+1);
      break;
    case 1770:
      gtsamBetweenFactorPoint2_dim_1770(nargout, out, nargin-1, in+1);
      break;
    case 1771:
      gtsamBetweenFactorPoint2_equals_1771(nargout, out, nargin-1, in+1);
      break;
    case 1772:
      gtsamBetweenFactorPoint2_error_1772(nargout, out, nargin-1, in+1);
      break;
    case 1773:
      gtsamBetweenFactorPoint2_get_noiseModel_1773(nargout, out, nargin-1, in+1);
      break;
    case 1774:
      gtsamBetweenFactorPoint2_keys_1774(nargout, out, nargin-1, in+1);
      break;
    case 1775:
      gtsamBetweenFactorPoint2_linearize_1775(nargout, out, nargin-1, in+1);
      break;
    case 1776:
      gtsamBetweenFactorPoint2_measured_1776(nargout, out, nargin-1, in+1);
      break;
    case 1777:
      gtsamBetweenFactorPoint2_noiseModel_1777(nargout, out, nargin-1, in+1);
      break;
    case 1778:
      gtsamBetweenFactorPoint2_print_1778(nargout, out, nargin-1, in+1);
      break;
    case 1779:
      gtsamBetweenFactorPoint2_printKeys_1779(nargout, out, nargin-1, in+1);
      break;
    case 1780:
      gtsamBetweenFactorPoint2_size_1780(nargout, out, nargin-1, in+1);
      break;
    case 1781:
      gtsamBetweenFactorPoint2_unwhitenedError_1781(nargout, out, nargin-1, in+1);
      break;
    case 1782:
      gtsamBetweenFactorPoint2_whitenedError_1782(nargout, out, nargin-1, in+1);
      break;
    case 1783:
      gtsamBetweenFactorPoint2_string_serialize_1783(nargout, out, nargin-1, in+1);
      break;
    case 1784:
      gtsamBetweenFactorPoint2_string_deserialize_1784(nargout, out, nargin-1, in+1);
      break;
    case 1785:
      gtsamBetweenFactorPoint3_collectorInsertAndMakeBase_1785(nargout, out, nargin-1, in+1);
      break;
    case 1786:
      gtsamBetweenFactorPoint3_upcastFromVoid_1786(nargout, out, nargin-1, in+1);
      break;
    case 1787:
      gtsamBetweenFactorPoint3_constructor_1787(nargout, out, nargin-1, in+1);
      break;
    case 1788:
      gtsamBetweenFactorPoint3_deconstructor_1788(nargout, out, nargin-1, in+1);
      break;
    case 1789:
      gtsamBetweenFactorPoint3_active_1789(nargout, out, nargin-1, in+1);
      break;
    case 1790:
      gtsamBetweenFactorPoint3_clone_1790(nargout, out, nargin-1, in+1);
      break;
    case 1791:
      gtsamBetweenFactorPoint3_dim_1791(nargout, out, nargin-1, in+1);
      break;
    case 1792:
      gtsamBetweenFactorPoint3_equals_1792(nargout, out, nargin-1, in+1);
      break;
    case 1793:
      gtsamBetweenFactorPoint3_error_1793(nargout, out, nargin-1, in+1);
      break;
    case 1794:
      gtsamBetweenFactorPoint3_get_noiseModel_1794(nargout, out, nargin-1, in+1);
      break;
    case 1795:
      gtsamBetweenFactorPoint3_keys_1795(nargout, out, nargin-1, in+1);
      break;
    case 1796:
      gtsamBetweenFactorPoint3_linearize_1796(nargout, out, nargin-1, in+1);
      break;
    case 1797:
      gtsamBetweenFactorPoint3_measured_1797(nargout, out, nargin-1, in+1);
      break;
    case 1798:
      gtsamBetweenFactorPoint3_noiseModel_1798(nargout, out, nargin-1, in+1);
      break;
    case 1799:
      gtsamBetweenFactorPoint3_print_1799(nargout, out, nargin-1, in+1);
      break;
    case 1800:
      gtsamBetweenFactorPoint3_printKeys_1800(nargout, out, nargin-1, in+1);
      break;
    case 1801:
      gtsamBetweenFactorPoint3_size_1801(nargout, out, nargin-1, in+1);
      break;
    case 1802:
      gtsamBetweenFactorPoint3_unwhitenedError_1802(nargout, out, nargin-1, in+1);
      break;
    case 1803:
      gtsamBetweenFactorPoint3_whitenedError_1803(nargout, out, nargin-1, in+1);
      break;
    case 1804:
      gtsamBetweenFactorPoint3_string_serialize_1804(nargout, out, nargin-1, in+1);
      break;
    case 1805:
      gtsamBetweenFactorPoint3_string_deserialize_1805(nargout, out, nargin-1, in+1);
      break;
    case 1806:
      gtsamBetweenFactorRot2_collectorInsertAndMakeBase_1806(nargout, out, nargin-1, in+1);
      break;
    case 1807:
      gtsamBetweenFactorRot2_upcastFromVoid_1807(nargout, out, nargin-1, in+1);
      break;
    case 1808:
      gtsamBetweenFactorRot2_constructor_1808(nargout, out, nargin-1, in+1);
      break;
    case 1809:
      gtsamBetweenFactorRot2_deconstructor_1809(nargout, out, nargin-1, in+1);
      break;
    case 1810:
      gtsamBetweenFactorRot2_active_1810(nargout, out, nargin-1, in+1);
      break;
    case 1811:
      gtsamBetweenFactorRot2_clone_1811(nargout, out, nargin-1, in+1);
      break;
    case 1812:
      gtsamBetweenFactorRot2_dim_1812(nargout, out, nargin-1, in+1);
      break;
    case 1813:
      gtsamBetweenFactorRot2_equals_1813(nargout, out, nargin-1, in+1);
      break;
    case 1814:
      gtsamBetweenFactorRot2_error_1814(nargout, out, nargin-1, in+1);
      break;
    case 1815:
      gtsamBetweenFactorRot2_get_noiseModel_1815(nargout, out, nargin-1, in+1);
      break;
    case 1816:
      gtsamBetweenFactorRot2_keys_1816(nargout, out, nargin-1, in+1);
      break;
    case 1817:
      gtsamBetweenFactorRot2_linearize_1817(nargout, out, nargin-1, in+1);
      break;
    case 1818:
      gtsamBetweenFactorRot2_measured_1818(nargout, out, nargin-1, in+1);
      break;
    case 1819:
      gtsamBetweenFactorRot2_noiseModel_1819(nargout, out, nargin-1, in+1);
      break;
    case 1820:
      gtsamBetweenFactorRot2_print_1820(nargout, out, nargin-1, in+1);
      break;
    case 1821:
      gtsamBetweenFactorRot2_printKeys_1821(nargout, out, nargin-1, in+1);
      break;
    case 1822:
      gtsamBetweenFactorRot2_size_1822(nargout, out, nargin-1, in+1);
      break;
    case 1823:
      gtsamBetweenFactorRot2_unwhitenedError_1823(nargout, out, nargin-1, in+1);
      break;
    case 1824:
      gtsamBetweenFactorRot2_whitenedError_1824(nargout, out, nargin-1, in+1);
      break;
    case 1825:
      gtsamBetweenFactorRot2_string_serialize_1825(nargout, out, nargin-1, in+1);
      break;
    case 1826:
      gtsamBetweenFactorRot2_string_deserialize_1826(nargout, out, nargin-1, in+1);
      break;
    case 1827:
      gtsamBetweenFactorRot3_collectorInsertAndMakeBase_1827(nargout, out, nargin-1, in+1);
      break;
    case 1828:
      gtsamBetweenFactorRot3_upcastFromVoid_1828(nargout, out, nargin-1, in+1);
      break;
    case 1829:
      gtsamBetweenFactorRot3_constructor_1829(nargout, out, nargin-1, in+1);
      break;
    case 1830:
      gtsamBetweenFactorRot3_deconstructor_1830(nargout, out, nargin-1, in+1);
      break;
    case 1831:
      gtsamBetweenFactorRot3_active_1831(nargout, out, nargin-1, in+1);
      break;
    case 1832:
      gtsamBetweenFactorRot3_clone_1832(nargout, out, nargin-1, in+1);
      break;
    case 1833:
      gtsamBetweenFactorRot3_dim_1833(nargout, out, nargin-1, in+1);
      break;
    case 1834:
      gtsamBetweenFactorRot3_equals_1834(nargout, out, nargin-1, in+1);
      break;
    case 1835:
      gtsamBetweenFactorRot3_error_1835(nargout, out, nargin-1, in+1);
      break;
    case 1836:
      gtsamBetweenFactorRot3_get_noiseModel_1836(nargout, out, nargin-1, in+1);
      break;
    case 1837:
      gtsamBetweenFactorRot3_keys_1837(nargout, out, nargin-1, in+1);
      break;
    case 1838:
      gtsamBetweenFactorRot3_linearize_1838(nargout, out, nargin-1, in+1);
      break;
    case 1839:
      gtsamBetweenFactorRot3_measured_1839(nargout, out, nargin-1, in+1);
      break;
    case 1840:
      gtsamBetweenFactorRot3_noiseModel_1840(nargout, out, nargin-1, in+1);
      break;
    case 1841:
      gtsamBetweenFactorRot3_print_1841(nargout, out, nargin-1, in+1);
      break;
    case 1842:
      gtsamBetweenFactorRot3_printKeys_1842(nargout, out, nargin-1, in+1);
      break;
    case 1843:
      gtsamBetweenFactorRot3_size_1843(nargout, out, nargin-1, in+1);
      break;
    case 1844:
      gtsamBetweenFactorRot3_unwhitenedError_1844(nargout, out, nargin-1, in+1);
      break;
    case 1845:
      gtsamBetweenFactorRot3_whitenedError_1845(nargout, out, nargin-1, in+1);
      break;
    case 1846:
      gtsamBetweenFactorRot3_string_serialize_1846(nargout, out, nargin-1, in+1);
      break;
    case 1847:
      gtsamBetweenFactorRot3_string_deserialize_1847(nargout, out, nargin-1, in+1);
      break;
    case 1848:
      gtsamBetweenFactorPose2_collectorInsertAndMakeBase_1848(nargout, out, nargin-1, in+1);
      break;
    case 1849:
      gtsamBetweenFactorPose2_upcastFromVoid_1849(nargout, out, nargin-1, in+1);
      break;
    case 1850:
      gtsamBetweenFactorPose2_constructor_1850(nargout, out, nargin-1, in+1);
      break;
    case 1851:
      gtsamBetweenFactorPose2_deconstructor_1851(nargout, out, nargin-1, in+1);
      break;
    case 1852:
      gtsamBetweenFactorPose2_active_1852(nargout, out, nargin-1, in+1);
      break;
    case 1853:
      gtsamBetweenFactorPose2_clone_1853(nargout, out, nargin-1, in+1);
      break;
    case 1854:
      gtsamBetweenFactorPose2_dim_1854(nargout, out, nargin-1, in+1);
      break;
    case 1855:
      gtsamBetweenFactorPose2_equals_1855(nargout, out, nargin-1, in+1);
      break;
    case 1856:
      gtsamBetweenFactorPose2_error_1856(nargout, out, nargin-1, in+1);
      break;
    case 1857:
      gtsamBetweenFactorPose2_get_noiseModel_1857(nargout, out, nargin-1, in+1);
      break;
    case 1858:
      gtsamBetweenFactorPose2_keys_1858(nargout, out, nargin-1, in+1);
      break;
    case 1859:
      gtsamBetweenFactorPose2_linearize_1859(nargout, out, nargin-1, in+1);
      break;
    case 1860:
      gtsamBetweenFactorPose2_measured_1860(nargout, out, nargin-1, in+1);
      break;
    case 1861:
      gtsamBetweenFactorPose2_noiseModel_1861(nargout, out, nargin-1, in+1);
      break;
    case 1862:
      gtsamBetweenFactorPose2_print_1862(nargout, out, nargin-1, in+1);
      break;
    case 1863:
      gtsamBetweenFactorPose2_printKeys_1863(nargout, out, nargin-1, in+1);
      break;
    case 1864:
      gtsamBetweenFactorPose2_size_1864(nargout, out, nargin-1, in+1);
      break;
    case 1865:
      gtsamBetweenFactorPose2_unwhitenedError_1865(nargout, out, nargin-1, in+1);
      break;
    case 1866:
      gtsamBetweenFactorPose2_whitenedError_1866(nargout, out, nargin-1, in+1);
      break;
    case 1867:
      gtsamBetweenFactorPose2_string_serialize_1867(nargout, out, nargin-1, in+1);
      break;
    case 1868:
      gtsamBetweenFactorPose2_string_deserialize_1868(nargout, out, nargin-1, in+1);
      break;
    case 1869:
      gtsamBetweenFactorPose3_collectorInsertAndMakeBase_1869(nargout, out, nargin-1, in+1);
      break;
    case 1870:
      gtsamBetweenFactorPose3_upcastFromVoid_1870(nargout, out, nargin-1, in+1);
      break;
    case 1871:
      gtsamBetweenFactorPose3_constructor_1871(nargout, out, nargin-1, in+1);
      break;
    case 1872:
      gtsamBetweenFactorPose3_deconstructor_1872(nargout, out, nargin-1, in+1);
      break;
    case 1873:
      gtsamBetweenFactorPose3_active_1873(nargout, out, nargin-1, in+1);
      break;
    case 1874:
      gtsamBetweenFactorPose3_clone_1874(nargout, out, nargin-1, in+1);
      break;
    case 1875:
      gtsamBetweenFactorPose3_dim_1875(nargout, out, nargin-1, in+1);
      break;
    case 1876:
      gtsamBetweenFactorPose3_equals_1876(nargout, out, nargin-1, in+1);
      break;
    case 1877:
      gtsamBetweenFactorPose3_error_1877(nargout, out, nargin-1, in+1);
      break;
    case 1878:
      gtsamBetweenFactorPose3_get_noiseModel_1878(nargout, out, nargin-1, in+1);
      break;
    case 1879:
      gtsamBetweenFactorPose3_keys_1879(nargout, out, nargin-1, in+1);
      break;
    case 1880:
      gtsamBetweenFactorPose3_linearize_1880(nargout, out, nargin-1, in+1);
      break;
    case 1881:
      gtsamBetweenFactorPose3_measured_1881(nargout, out, nargin-1, in+1);
      break;
    case 1882:
      gtsamBetweenFactorPose3_noiseModel_1882(nargout, out, nargin-1, in+1);
      break;
    case 1883:
      gtsamBetweenFactorPose3_print_1883(nargout, out, nargin-1, in+1);
      break;
    case 1884:
      gtsamBetweenFactorPose3_printKeys_1884(nargout, out, nargin-1, in+1);
      break;
    case 1885:
      gtsamBetweenFactorPose3_size_1885(nargout, out, nargin-1, in+1);
      break;
    case 1886:
      gtsamBetweenFactorPose3_unwhitenedError_1886(nargout, out, nargin-1, in+1);
      break;
    case 1887:
      gtsamBetweenFactorPose3_whitenedError_1887(nargout, out, nargin-1, in+1);
      break;
    case 1888:
      gtsamBetweenFactorPose3_string_serialize_1888(nargout, out, nargin-1, in+1);
      break;
    case 1889:
      gtsamBetweenFactorPose3_string_deserialize_1889(nargout, out, nargin-1, in+1);
      break;
    case 1890:
      gtsamBetweenFactorConstantBias_collectorInsertAndMakeBase_1890(nargout, out, nargin-1, in+1);
      break;
    case 1891:
      gtsamBetweenFactorConstantBias_upcastFromVoid_1891(nargout, out, nargin-1, in+1);
      break;
    case 1892:
      gtsamBetweenFactorConstantBias_constructor_1892(nargout, out, nargin-1, in+1);
      break;
    case 1893:
      gtsamBetweenFactorConstantBias_deconstructor_1893(nargout, out, nargin-1, in+1);
      break;
    case 1894:
      gtsamBetweenFactorConstantBias_active_1894(nargout, out, nargin-1, in+1);
      break;
    case 1895:
      gtsamBetweenFactorConstantBias_clone_1895(nargout, out, nargin-1, in+1);
      break;
    case 1896:
      gtsamBetweenFactorConstantBias_dim_1896(nargout, out, nargin-1, in+1);
      break;
    case 1897:
      gtsamBetweenFactorConstantBias_equals_1897(nargout, out, nargin-1, in+1);
      break;
    case 1898:
      gtsamBetweenFactorConstantBias_error_1898(nargout, out, nargin-1, in+1);
      break;
    case 1899:
      gtsamBetweenFactorConstantBias_get_noiseModel_1899(nargout, out, nargin-1, in+1);
      break;
    case 1900:
      gtsamBetweenFactorConstantBias_keys_1900(nargout, out, nargin-1, in+1);
      break;
    case 1901:
      gtsamBetweenFactorConstantBias_linearize_1901(nargout, out, nargin-1, in+1);
      break;
    case 1902:
      gtsamBetweenFactorConstantBias_measured_1902(nargout, out, nargin-1, in+1);
      break;
    case 1903:
      gtsamBetweenFactorConstantBias_noiseModel_1903(nargout, out, nargin-1, in+1);
      break;
    case 1904:
      gtsamBetweenFactorConstantBias_print_1904(nargout, out, nargin-1, in+1);
      break;
    case 1905:
      gtsamBetweenFactorConstantBias_printKeys_1905(nargout, out, nargin-1, in+1);
      break;
    case 1906:
      gtsamBetweenFactorConstantBias_size_1906(nargout, out, nargin-1, in+1);
      break;
    case 1907:
      gtsamBetweenFactorConstantBias_unwhitenedError_1907(nargout, out, nargin-1, in+1);
      break;
    case 1908:
      gtsamBetweenFactorConstantBias_whitenedError_1908(nargout, out, nargin-1, in+1);
      break;
    case 1909:
      gtsamBetweenFactorConstantBias_string_serialize_1909(nargout, out, nargin-1, in+1);
      break;
    case 1910:
      gtsamBetweenFactorConstantBias_string_deserialize_1910(nargout, out, nargin-1, in+1);
      break;
    case 1911:
      gtsamNonlinearEqualityPoint2_collectorInsertAndMakeBase_1911(nargout, out, nargin-1, in+1);
      break;
    case 1912:
      gtsamNonlinearEqualityPoint2_upcastFromVoid_1912(nargout, out, nargin-1, in+1);
      break;
    case 1913:
      gtsamNonlinearEqualityPoint2_constructor_1913(nargout, out, nargin-1, in+1);
      break;
    case 1914:
      gtsamNonlinearEqualityPoint2_constructor_1914(nargout, out, nargin-1, in+1);
      break;
    case 1915:
      gtsamNonlinearEqualityPoint2_deconstructor_1915(nargout, out, nargin-1, in+1);
      break;
    case 1916:
      gtsamNonlinearEqualityPoint2_active_1916(nargout, out, nargin-1, in+1);
      break;
    case 1917:
      gtsamNonlinearEqualityPoint2_clone_1917(nargout, out, nargin-1, in+1);
      break;
    case 1918:
      gtsamNonlinearEqualityPoint2_dim_1918(nargout, out, nargin-1, in+1);
      break;
    case 1919:
      gtsamNonlinearEqualityPoint2_equals_1919(nargout, out, nargin-1, in+1);
      break;
    case 1920:
      gtsamNonlinearEqualityPoint2_error_1920(nargout, out, nargin-1, in+1);
      break;
    case 1921:
      gtsamNonlinearEqualityPoint2_get_noiseModel_1921(nargout, out, nargin-1, in+1);
      break;
    case 1922:
      gtsamNonlinearEqualityPoint2_keys_1922(nargout, out, nargin-1, in+1);
      break;
    case 1923:
      gtsamNonlinearEqualityPoint2_linearize_1923(nargout, out, nargin-1, in+1);
      break;
    case 1924:
      gtsamNonlinearEqualityPoint2_noiseModel_1924(nargout, out, nargin-1, in+1);
      break;
    case 1925:
      gtsamNonlinearEqualityPoint2_print_1925(nargout, out, nargin-1, in+1);
      break;
    case 1926:
      gtsamNonlinearEqualityPoint2_printKeys_1926(nargout, out, nargin-1, in+1);
      break;
    case 1927:
      gtsamNonlinearEqualityPoint2_size_1927(nargout, out, nargin-1, in+1);
      break;
    case 1928:
      gtsamNonlinearEqualityPoint2_unwhitenedError_1928(nargout, out, nargin-1, in+1);
      break;
    case 1929:
      gtsamNonlinearEqualityPoint2_whitenedError_1929(nargout, out, nargin-1, in+1);
      break;
    case 1930:
      gtsamNonlinearEqualityPoint2_string_serialize_1930(nargout, out, nargin-1, in+1);
      break;
    case 1931:
      gtsamNonlinearEqualityPoint2_string_deserialize_1931(nargout, out, nargin-1, in+1);
      break;
    case 1932:
      gtsamNonlinearEqualityStereoPoint2_collectorInsertAndMakeBase_1932(nargout, out, nargin-1, in+1);
      break;
    case 1933:
      gtsamNonlinearEqualityStereoPoint2_upcastFromVoid_1933(nargout, out, nargin-1, in+1);
      break;
    case 1934:
      gtsamNonlinearEqualityStereoPoint2_constructor_1934(nargout, out, nargin-1, in+1);
      break;
    case 1935:
      gtsamNonlinearEqualityStereoPoint2_constructor_1935(nargout, out, nargin-1, in+1);
      break;
    case 1936:
      gtsamNonlinearEqualityStereoPoint2_deconstructor_1936(nargout, out, nargin-1, in+1);
      break;
    case 1937:
      gtsamNonlinearEqualityStereoPoint2_active_1937(nargout, out, nargin-1, in+1);
      break;
    case 1938:
      gtsamNonlinearEqualityStereoPoint2_clone_1938(nargout, out, nargin-1, in+1);
      break;
    case 1939:
      gtsamNonlinearEqualityStereoPoint2_dim_1939(nargout, out, nargin-1, in+1);
      break;
    case 1940:
      gtsamNonlinearEqualityStereoPoint2_equals_1940(nargout, out, nargin-1, in+1);
      break;
    case 1941:
      gtsamNonlinearEqualityStereoPoint2_error_1941(nargout, out, nargin-1, in+1);
      break;
    case 1942:
      gtsamNonlinearEqualityStereoPoint2_get_noiseModel_1942(nargout, out, nargin-1, in+1);
      break;
    case 1943:
      gtsamNonlinearEqualityStereoPoint2_keys_1943(nargout, out, nargin-1, in+1);
      break;
    case 1944:
      gtsamNonlinearEqualityStereoPoint2_linearize_1944(nargout, out, nargin-1, in+1);
      break;
    case 1945:
      gtsamNonlinearEqualityStereoPoint2_noiseModel_1945(nargout, out, nargin-1, in+1);
      break;
    case 1946:
      gtsamNonlinearEqualityStereoPoint2_print_1946(nargout, out, nargin-1, in+1);
      break;
    case 1947:
      gtsamNonlinearEqualityStereoPoint2_printKeys_1947(nargout, out, nargin-1, in+1);
      break;
    case 1948:
      gtsamNonlinearEqualityStereoPoint2_size_1948(nargout, out, nargin-1, in+1);
      break;
    case 1949:
      gtsamNonlinearEqualityStereoPoint2_unwhitenedError_1949(nargout, out, nargin-1, in+1);
      break;
    case 1950:
      gtsamNonlinearEqualityStereoPoint2_whitenedError_1950(nargout, out, nargin-1, in+1);
      break;
    case 1951:
      gtsamNonlinearEqualityStereoPoint2_string_serialize_1951(nargout, out, nargin-1, in+1);
      break;
    case 1952:
      gtsamNonlinearEqualityStereoPoint2_string_deserialize_1952(nargout, out, nargin-1, in+1);
      break;
    case 1953:
      gtsamNonlinearEqualityPoint3_collectorInsertAndMakeBase_1953(nargout, out, nargin-1, in+1);
      break;
    case 1954:
      gtsamNonlinearEqualityPoint3_upcastFromVoid_1954(nargout, out, nargin-1, in+1);
      break;
    case 1955:
      gtsamNonlinearEqualityPoint3_constructor_1955(nargout, out, nargin-1, in+1);
      break;
    case 1956:
      gtsamNonlinearEqualityPoint3_constructor_1956(nargout, out, nargin-1, in+1);
      break;
    case 1957:
      gtsamNonlinearEqualityPoint3_deconstructor_1957(nargout, out, nargin-1, in+1);
      break;
    case 1958:
      gtsamNonlinearEqualityPoint3_active_1958(nargout, out, nargin-1, in+1);
      break;
    case 1959:
      gtsamNonlinearEqualityPoint3_clone_1959(nargout, out, nargin-1, in+1);
      break;
    case 1960:
      gtsamNonlinearEqualityPoint3_dim_1960(nargout, out, nargin-1, in+1);
      break;
    case 1961:
      gtsamNonlinearEqualityPoint3_equals_1961(nargout, out, nargin-1, in+1);
      break;
    case 1962:
      gtsamNonlinearEqualityPoint3_error_1962(nargout, out, nargin-1, in+1);
      break;
    case 1963:
      gtsamNonlinearEqualityPoint3_get_noiseModel_1963(nargout, out, nargin-1, in+1);
      break;
    case 1964:
      gtsamNonlinearEqualityPoint3_keys_1964(nargout, out, nargin-1, in+1);
      break;
    case 1965:
      gtsamNonlinearEqualityPoint3_linearize_1965(nargout, out, nargin-1, in+1);
      break;
    case 1966:
      gtsamNonlinearEqualityPoint3_noiseModel_1966(nargout, out, nargin-1, in+1);
      break;
    case 1967:
      gtsamNonlinearEqualityPoint3_print_1967(nargout, out, nargin-1, in+1);
      break;
    case 1968:
      gtsamNonlinearEqualityPoint3_printKeys_1968(nargout, out, nargin-1, in+1);
      break;
    case 1969:
      gtsamNonlinearEqualityPoint3_size_1969(nargout, out, nargin-1, in+1);
      break;
    case 1970:
      gtsamNonlinearEqualityPoint3_unwhitenedError_1970(nargout, out, nargin-1, in+1);
      break;
    case 1971:
      gtsamNonlinearEqualityPoint3_whitenedError_1971(nargout, out, nargin-1, in+1);
      break;
    case 1972:
      gtsamNonlinearEqualityPoint3_string_serialize_1972(nargout, out, nargin-1, in+1);
      break;
    case 1973:
      gtsamNonlinearEqualityPoint3_string_deserialize_1973(nargout, out, nargin-1, in+1);
      break;
    case 1974:
      gtsamNonlinearEqualityRot2_collectorInsertAndMakeBase_1974(nargout, out, nargin-1, in+1);
      break;
    case 1975:
      gtsamNonlinearEqualityRot2_upcastFromVoid_1975(nargout, out, nargin-1, in+1);
      break;
    case 1976:
      gtsamNonlinearEqualityRot2_constructor_1976(nargout, out, nargin-1, in+1);
      break;
    case 1977:
      gtsamNonlinearEqualityRot2_constructor_1977(nargout, out, nargin-1, in+1);
      break;
    case 1978:
      gtsamNonlinearEqualityRot2_deconstructor_1978(nargout, out, nargin-1, in+1);
      break;
    case 1979:
      gtsamNonlinearEqualityRot2_active_1979(nargout, out, nargin-1, in+1);
      break;
    case 1980:
      gtsamNonlinearEqualityRot2_clone_1980(nargout, out, nargin-1, in+1);
      break;
    case 1981:
      gtsamNonlinearEqualityRot2_dim_1981(nargout, out, nargin-1, in+1);
      break;
    case 1982:
      gtsamNonlinearEqualityRot2_equals_1982(nargout, out, nargin-1, in+1);
      break;
    case 1983:
      gtsamNonlinearEqualityRot2_error_1983(nargout, out, nargin-1, in+1);
      break;
    case 1984:
      gtsamNonlinearEqualityRot2_get_noiseModel_1984(nargout, out, nargin-1, in+1);
      break;
    case 1985:
      gtsamNonlinearEqualityRot2_keys_1985(nargout, out, nargin-1, in+1);
      break;
    case 1986:
      gtsamNonlinearEqualityRot2_linearize_1986(nargout, out, nargin-1, in+1);
      break;
    case 1987:
      gtsamNonlinearEqualityRot2_noiseModel_1987(nargout, out, nargin-1, in+1);
      break;
    case 1988:
      gtsamNonlinearEqualityRot2_print_1988(nargout, out, nargin-1, in+1);
      break;
    case 1989:
      gtsamNonlinearEqualityRot2_printKeys_1989(nargout, out, nargin-1, in+1);
      break;
    case 1990:
      gtsamNonlinearEqualityRot2_size_1990(nargout, out, nargin-1, in+1);
      break;
    case 1991:
      gtsamNonlinearEqualityRot2_unwhitenedError_1991(nargout, out, nargin-1, in+1);
      break;
    case 1992:
      gtsamNonlinearEqualityRot2_whitenedError_1992(nargout, out, nargin-1, in+1);
      break;
    case 1993:
      gtsamNonlinearEqualityRot2_string_serialize_1993(nargout, out, nargin-1, in+1);
      break;
    case 1994:
      gtsamNonlinearEqualityRot2_string_deserialize_1994(nargout, out, nargin-1, in+1);
      break;
    case 1995:
      gtsamNonlinearEqualityRot3_collectorInsertAndMakeBase_1995(nargout, out, nargin-1, in+1);
      break;
    case 1996:
      gtsamNonlinearEqualityRot3_upcastFromVoid_1996(nargout, out, nargin-1, in+1);
      break;
    case 1997:
      gtsamNonlinearEqualityRot3_constructor_1997(nargout, out, nargin-1, in+1);
      break;
    case 1998:
      gtsamNonlinearEqualityRot3_constructor_1998(nargout, out, nargin-1, in+1);
      break;
    case 1999:
      gtsamNonlinearEqualityRot3_deconstructor_1999(nargout, out, nargin-1, in+1);
      break;
    case 2000:
      gtsamNonlinearEqualityRot3_active_2000(nargout, out, nargin-1, in+1);
      break;
    case 2001:
      gtsamNonlinearEqualityRot3_clone_2001(nargout, out, nargin-1, in+1);
      break;
    case 2002:
      gtsamNonlinearEqualityRot3_dim_2002(nargout, out, nargin-1, in+1);
      break;
    case 2003:
      gtsamNonlinearEqualityRot3_equals_2003(nargout, out, nargin-1, in+1);
      break;
    case 2004:
      gtsamNonlinearEqualityRot3_error_2004(nargout, out, nargin-1, in+1);
      break;
    case 2005:
      gtsamNonlinearEqualityRot3_get_noiseModel_2005(nargout, out, nargin-1, in+1);
      break;
    case 2006:
      gtsamNonlinearEqualityRot3_keys_2006(nargout, out, nargin-1, in+1);
      break;
    case 2007:
      gtsamNonlinearEqualityRot3_linearize_2007(nargout, out, nargin-1, in+1);
      break;
    case 2008:
      gtsamNonlinearEqualityRot3_noiseModel_2008(nargout, out, nargin-1, in+1);
      break;
    case 2009:
      gtsamNonlinearEqualityRot3_print_2009(nargout, out, nargin-1, in+1);
      break;
    case 2010:
      gtsamNonlinearEqualityRot3_printKeys_2010(nargout, out, nargin-1, in+1);
      break;
    case 2011:
      gtsamNonlinearEqualityRot3_size_2011(nargout, out, nargin-1, in+1);
      break;
    case 2012:
      gtsamNonlinearEqualityRot3_unwhitenedError_2012(nargout, out, nargin-1, in+1);
      break;
    case 2013:
      gtsamNonlinearEqualityRot3_whitenedError_2013(nargout, out, nargin-1, in+1);
      break;
    case 2014:
      gtsamNonlinearEqualityRot3_string_serialize_2014(nargout, out, nargin-1, in+1);
      break;
    case 2015:
      gtsamNonlinearEqualityRot3_string_deserialize_2015(nargout, out, nargin-1, in+1);
      break;
    case 2016:
      gtsamNonlinearEqualityPose2_collectorInsertAndMakeBase_2016(nargout, out, nargin-1, in+1);
      break;
    case 2017:
      gtsamNonlinearEqualityPose2_upcastFromVoid_2017(nargout, out, nargin-1, in+1);
      break;
    case 2018:
      gtsamNonlinearEqualityPose2_constructor_2018(nargout, out, nargin-1, in+1);
      break;
    case 2019:
      gtsamNonlinearEqualityPose2_constructor_2019(nargout, out, nargin-1, in+1);
      break;
    case 2020:
      gtsamNonlinearEqualityPose2_deconstructor_2020(nargout, out, nargin-1, in+1);
      break;
    case 2021:
      gtsamNonlinearEqualityPose2_active_2021(nargout, out, nargin-1, in+1);
      break;
    case 2022:
      gtsamNonlinearEqualityPose2_clone_2022(nargout, out, nargin-1, in+1);
      break;
    case 2023:
      gtsamNonlinearEqualityPose2_dim_2023(nargout, out, nargin-1, in+1);
      break;
    case 2024:
      gtsamNonlinearEqualityPose2_equals_2024(nargout, out, nargin-1, in+1);
      break;
    case 2025:
      gtsamNonlinearEqualityPose2_error_2025(nargout, out, nargin-1, in+1);
      break;
    case 2026:
      gtsamNonlinearEqualityPose2_get_noiseModel_2026(nargout, out, nargin-1, in+1);
      break;
    case 2027:
      gtsamNonlinearEqualityPose2_keys_2027(nargout, out, nargin-1, in+1);
      break;
    case 2028:
      gtsamNonlinearEqualityPose2_linearize_2028(nargout, out, nargin-1, in+1);
      break;
    case 2029:
      gtsamNonlinearEqualityPose2_noiseModel_2029(nargout, out, nargin-1, in+1);
      break;
    case 2030:
      gtsamNonlinearEqualityPose2_print_2030(nargout, out, nargin-1, in+1);
      break;
    case 2031:
      gtsamNonlinearEqualityPose2_printKeys_2031(nargout, out, nargin-1, in+1);
      break;
    case 2032:
      gtsamNonlinearEqualityPose2_size_2032(nargout, out, nargin-1, in+1);
      break;
    case 2033:
      gtsamNonlinearEqualityPose2_unwhitenedError_2033(nargout, out, nargin-1, in+1);
      break;
    case 2034:
      gtsamNonlinearEqualityPose2_whitenedError_2034(nargout, out, nargin-1, in+1);
      break;
    case 2035:
      gtsamNonlinearEqualityPose2_string_serialize_2035(nargout, out, nargin-1, in+1);
      break;
    case 2036:
      gtsamNonlinearEqualityPose2_string_deserialize_2036(nargout, out, nargin-1, in+1);
      break;
    case 2037:
      gtsamNonlinearEqualityPose3_collectorInsertAndMakeBase_2037(nargout, out, nargin-1, in+1);
      break;
    case 2038:
      gtsamNonlinearEqualityPose3_upcastFromVoid_2038(nargout, out, nargin-1, in+1);
      break;
    case 2039:
      gtsamNonlinearEqualityPose3_constructor_2039(nargout, out, nargin-1, in+1);
      break;
    case 2040:
      gtsamNonlinearEqualityPose3_constructor_2040(nargout, out, nargin-1, in+1);
      break;
    case 2041:
      gtsamNonlinearEqualityPose3_deconstructor_2041(nargout, out, nargin-1, in+1);
      break;
    case 2042:
      gtsamNonlinearEqualityPose3_active_2042(nargout, out, nargin-1, in+1);
      break;
    case 2043:
      gtsamNonlinearEqualityPose3_clone_2043(nargout, out, nargin-1, in+1);
      break;
    case 2044:
      gtsamNonlinearEqualityPose3_dim_2044(nargout, out, nargin-1, in+1);
      break;
    case 2045:
      gtsamNonlinearEqualityPose3_equals_2045(nargout, out, nargin-1, in+1);
      break;
    case 2046:
      gtsamNonlinearEqualityPose3_error_2046(nargout, out, nargin-1, in+1);
      break;
    case 2047:
      gtsamNonlinearEqualityPose3_get_noiseModel_2047(nargout, out, nargin-1, in+1);
      break;
    case 2048:
      gtsamNonlinearEqualityPose3_keys_2048(nargout, out, nargin-1, in+1);
      break;
    case 2049:
      gtsamNonlinearEqualityPose3_linearize_2049(nargout, out, nargin-1, in+1);
      break;
    case 2050:
      gtsamNonlinearEqualityPose3_noiseModel_2050(nargout, out, nargin-1, in+1);
      break;
    case 2051:
      gtsamNonlinearEqualityPose3_print_2051(nargout, out, nargin-1, in+1);
      break;
    case 2052:
      gtsamNonlinearEqualityPose3_printKeys_2052(nargout, out, nargin-1, in+1);
      break;
    case 2053:
      gtsamNonlinearEqualityPose3_size_2053(nargout, out, nargin-1, in+1);
      break;
    case 2054:
      gtsamNonlinearEqualityPose3_unwhitenedError_2054(nargout, out, nargin-1, in+1);
      break;
    case 2055:
      gtsamNonlinearEqualityPose3_whitenedError_2055(nargout, out, nargin-1, in+1);
      break;
    case 2056:
      gtsamNonlinearEqualityPose3_string_serialize_2056(nargout, out, nargin-1, in+1);
      break;
    case 2057:
      gtsamNonlinearEqualityPose3_string_deserialize_2057(nargout, out, nargin-1, in+1);
      break;
    case 2058:
      gtsamNonlinearEqualityCal3_S2_collectorInsertAndMakeBase_2058(nargout, out, nargin-1, in+1);
      break;
    case 2059:
      gtsamNonlinearEqualityCal3_S2_upcastFromVoid_2059(nargout, out, nargin-1, in+1);
      break;
    case 2060:
      gtsamNonlinearEqualityCal3_S2_constructor_2060(nargout, out, nargin-1, in+1);
      break;
    case 2061:
      gtsamNonlinearEqualityCal3_S2_constructor_2061(nargout, out, nargin-1, in+1);
      break;
    case 2062:
      gtsamNonlinearEqualityCal3_S2_deconstructor_2062(nargout, out, nargin-1, in+1);
      break;
    case 2063:
      gtsamNonlinearEqualityCal3_S2_active_2063(nargout, out, nargin-1, in+1);
      break;
    case 2064:
      gtsamNonlinearEqualityCal3_S2_clone_2064(nargout, out, nargin-1, in+1);
      break;
    case 2065:
      gtsamNonlinearEqualityCal3_S2_dim_2065(nargout, out, nargin-1, in+1);
      break;
    case 2066:
      gtsamNonlinearEqualityCal3_S2_equals_2066(nargout, out, nargin-1, in+1);
      break;
    case 2067:
      gtsamNonlinearEqualityCal3_S2_error_2067(nargout, out, nargin-1, in+1);
      break;
    case 2068:
      gtsamNonlinearEqualityCal3_S2_get_noiseModel_2068(nargout, out, nargin-1, in+1);
      break;
    case 2069:
      gtsamNonlinearEqualityCal3_S2_keys_2069(nargout, out, nargin-1, in+1);
      break;
    case 2070:
      gtsamNonlinearEqualityCal3_S2_linearize_2070(nargout, out, nargin-1, in+1);
      break;
    case 2071:
      gtsamNonlinearEqualityCal3_S2_noiseModel_2071(nargout, out, nargin-1, in+1);
      break;
    case 2072:
      gtsamNonlinearEqualityCal3_S2_print_2072(nargout, out, nargin-1, in+1);
      break;
    case 2073:
      gtsamNonlinearEqualityCal3_S2_printKeys_2073(nargout, out, nargin-1, in+1);
      break;
    case 2074:
      gtsamNonlinearEqualityCal3_S2_size_2074(nargout, out, nargin-1, in+1);
      break;
    case 2075:
      gtsamNonlinearEqualityCal3_S2_unwhitenedError_2075(nargout, out, nargin-1, in+1);
      break;
    case 2076:
      gtsamNonlinearEqualityCal3_S2_whitenedError_2076(nargout, out, nargin-1, in+1);
      break;
    case 2077:
      gtsamNonlinearEqualityCal3_S2_string_serialize_2077(nargout, out, nargin-1, in+1);
      break;
    case 2078:
      gtsamNonlinearEqualityCal3_S2_string_deserialize_2078(nargout, out, nargin-1, in+1);
      break;
    case 2079:
      gtsamNonlinearEqualityCalibratedCamera_collectorInsertAndMakeBase_2079(nargout, out, nargin-1, in+1);
      break;
    case 2080:
      gtsamNonlinearEqualityCalibratedCamera_upcastFromVoid_2080(nargout, out, nargin-1, in+1);
      break;
    case 2081:
      gtsamNonlinearEqualityCalibratedCamera_constructor_2081(nargout, out, nargin-1, in+1);
      break;
    case 2082:
      gtsamNonlinearEqualityCalibratedCamera_constructor_2082(nargout, out, nargin-1, in+1);
      break;
    case 2083:
      gtsamNonlinearEqualityCalibratedCamera_deconstructor_2083(nargout, out, nargin-1, in+1);
      break;
    case 2084:
      gtsamNonlinearEqualityCalibratedCamera_active_2084(nargout, out, nargin-1, in+1);
      break;
    case 2085:
      gtsamNonlinearEqualityCalibratedCamera_clone_2085(nargout, out, nargin-1, in+1);
      break;
    case 2086:
      gtsamNonlinearEqualityCalibratedCamera_dim_2086(nargout, out, nargin-1, in+1);
      break;
    case 2087:
      gtsamNonlinearEqualityCalibratedCamera_equals_2087(nargout, out, nargin-1, in+1);
      break;
    case 2088:
      gtsamNonlinearEqualityCalibratedCamera_error_2088(nargout, out, nargin-1, in+1);
      break;
    case 2089:
      gtsamNonlinearEqualityCalibratedCamera_get_noiseModel_2089(nargout, out, nargin-1, in+1);
      break;
    case 2090:
      gtsamNonlinearEqualityCalibratedCamera_keys_2090(nargout, out, nargin-1, in+1);
      break;
    case 2091:
      gtsamNonlinearEqualityCalibratedCamera_linearize_2091(nargout, out, nargin-1, in+1);
      break;
    case 2092:
      gtsamNonlinearEqualityCalibratedCamera_noiseModel_2092(nargout, out, nargin-1, in+1);
      break;
    case 2093:
      gtsamNonlinearEqualityCalibratedCamera_print_2093(nargout, out, nargin-1, in+1);
      break;
    case 2094:
      gtsamNonlinearEqualityCalibratedCamera_printKeys_2094(nargout, out, nargin-1, in+1);
      break;
    case 2095:
      gtsamNonlinearEqualityCalibratedCamera_size_2095(nargout, out, nargin-1, in+1);
      break;
    case 2096:
      gtsamNonlinearEqualityCalibratedCamera_unwhitenedError_2096(nargout, out, nargin-1, in+1);
      break;
    case 2097:
      gtsamNonlinearEqualityCalibratedCamera_whitenedError_2097(nargout, out, nargin-1, in+1);
      break;
    case 2098:
      gtsamNonlinearEqualityCalibratedCamera_string_serialize_2098(nargout, out, nargin-1, in+1);
      break;
    case 2099:
      gtsamNonlinearEqualityCalibratedCamera_string_deserialize_2099(nargout, out, nargin-1, in+1);
      break;
    case 2100:
      gtsamNonlinearEqualitySimpleCamera_collectorInsertAndMakeBase_2100(nargout, out, nargin-1, in+1);
      break;
    case 2101:
      gtsamNonlinearEqualitySimpleCamera_upcastFromVoid_2101(nargout, out, nargin-1, in+1);
      break;
    case 2102:
      gtsamNonlinearEqualitySimpleCamera_constructor_2102(nargout, out, nargin-1, in+1);
      break;
    case 2103:
      gtsamNonlinearEqualitySimpleCamera_constructor_2103(nargout, out, nargin-1, in+1);
      break;
    case 2104:
      gtsamNonlinearEqualitySimpleCamera_deconstructor_2104(nargout, out, nargin-1, in+1);
      break;
    case 2105:
      gtsamNonlinearEqualitySimpleCamera_active_2105(nargout, out, nargin-1, in+1);
      break;
    case 2106:
      gtsamNonlinearEqualitySimpleCamera_clone_2106(nargout, out, nargin-1, in+1);
      break;
    case 2107:
      gtsamNonlinearEqualitySimpleCamera_dim_2107(nargout, out, nargin-1, in+1);
      break;
    case 2108:
      gtsamNonlinearEqualitySimpleCamera_equals_2108(nargout, out, nargin-1, in+1);
      break;
    case 2109:
      gtsamNonlinearEqualitySimpleCamera_error_2109(nargout, out, nargin-1, in+1);
      break;
    case 2110:
      gtsamNonlinearEqualitySimpleCamera_get_noiseModel_2110(nargout, out, nargin-1, in+1);
      break;
    case 2111:
      gtsamNonlinearEqualitySimpleCamera_keys_2111(nargout, out, nargin-1, in+1);
      break;
    case 2112:
      gtsamNonlinearEqualitySimpleCamera_linearize_2112(nargout, out, nargin-1, in+1);
      break;
    case 2113:
      gtsamNonlinearEqualitySimpleCamera_noiseModel_2113(nargout, out, nargin-1, in+1);
      break;
    case 2114:
      gtsamNonlinearEqualitySimpleCamera_print_2114(nargout, out, nargin-1, in+1);
      break;
    case 2115:
      gtsamNonlinearEqualitySimpleCamera_printKeys_2115(nargout, out, nargin-1, in+1);
      break;
    case 2116:
      gtsamNonlinearEqualitySimpleCamera_size_2116(nargout, out, nargin-1, in+1);
      break;
    case 2117:
      gtsamNonlinearEqualitySimpleCamera_unwhitenedError_2117(nargout, out, nargin-1, in+1);
      break;
    case 2118:
      gtsamNonlinearEqualitySimpleCamera_whitenedError_2118(nargout, out, nargin-1, in+1);
      break;
    case 2119:
      gtsamNonlinearEqualitySimpleCamera_string_serialize_2119(nargout, out, nargin-1, in+1);
      break;
    case 2120:
      gtsamNonlinearEqualitySimpleCamera_string_deserialize_2120(nargout, out, nargin-1, in+1);
      break;
    case 2121:
      gtsamNonlinearEqualityConstantBias_collectorInsertAndMakeBase_2121(nargout, out, nargin-1, in+1);
      break;
    case 2122:
      gtsamNonlinearEqualityConstantBias_upcastFromVoid_2122(nargout, out, nargin-1, in+1);
      break;
    case 2123:
      gtsamNonlinearEqualityConstantBias_constructor_2123(nargout, out, nargin-1, in+1);
      break;
    case 2124:
      gtsamNonlinearEqualityConstantBias_constructor_2124(nargout, out, nargin-1, in+1);
      break;
    case 2125:
      gtsamNonlinearEqualityConstantBias_deconstructor_2125(nargout, out, nargin-1, in+1);
      break;
    case 2126:
      gtsamNonlinearEqualityConstantBias_active_2126(nargout, out, nargin-1, in+1);
      break;
    case 2127:
      gtsamNonlinearEqualityConstantBias_clone_2127(nargout, out, nargin-1, in+1);
      break;
    case 2128:
      gtsamNonlinearEqualityConstantBias_dim_2128(nargout, out, nargin-1, in+1);
      break;
    case 2129:
      gtsamNonlinearEqualityConstantBias_equals_2129(nargout, out, nargin-1, in+1);
      break;
    case 2130:
      gtsamNonlinearEqualityConstantBias_error_2130(nargout, out, nargin-1, in+1);
      break;
    case 2131:
      gtsamNonlinearEqualityConstantBias_get_noiseModel_2131(nargout, out, nargin-1, in+1);
      break;
    case 2132:
      gtsamNonlinearEqualityConstantBias_keys_2132(nargout, out, nargin-1, in+1);
      break;
    case 2133:
      gtsamNonlinearEqualityConstantBias_linearize_2133(nargout, out, nargin-1, in+1);
      break;
    case 2134:
      gtsamNonlinearEqualityConstantBias_noiseModel_2134(nargout, out, nargin-1, in+1);
      break;
    case 2135:
      gtsamNonlinearEqualityConstantBias_print_2135(nargout, out, nargin-1, in+1);
      break;
    case 2136:
      gtsamNonlinearEqualityConstantBias_printKeys_2136(nargout, out, nargin-1, in+1);
      break;
    case 2137:
      gtsamNonlinearEqualityConstantBias_size_2137(nargout, out, nargin-1, in+1);
      break;
    case 2138:
      gtsamNonlinearEqualityConstantBias_unwhitenedError_2138(nargout, out, nargin-1, in+1);
      break;
    case 2139:
      gtsamNonlinearEqualityConstantBias_whitenedError_2139(nargout, out, nargin-1, in+1);
      break;
    case 2140:
      gtsamNonlinearEqualityConstantBias_string_serialize_2140(nargout, out, nargin-1, in+1);
      break;
    case 2141:
      gtsamNonlinearEqualityConstantBias_string_deserialize_2141(nargout, out, nargin-1, in+1);
      break;
    case 2142:
      gtsamGeneralSFMFactor2Cal3_S2_collectorInsertAndMakeBase_2142(nargout, out, nargin-1, in+1);
      break;
    case 2143:
      gtsamGeneralSFMFactor2Cal3_S2_upcastFromVoid_2143(nargout, out, nargin-1, in+1);
      break;
    case 2144:
      gtsamGeneralSFMFactor2Cal3_S2_constructor_2144(nargout, out, nargin-1, in+1);
      break;
    case 2145:
      gtsamGeneralSFMFactor2Cal3_S2_deconstructor_2145(nargout, out, nargin-1, in+1);
      break;
    case 2146:
      gtsamGeneralSFMFactor2Cal3_S2_active_2146(nargout, out, nargin-1, in+1);
      break;
    case 2147:
      gtsamGeneralSFMFactor2Cal3_S2_clone_2147(nargout, out, nargin-1, in+1);
      break;
    case 2148:
      gtsamGeneralSFMFactor2Cal3_S2_dim_2148(nargout, out, nargin-1, in+1);
      break;
    case 2149:
      gtsamGeneralSFMFactor2Cal3_S2_equals_2149(nargout, out, nargin-1, in+1);
      break;
    case 2150:
      gtsamGeneralSFMFactor2Cal3_S2_error_2150(nargout, out, nargin-1, in+1);
      break;
    case 2151:
      gtsamGeneralSFMFactor2Cal3_S2_get_noiseModel_2151(nargout, out, nargin-1, in+1);
      break;
    case 2152:
      gtsamGeneralSFMFactor2Cal3_S2_keys_2152(nargout, out, nargin-1, in+1);
      break;
    case 2153:
      gtsamGeneralSFMFactor2Cal3_S2_linearize_2153(nargout, out, nargin-1, in+1);
      break;
    case 2154:
      gtsamGeneralSFMFactor2Cal3_S2_measured_2154(nargout, out, nargin-1, in+1);
      break;
    case 2155:
      gtsamGeneralSFMFactor2Cal3_S2_noiseModel_2155(nargout, out, nargin-1, in+1);
      break;
    case 2156:
      gtsamGeneralSFMFactor2Cal3_S2_print_2156(nargout, out, nargin-1, in+1);
      break;
    case 2157:
      gtsamGeneralSFMFactor2Cal3_S2_printKeys_2157(nargout, out, nargin-1, in+1);
      break;
    case 2158:
      gtsamGeneralSFMFactor2Cal3_S2_size_2158(nargout, out, nargin-1, in+1);
      break;
    case 2159:
      gtsamGeneralSFMFactor2Cal3_S2_unwhitenedError_2159(nargout, out, nargin-1, in+1);
      break;
    case 2160:
      gtsamGeneralSFMFactor2Cal3_S2_whitenedError_2160(nargout, out, nargin-1, in+1);
      break;
    case 2161:
      gtsamGeneralSFMFactor2Cal3_S2_string_serialize_2161(nargout, out, nargin-1, in+1);
      break;
    case 2162:
      gtsamGeneralSFMFactor2Cal3_S2_string_deserialize_2162(nargout, out, nargin-1, in+1);
      break;
    case 2163:
      gtsamSmartProjectionParams_collectorInsertAndMakeBase_2163(nargout, out, nargin-1, in+1);
      break;
    case 2164:
      gtsamSmartProjectionParams_constructor_2164(nargout, out, nargin-1, in+1);
      break;
    case 2165:
      gtsamSmartProjectionParams_deconstructor_2165(nargout, out, nargin-1, in+1);
      break;
    case 2166:
      gtsamSmartProjectionParams_setDynamicOutlierRejectionThreshold_2166(nargout, out, nargin-1, in+1);
      break;
    case 2167:
      gtsamSmartProjectionParams_setEnableEPI_2167(nargout, out, nargin-1, in+1);
      break;
    case 2168:
      gtsamSmartProjectionParams_setLandmarkDistanceThreshold_2168(nargout, out, nargin-1, in+1);
      break;
    case 2169:
      gtsamSmartProjectionParams_setRankTolerance_2169(nargout, out, nargin-1, in+1);
      break;
    case 2170:
      gtsamEssentialMatrixFactor_collectorInsertAndMakeBase_2170(nargout, out, nargin-1, in+1);
      break;
    case 2171:
      gtsamEssentialMatrixFactor_upcastFromVoid_2171(nargout, out, nargin-1, in+1);
      break;
    case 2172:
      gtsamEssentialMatrixFactor_constructor_2172(nargout, out, nargin-1, in+1);
      break;
    case 2173:
      gtsamEssentialMatrixFactor_deconstructor_2173(nargout, out, nargin-1, in+1);
      break;
    case 2174:
      gtsamEssentialMatrixFactor_active_2174(nargout, out, nargin-1, in+1);
      break;
    case 2175:
      gtsamEssentialMatrixFactor_clone_2175(nargout, out, nargin-1, in+1);
      break;
    case 2176:
      gtsamEssentialMatrixFactor_dim_2176(nargout, out, nargin-1, in+1);
      break;
    case 2177:
      gtsamEssentialMatrixFactor_equals_2177(nargout, out, nargin-1, in+1);
      break;
    case 2178:
      gtsamEssentialMatrixFactor_error_2178(nargout, out, nargin-1, in+1);
      break;
    case 2179:
      gtsamEssentialMatrixFactor_get_noiseModel_2179(nargout, out, nargin-1, in+1);
      break;
    case 2180:
      gtsamEssentialMatrixFactor_keys_2180(nargout, out, nargin-1, in+1);
      break;
    case 2181:
      gtsamEssentialMatrixFactor_linearize_2181(nargout, out, nargin-1, in+1);
      break;
    case 2182:
      gtsamEssentialMatrixFactor_noiseModel_2182(nargout, out, nargin-1, in+1);
      break;
    case 2183:
      gtsamEssentialMatrixFactor_print_2183(nargout, out, nargin-1, in+1);
      break;
    case 2184:
      gtsamEssentialMatrixFactor_printKeys_2184(nargout, out, nargin-1, in+1);
      break;
    case 2185:
      gtsamEssentialMatrixFactor_size_2185(nargout, out, nargin-1, in+1);
      break;
    case 2186:
      gtsamEssentialMatrixFactor_unwhitenedError_2186(nargout, out, nargin-1, in+1);
      break;
    case 2187:
      gtsamEssentialMatrixFactor_whitenedError_2187(nargout, out, nargin-1, in+1);
      break;
    case 2188:
      gtsamimuBiasConstantBias_collectorInsertAndMakeBase_2188(nargout, out, nargin-1, in+1);
      break;
    case 2189:
      gtsamimuBiasConstantBias_constructor_2189(nargout, out, nargin-1, in+1);
      break;
    case 2190:
      gtsamimuBiasConstantBias_constructor_2190(nargout, out, nargin-1, in+1);
      break;
    case 2191:
      gtsamimuBiasConstantBias_deconstructor_2191(nargout, out, nargin-1, in+1);
      break;
    case 2192:
      gtsamimuBiasConstantBias_accelerometer_2192(nargout, out, nargin-1, in+1);
      break;
    case 2193:
      gtsamimuBiasConstantBias_between_2193(nargout, out, nargin-1, in+1);
      break;
    case 2194:
      gtsamimuBiasConstantBias_compose_2194(nargout, out, nargin-1, in+1);
      break;
    case 2195:
      gtsamimuBiasConstantBias_correctAccelerometer_2195(nargout, out, nargin-1, in+1);
      break;
    case 2196:
      gtsamimuBiasConstantBias_correctGyroscope_2196(nargout, out, nargin-1, in+1);
      break;
    case 2197:
      gtsamimuBiasConstantBias_equals_2197(nargout, out, nargin-1, in+1);
      break;
    case 2198:
      gtsamimuBiasConstantBias_gyroscope_2198(nargout, out, nargin-1, in+1);
      break;
    case 2199:
      gtsamimuBiasConstantBias_inverse_2199(nargout, out, nargin-1, in+1);
      break;
    case 2200:
      gtsamimuBiasConstantBias_localCoordinates_2200(nargout, out, nargin-1, in+1);
      break;
    case 2201:
      gtsamimuBiasConstantBias_print_2201(nargout, out, nargin-1, in+1);
      break;
    case 2202:
      gtsamimuBiasConstantBias_retract_2202(nargout, out, nargin-1, in+1);
      break;
    case 2203:
      gtsamimuBiasConstantBias_vector_2203(nargout, out, nargin-1, in+1);
      break;
    case 2204:
      gtsamimuBiasConstantBias_Expmap_2204(nargout, out, nargin-1, in+1);
      break;
    case 2205:
      gtsamimuBiasConstantBias_Logmap_2205(nargout, out, nargin-1, in+1);
      break;
    case 2206:
      gtsamimuBiasConstantBias_identity_2206(nargout, out, nargin-1, in+1);
      break;
    case 2207:
      gtsamNavState_collectorInsertAndMakeBase_2207(nargout, out, nargin-1, in+1);
      break;
    case 2208:
      gtsamNavState_constructor_2208(nargout, out, nargin-1, in+1);
      break;
    case 2209:
      gtsamNavState_constructor_2209(nargout, out, nargin-1, in+1);
      break;
    case 2210:
      gtsamNavState_constructor_2210(nargout, out, nargin-1, in+1);
      break;
    case 2211:
      gtsamNavState_deconstructor_2211(nargout, out, nargin-1, in+1);
      break;
    case 2212:
      gtsamNavState_attitude_2212(nargout, out, nargin-1, in+1);
      break;
    case 2213:
      gtsamNavState_equals_2213(nargout, out, nargin-1, in+1);
      break;
    case 2214:
      gtsamNavState_pose_2214(nargout, out, nargin-1, in+1);
      break;
    case 2215:
      gtsamNavState_position_2215(nargout, out, nargin-1, in+1);
      break;
    case 2216:
      gtsamNavState_print_2216(nargout, out, nargin-1, in+1);
      break;
    case 2217:
      gtsamNavState_velocity_2217(nargout, out, nargin-1, in+1);
      break;
    case 2218:
      gtsamPreintegratedRotationParams_collectorInsertAndMakeBase_2218(nargout, out, nargin-1, in+1);
      break;
    case 2219:
      gtsamPreintegratedRotationParams_upcastFromVoid_2219(nargout, out, nargin-1, in+1);
      break;
    case 2220:
      gtsamPreintegratedRotationParams_constructor_2220(nargout, out, nargin-1, in+1);
      break;
    case 2221:
      gtsamPreintegratedRotationParams_deconstructor_2221(nargout, out, nargin-1, in+1);
      break;
    case 2222:
      gtsamPreintegratedRotationParams_getGyroscopeCovariance_2222(nargout, out, nargin-1, in+1);
      break;
    case 2223:
      gtsamPreintegratedRotationParams_setBodyPSensor_2223(nargout, out, nargin-1, in+1);
      break;
    case 2224:
      gtsamPreintegratedRotationParams_setGyroscopeCovariance_2224(nargout, out, nargin-1, in+1);
      break;
    case 2225:
      gtsamPreintegratedRotationParams_setOmegaCoriolis_2225(nargout, out, nargin-1, in+1);
      break;
    case 2226:
      gtsamPreintegrationParams_collectorInsertAndMakeBase_2226(nargout, out, nargin-1, in+1);
      break;
    case 2227:
      gtsamPreintegrationParams_upcastFromVoid_2227(nargout, out, nargin-1, in+1);
      break;
    case 2228:
      gtsamPreintegrationParams_constructor_2228(nargout, out, nargin-1, in+1);
      break;
    case 2229:
      gtsamPreintegrationParams_deconstructor_2229(nargout, out, nargin-1, in+1);
      break;
    case 2230:
      gtsamPreintegrationParams_getAccelerometerCovariance_2230(nargout, out, nargin-1, in+1);
      break;
    case 2231:
      gtsamPreintegrationParams_getGyroscopeCovariance_2231(nargout, out, nargin-1, in+1);
      break;
    case 2232:
      gtsamPreintegrationParams_getIntegrationCovariance_2232(nargout, out, nargin-1, in+1);
      break;
    case 2233:
      gtsamPreintegrationParams_getUse2ndOrderCoriolis_2233(nargout, out, nargin-1, in+1);
      break;
    case 2234:
      gtsamPreintegrationParams_print_2234(nargout, out, nargin-1, in+1);
      break;
    case 2235:
      gtsamPreintegrationParams_setAccelerometerCovariance_2235(nargout, out, nargin-1, in+1);
      break;
    case 2236:
      gtsamPreintegrationParams_setBodyPSensor_2236(nargout, out, nargin-1, in+1);
      break;
    case 2237:
      gtsamPreintegrationParams_setGyroscopeCovariance_2237(nargout, out, nargin-1, in+1);
      break;
    case 2238:
      gtsamPreintegrationParams_setIntegrationCovariance_2238(nargout, out, nargin-1, in+1);
      break;
    case 2239:
      gtsamPreintegrationParams_setOmegaCoriolis_2239(nargout, out, nargin-1, in+1);
      break;
    case 2240:
      gtsamPreintegrationParams_setUse2ndOrderCoriolis_2240(nargout, out, nargin-1, in+1);
      break;
    case 2241:
      gtsamPreintegratedImuMeasurements_collectorInsertAndMakeBase_2241(nargout, out, nargin-1, in+1);
      break;
    case 2242:
      gtsamPreintegratedImuMeasurements_constructor_2242(nargout, out, nargin-1, in+1);
      break;
    case 2243:
      gtsamPreintegratedImuMeasurements_constructor_2243(nargout, out, nargin-1, in+1);
      break;
    case 2244:
      gtsamPreintegratedImuMeasurements_deconstructor_2244(nargout, out, nargin-1, in+1);
      break;
    case 2245:
      gtsamPreintegratedImuMeasurements_biasHatVector_2245(nargout, out, nargin-1, in+1);
      break;
    case 2246:
      gtsamPreintegratedImuMeasurements_deltaPij_2246(nargout, out, nargin-1, in+1);
      break;
    case 2247:
      gtsamPreintegratedImuMeasurements_deltaRij_2247(nargout, out, nargin-1, in+1);
      break;
    case 2248:
      gtsamPreintegratedImuMeasurements_deltaTij_2248(nargout, out, nargin-1, in+1);
      break;
    case 2249:
      gtsamPreintegratedImuMeasurements_deltaVij_2249(nargout, out, nargin-1, in+1);
      break;
    case 2250:
      gtsamPreintegratedImuMeasurements_equals_2250(nargout, out, nargin-1, in+1);
      break;
    case 2251:
      gtsamPreintegratedImuMeasurements_integrateMeasurement_2251(nargout, out, nargin-1, in+1);
      break;
    case 2252:
      gtsamPreintegratedImuMeasurements_predict_2252(nargout, out, nargin-1, in+1);
      break;
    case 2253:
      gtsamPreintegratedImuMeasurements_preintMeasCov_2253(nargout, out, nargin-1, in+1);
      break;
    case 2254:
      gtsamPreintegratedImuMeasurements_print_2254(nargout, out, nargin-1, in+1);
      break;
    case 2255:
      gtsamPreintegratedImuMeasurements_resetIntegration_2255(nargout, out, nargin-1, in+1);
      break;
    case 2256:
      gtsamImuFactor_collectorInsertAndMakeBase_2256(nargout, out, nargin-1, in+1);
      break;
    case 2257:
      gtsamImuFactor_upcastFromVoid_2257(nargout, out, nargin-1, in+1);
      break;
    case 2258:
      gtsamImuFactor_constructor_2258(nargout, out, nargin-1, in+1);
      break;
    case 2259:
      gtsamImuFactor_deconstructor_2259(nargout, out, nargin-1, in+1);
      break;
    case 2260:
      gtsamImuFactor_active_2260(nargout, out, nargin-1, in+1);
      break;
    case 2261:
      gtsamImuFactor_clone_2261(nargout, out, nargin-1, in+1);
      break;
    case 2262:
      gtsamImuFactor_dim_2262(nargout, out, nargin-1, in+1);
      break;
    case 2263:
      gtsamImuFactor_equals_2263(nargout, out, nargin-1, in+1);
      break;
    case 2264:
      gtsamImuFactor_error_2264(nargout, out, nargin-1, in+1);
      break;
    case 2265:
      gtsamImuFactor_evaluateError_2265(nargout, out, nargin-1, in+1);
      break;
    case 2266:
      gtsamImuFactor_keys_2266(nargout, out, nargin-1, in+1);
      break;
    case 2267:
      gtsamImuFactor_linearize_2267(nargout, out, nargin-1, in+1);
      break;
    case 2268:
      gtsamImuFactor_preintegratedMeasurements_2268(nargout, out, nargin-1, in+1);
      break;
    case 2269:
      gtsamImuFactor_print_2269(nargout, out, nargin-1, in+1);
      break;
    case 2270:
      gtsamImuFactor_printKeys_2270(nargout, out, nargin-1, in+1);
      break;
    case 2271:
      gtsamImuFactor_size_2271(nargout, out, nargin-1, in+1);
      break;
    case 2272:
      gtsamPreintegratedCombinedMeasurements_collectorInsertAndMakeBase_2272(nargout, out, nargin-1, in+1);
      break;
    case 2273:
      gtsamPreintegratedCombinedMeasurements_deconstructor_2273(nargout, out, nargin-1, in+1);
      break;
    case 2274:
      gtsamPreintegratedCombinedMeasurements_biasHatVector_2274(nargout, out, nargin-1, in+1);
      break;
    case 2275:
      gtsamPreintegratedCombinedMeasurements_deltaPij_2275(nargout, out, nargin-1, in+1);
      break;
    case 2276:
      gtsamPreintegratedCombinedMeasurements_deltaRij_2276(nargout, out, nargin-1, in+1);
      break;
    case 2277:
      gtsamPreintegratedCombinedMeasurements_deltaTij_2277(nargout, out, nargin-1, in+1);
      break;
    case 2278:
      gtsamPreintegratedCombinedMeasurements_deltaVij_2278(nargout, out, nargin-1, in+1);
      break;
    case 2279:
      gtsamPreintegratedCombinedMeasurements_equals_2279(nargout, out, nargin-1, in+1);
      break;
    case 2280:
      gtsamPreintegratedCombinedMeasurements_integrateMeasurement_2280(nargout, out, nargin-1, in+1);
      break;
    case 2281:
      gtsamPreintegratedCombinedMeasurements_predict_2281(nargout, out, nargin-1, in+1);
      break;
    case 2282:
      gtsamPreintegratedCombinedMeasurements_preintMeasCov_2282(nargout, out, nargin-1, in+1);
      break;
    case 2283:
      gtsamPreintegratedCombinedMeasurements_print_2283(nargout, out, nargin-1, in+1);
      break;
    case 2284:
      gtsamPreintegratedCombinedMeasurements_resetIntegration_2284(nargout, out, nargin-1, in+1);
      break;
    case 2285:
      gtsamCombinedImuFactor_collectorInsertAndMakeBase_2285(nargout, out, nargin-1, in+1);
      break;
    case 2286:
      gtsamCombinedImuFactor_upcastFromVoid_2286(nargout, out, nargin-1, in+1);
      break;
    case 2287:
      gtsamCombinedImuFactor_constructor_2287(nargout, out, nargin-1, in+1);
      break;
    case 2288:
      gtsamCombinedImuFactor_deconstructor_2288(nargout, out, nargin-1, in+1);
      break;
    case 2289:
      gtsamCombinedImuFactor_active_2289(nargout, out, nargin-1, in+1);
      break;
    case 2290:
      gtsamCombinedImuFactor_clone_2290(nargout, out, nargin-1, in+1);
      break;
    case 2291:
      gtsamCombinedImuFactor_dim_2291(nargout, out, nargin-1, in+1);
      break;
    case 2292:
      gtsamCombinedImuFactor_equals_2292(nargout, out, nargin-1, in+1);
      break;
    case 2293:
      gtsamCombinedImuFactor_error_2293(nargout, out, nargin-1, in+1);
      break;
    case 2294:
      gtsamCombinedImuFactor_evaluateError_2294(nargout, out, nargin-1, in+1);
      break;
    case 2295:
      gtsamCombinedImuFactor_keys_2295(nargout, out, nargin-1, in+1);
      break;
    case 2296:
      gtsamCombinedImuFactor_linearize_2296(nargout, out, nargin-1, in+1);
      break;
    case 2297:
      gtsamCombinedImuFactor_preintegratedMeasurements_2297(nargout, out, nargin-1, in+1);
      break;
    case 2298:
      gtsamCombinedImuFactor_print_2298(nargout, out, nargin-1, in+1);
      break;
    case 2299:
      gtsamCombinedImuFactor_printKeys_2299(nargout, out, nargin-1, in+1);
      break;
    case 2300:
      gtsamCombinedImuFactor_size_2300(nargout, out, nargin-1, in+1);
      break;
    case 2301:
      gtsamPreintegratedAhrsMeasurements_collectorInsertAndMakeBase_2301(nargout, out, nargin-1, in+1);
      break;
    case 2302:
      gtsamPreintegratedAhrsMeasurements_constructor_2302(nargout, out, nargin-1, in+1);
      break;
    case 2303:
      gtsamPreintegratedAhrsMeasurements_constructor_2303(nargout, out, nargin-1, in+1);
      break;
    case 2304:
      gtsamPreintegratedAhrsMeasurements_deconstructor_2304(nargout, out, nargin-1, in+1);
      break;
    case 2305:
      gtsamPreintegratedAhrsMeasurements_biasHat_2305(nargout, out, nargin-1, in+1);
      break;
    case 2306:
      gtsamPreintegratedAhrsMeasurements_deltaRij_2306(nargout, out, nargin-1, in+1);
      break;
    case 2307:
      gtsamPreintegratedAhrsMeasurements_deltaTij_2307(nargout, out, nargin-1, in+1);
      break;
    case 2308:
      gtsamPreintegratedAhrsMeasurements_equals_2308(nargout, out, nargin-1, in+1);
      break;
    case 2309:
      gtsamPreintegratedAhrsMeasurements_integrateMeasurement_2309(nargout, out, nargin-1, in+1);
      break;
    case 2310:
      gtsamPreintegratedAhrsMeasurements_print_2310(nargout, out, nargin-1, in+1);
      break;
    case 2311:
      gtsamPreintegratedAhrsMeasurements_resetIntegration_2311(nargout, out, nargin-1, in+1);
      break;
    case 2312:
      gtsamAHRSFactor_collectorInsertAndMakeBase_2312(nargout, out, nargin-1, in+1);
      break;
    case 2313:
      gtsamAHRSFactor_upcastFromVoid_2313(nargout, out, nargin-1, in+1);
      break;
    case 2314:
      gtsamAHRSFactor_constructor_2314(nargout, out, nargin-1, in+1);
      break;
    case 2315:
      gtsamAHRSFactor_constructor_2315(nargout, out, nargin-1, in+1);
      break;
    case 2316:
      gtsamAHRSFactor_deconstructor_2316(nargout, out, nargin-1, in+1);
      break;
    case 2317:
      gtsamAHRSFactor_active_2317(nargout, out, nargin-1, in+1);
      break;
    case 2318:
      gtsamAHRSFactor_clone_2318(nargout, out, nargin-1, in+1);
      break;
    case 2319:
      gtsamAHRSFactor_dim_2319(nargout, out, nargin-1, in+1);
      break;
    case 2320:
      gtsamAHRSFactor_equals_2320(nargout, out, nargin-1, in+1);
      break;
    case 2321:
      gtsamAHRSFactor_error_2321(nargout, out, nargin-1, in+1);
      break;
    case 2322:
      gtsamAHRSFactor_evaluateError_2322(nargout, out, nargin-1, in+1);
      break;
    case 2323:
      gtsamAHRSFactor_keys_2323(nargout, out, nargin-1, in+1);
      break;
    case 2324:
      gtsamAHRSFactor_linearize_2324(nargout, out, nargin-1, in+1);
      break;
    case 2325:
      gtsamAHRSFactor_predict_2325(nargout, out, nargin-1, in+1);
      break;
    case 2326:
      gtsamAHRSFactor_preintegratedMeasurements_2326(nargout, out, nargin-1, in+1);
      break;
    case 2327:
      gtsamAHRSFactor_print_2327(nargout, out, nargin-1, in+1);
      break;
    case 2328:
      gtsamAHRSFactor_printKeys_2328(nargout, out, nargin-1, in+1);
      break;
    case 2329:
      gtsamAHRSFactor_size_2329(nargout, out, nargin-1, in+1);
      break;
    case 2330:
      gtsamRot3AttitudeFactor_collectorInsertAndMakeBase_2330(nargout, out, nargin-1, in+1);
      break;
    case 2331:
      gtsamRot3AttitudeFactor_upcastFromVoid_2331(nargout, out, nargin-1, in+1);
      break;
    case 2332:
      gtsamRot3AttitudeFactor_constructor_2332(nargout, out, nargin-1, in+1);
      break;
    case 2333:
      gtsamRot3AttitudeFactor_constructor_2333(nargout, out, nargin-1, in+1);
      break;
    case 2334:
      gtsamRot3AttitudeFactor_constructor_2334(nargout, out, nargin-1, in+1);
      break;
    case 2335:
      gtsamRot3AttitudeFactor_deconstructor_2335(nargout, out, nargin-1, in+1);
      break;
    case 2336:
      gtsamRot3AttitudeFactor_active_2336(nargout, out, nargin-1, in+1);
      break;
    case 2337:
      gtsamRot3AttitudeFactor_bRef_2337(nargout, out, nargin-1, in+1);
      break;
    case 2338:
      gtsamRot3AttitudeFactor_clone_2338(nargout, out, nargin-1, in+1);
      break;
    case 2339:
      gtsamRot3AttitudeFactor_dim_2339(nargout, out, nargin-1, in+1);
      break;
    case 2340:
      gtsamRot3AttitudeFactor_equals_2340(nargout, out, nargin-1, in+1);
      break;
    case 2341:
      gtsamRot3AttitudeFactor_error_2341(nargout, out, nargin-1, in+1);
      break;
    case 2342:
      gtsamRot3AttitudeFactor_keys_2342(nargout, out, nargin-1, in+1);
      break;
    case 2343:
      gtsamRot3AttitudeFactor_linearize_2343(nargout, out, nargin-1, in+1);
      break;
    case 2344:
      gtsamRot3AttitudeFactor_nZ_2344(nargout, out, nargin-1, in+1);
      break;
    case 2345:
      gtsamRot3AttitudeFactor_print_2345(nargout, out, nargin-1, in+1);
      break;
    case 2346:
      gtsamRot3AttitudeFactor_printKeys_2346(nargout, out, nargin-1, in+1);
      break;
    case 2347:
      gtsamRot3AttitudeFactor_size_2347(nargout, out, nargin-1, in+1);
      break;
    case 2348:
      gtsamPose3AttitudeFactor_collectorInsertAndMakeBase_2348(nargout, out, nargin-1, in+1);
      break;
    case 2349:
      gtsamPose3AttitudeFactor_upcastFromVoid_2349(nargout, out, nargin-1, in+1);
      break;
    case 2350:
      gtsamPose3AttitudeFactor_constructor_2350(nargout, out, nargin-1, in+1);
      break;
    case 2351:
      gtsamPose3AttitudeFactor_constructor_2351(nargout, out, nargin-1, in+1);
      break;
    case 2352:
      gtsamPose3AttitudeFactor_constructor_2352(nargout, out, nargin-1, in+1);
      break;
    case 2353:
      gtsamPose3AttitudeFactor_deconstructor_2353(nargout, out, nargin-1, in+1);
      break;
    case 2354:
      gtsamPose3AttitudeFactor_active_2354(nargout, out, nargin-1, in+1);
      break;
    case 2355:
      gtsamPose3AttitudeFactor_bRef_2355(nargout, out, nargin-1, in+1);
      break;
    case 2356:
      gtsamPose3AttitudeFactor_clone_2356(nargout, out, nargin-1, in+1);
      break;
    case 2357:
      gtsamPose3AttitudeFactor_dim_2357(nargout, out, nargin-1, in+1);
      break;
    case 2358:
      gtsamPose3AttitudeFactor_equals_2358(nargout, out, nargin-1, in+1);
      break;
    case 2359:
      gtsamPose3AttitudeFactor_error_2359(nargout, out, nargin-1, in+1);
      break;
    case 2360:
      gtsamPose3AttitudeFactor_keys_2360(nargout, out, nargin-1, in+1);
      break;
    case 2361:
      gtsamPose3AttitudeFactor_linearize_2361(nargout, out, nargin-1, in+1);
      break;
    case 2362:
      gtsamPose3AttitudeFactor_nZ_2362(nargout, out, nargin-1, in+1);
      break;
    case 2363:
      gtsamPose3AttitudeFactor_print_2363(nargout, out, nargin-1, in+1);
      break;
    case 2364:
      gtsamPose3AttitudeFactor_printKeys_2364(nargout, out, nargin-1, in+1);
      break;
    case 2365:
      gtsamPose3AttitudeFactor_size_2365(nargout, out, nargin-1, in+1);
      break;
    case 2366:
      gtsamRedirectCout_collectorInsertAndMakeBase_2366(nargout, out, nargin-1, in+1);
      break;
    case 2367:
      gtsamRedirectCout_constructor_2367(nargout, out, nargin-1, in+1);
      break;
    case 2368:
      gtsamRedirectCout_deconstructor_2368(nargout, out, nargin-1, in+1);
      break;
    case 2369:
      gtsamRedirectCout_str_2369(nargout, out, nargin-1, in+1);
      break;
    case 2370:
      gtsamPinholeCameraCal3_S2_collectorInsertAndMakeBase_2370(nargout, out, nargin-1, in+1);
      break;
    case 2371:
      gtsamPinholeCameraCal3_S2_constructor_2371(nargout, out, nargin-1, in+1);
      break;
    case 2372:
      gtsamPinholeCameraCal3_S2_constructor_2372(nargout, out, nargin-1, in+1);
      break;
    case 2373:
      gtsamPinholeCameraCal3_S2_constructor_2373(nargout, out, nargin-1, in+1);
      break;
    case 2374:
      gtsamPinholeCameraCal3_S2_deconstructor_2374(nargout, out, nargin-1, in+1);
      break;
    case 2375:
      gtsamPinholeCameraCal3_S2_backproject_2375(nargout, out, nargin-1, in+1);
      break;
    case 2376:
      gtsamPinholeCameraCal3_S2_calibration_2376(nargout, out, nargin-1, in+1);
      break;
    case 2377:
      gtsamPinholeCameraCal3_S2_dim_2377(nargout, out, nargin-1, in+1);
      break;
    case 2378:
      gtsamPinholeCameraCal3_S2_equals_2378(nargout, out, nargin-1, in+1);
      break;
    case 2379:
      gtsamPinholeCameraCal3_S2_localCoordinates_2379(nargout, out, nargin-1, in+1);
      break;
    case 2380:
      gtsamPinholeCameraCal3_S2_pose_2380(nargout, out, nargin-1, in+1);
      break;
    case 2381:
      gtsamPinholeCameraCal3_S2_print_2381(nargout, out, nargin-1, in+1);
      break;
    case 2382:
      gtsamPinholeCameraCal3_S2_project_2382(nargout, out, nargin-1, in+1);
      break;
    case 2383:
      gtsamPinholeCameraCal3_S2_projectSafe_2383(nargout, out, nargin-1, in+1);
      break;
    case 2384:
      gtsamPinholeCameraCal3_S2_range_2384(nargout, out, nargin-1, in+1);
      break;
    case 2385:
      gtsamPinholeCameraCal3_S2_range_2385(nargout, out, nargin-1, in+1);
      break;
    case 2386:
      gtsamPinholeCameraCal3_S2_retract_2386(nargout, out, nargin-1, in+1);
      break;
    case 2387:
      gtsamPinholeCameraCal3_S2_string_serialize_2387(nargout, out, nargin-1, in+1);
      break;
    case 2388:
      gtsamPinholeCameraCal3_S2_Dim_2388(nargout, out, nargin-1, in+1);
      break;
    case 2389:
      gtsamPinholeCameraCal3_S2_Level_2389(nargout, out, nargin-1, in+1);
      break;
    case 2390:
      gtsamPinholeCameraCal3_S2_Level_2390(nargout, out, nargin-1, in+1);
      break;
    case 2391:
      gtsamPinholeCameraCal3_S2_Lookat_2391(nargout, out, nargin-1, in+1);
      break;
    case 2392:
      gtsamPinholeCameraCal3_S2_Project_2392(nargout, out, nargin-1, in+1);
      break;
    case 2393:
      gtsamPinholeCameraCal3_S2_string_deserialize_2393(nargout, out, nargin-1, in+1);
      break;
    case 2394:
      gtsamRangeFactorPosePoint2_collectorInsertAndMakeBase_2394(nargout, out, nargin-1, in+1);
      break;
    case 2395:
      gtsamRangeFactorPosePoint2_upcastFromVoid_2395(nargout, out, nargin-1, in+1);
      break;
    case 2396:
      gtsamRangeFactorPosePoint2_constructor_2396(nargout, out, nargin-1, in+1);
      break;
    case 2397:
      gtsamRangeFactorPosePoint2_deconstructor_2397(nargout, out, nargin-1, in+1);
      break;
    case 2398:
      gtsamRangeFactorPosePoint2_active_2398(nargout, out, nargin-1, in+1);
      break;
    case 2399:
      gtsamRangeFactorPosePoint2_clone_2399(nargout, out, nargin-1, in+1);
      break;
    case 2400:
      gtsamRangeFactorPosePoint2_dim_2400(nargout, out, nargin-1, in+1);
      break;
    case 2401:
      gtsamRangeFactorPosePoint2_equals_2401(nargout, out, nargin-1, in+1);
      break;
    case 2402:
      gtsamRangeFactorPosePoint2_error_2402(nargout, out, nargin-1, in+1);
      break;
    case 2403:
      gtsamRangeFactorPosePoint2_get_noiseModel_2403(nargout, out, nargin-1, in+1);
      break;
    case 2404:
      gtsamRangeFactorPosePoint2_keys_2404(nargout, out, nargin-1, in+1);
      break;
    case 2405:
      gtsamRangeFactorPosePoint2_linearize_2405(nargout, out, nargin-1, in+1);
      break;
    case 2406:
      gtsamRangeFactorPosePoint2_noiseModel_2406(nargout, out, nargin-1, in+1);
      break;
    case 2407:
      gtsamRangeFactorPosePoint2_print_2407(nargout, out, nargin-1, in+1);
      break;
    case 2408:
      gtsamRangeFactorPosePoint2_printKeys_2408(nargout, out, nargin-1, in+1);
      break;
    case 2409:
      gtsamRangeFactorPosePoint2_size_2409(nargout, out, nargin-1, in+1);
      break;
    case 2410:
      gtsamRangeFactorPosePoint2_unwhitenedError_2410(nargout, out, nargin-1, in+1);
      break;
    case 2411:
      gtsamRangeFactorPosePoint2_whitenedError_2411(nargout, out, nargin-1, in+1);
      break;
    case 2412:
      gtsamRangeFactorPosePoint3_collectorInsertAndMakeBase_2412(nargout, out, nargin-1, in+1);
      break;
    case 2413:
      gtsamRangeFactorPosePoint3_upcastFromVoid_2413(nargout, out, nargin-1, in+1);
      break;
    case 2414:
      gtsamRangeFactorPosePoint3_constructor_2414(nargout, out, nargin-1, in+1);
      break;
    case 2415:
      gtsamRangeFactorPosePoint3_deconstructor_2415(nargout, out, nargin-1, in+1);
      break;
    case 2416:
      gtsamRangeFactorPosePoint3_active_2416(nargout, out, nargin-1, in+1);
      break;
    case 2417:
      gtsamRangeFactorPosePoint3_clone_2417(nargout, out, nargin-1, in+1);
      break;
    case 2418:
      gtsamRangeFactorPosePoint3_dim_2418(nargout, out, nargin-1, in+1);
      break;
    case 2419:
      gtsamRangeFactorPosePoint3_equals_2419(nargout, out, nargin-1, in+1);
      break;
    case 2420:
      gtsamRangeFactorPosePoint3_error_2420(nargout, out, nargin-1, in+1);
      break;
    case 2421:
      gtsamRangeFactorPosePoint3_get_noiseModel_2421(nargout, out, nargin-1, in+1);
      break;
    case 2422:
      gtsamRangeFactorPosePoint3_keys_2422(nargout, out, nargin-1, in+1);
      break;
    case 2423:
      gtsamRangeFactorPosePoint3_linearize_2423(nargout, out, nargin-1, in+1);
      break;
    case 2424:
      gtsamRangeFactorPosePoint3_noiseModel_2424(nargout, out, nargin-1, in+1);
      break;
    case 2425:
      gtsamRangeFactorPosePoint3_print_2425(nargout, out, nargin-1, in+1);
      break;
    case 2426:
      gtsamRangeFactorPosePoint3_printKeys_2426(nargout, out, nargin-1, in+1);
      break;
    case 2427:
      gtsamRangeFactorPosePoint3_size_2427(nargout, out, nargin-1, in+1);
      break;
    case 2428:
      gtsamRangeFactorPosePoint3_unwhitenedError_2428(nargout, out, nargin-1, in+1);
      break;
    case 2429:
      gtsamRangeFactorPosePoint3_whitenedError_2429(nargout, out, nargin-1, in+1);
      break;
    case 2430:
      gtsamRangeFactorPose2_collectorInsertAndMakeBase_2430(nargout, out, nargin-1, in+1);
      break;
    case 2431:
      gtsamRangeFactorPose2_upcastFromVoid_2431(nargout, out, nargin-1, in+1);
      break;
    case 2432:
      gtsamRangeFactorPose2_constructor_2432(nargout, out, nargin-1, in+1);
      break;
    case 2433:
      gtsamRangeFactorPose2_deconstructor_2433(nargout, out, nargin-1, in+1);
      break;
    case 2434:
      gtsamRangeFactorPose2_active_2434(nargout, out, nargin-1, in+1);
      break;
    case 2435:
      gtsamRangeFactorPose2_clone_2435(nargout, out, nargin-1, in+1);
      break;
    case 2436:
      gtsamRangeFactorPose2_dim_2436(nargout, out, nargin-1, in+1);
      break;
    case 2437:
      gtsamRangeFactorPose2_equals_2437(nargout, out, nargin-1, in+1);
      break;
    case 2438:
      gtsamRangeFactorPose2_error_2438(nargout, out, nargin-1, in+1);
      break;
    case 2439:
      gtsamRangeFactorPose2_get_noiseModel_2439(nargout, out, nargin-1, in+1);
      break;
    case 2440:
      gtsamRangeFactorPose2_keys_2440(nargout, out, nargin-1, in+1);
      break;
    case 2441:
      gtsamRangeFactorPose2_linearize_2441(nargout, out, nargin-1, in+1);
      break;
    case 2442:
      gtsamRangeFactorPose2_noiseModel_2442(nargout, out, nargin-1, in+1);
      break;
    case 2443:
      gtsamRangeFactorPose2_print_2443(nargout, out, nargin-1, in+1);
      break;
    case 2444:
      gtsamRangeFactorPose2_printKeys_2444(nargout, out, nargin-1, in+1);
      break;
    case 2445:
      gtsamRangeFactorPose2_size_2445(nargout, out, nargin-1, in+1);
      break;
    case 2446:
      gtsamRangeFactorPose2_unwhitenedError_2446(nargout, out, nargin-1, in+1);
      break;
    case 2447:
      gtsamRangeFactorPose2_whitenedError_2447(nargout, out, nargin-1, in+1);
      break;
    case 2448:
      gtsamRangeFactorPose3_collectorInsertAndMakeBase_2448(nargout, out, nargin-1, in+1);
      break;
    case 2449:
      gtsamRangeFactorPose3_upcastFromVoid_2449(nargout, out, nargin-1, in+1);
      break;
    case 2450:
      gtsamRangeFactorPose3_constructor_2450(nargout, out, nargin-1, in+1);
      break;
    case 2451:
      gtsamRangeFactorPose3_deconstructor_2451(nargout, out, nargin-1, in+1);
      break;
    case 2452:
      gtsamRangeFactorPose3_active_2452(nargout, out, nargin-1, in+1);
      break;
    case 2453:
      gtsamRangeFactorPose3_clone_2453(nargout, out, nargin-1, in+1);
      break;
    case 2454:
      gtsamRangeFactorPose3_dim_2454(nargout, out, nargin-1, in+1);
      break;
    case 2455:
      gtsamRangeFactorPose3_equals_2455(nargout, out, nargin-1, in+1);
      break;
    case 2456:
      gtsamRangeFactorPose3_error_2456(nargout, out, nargin-1, in+1);
      break;
    case 2457:
      gtsamRangeFactorPose3_get_noiseModel_2457(nargout, out, nargin-1, in+1);
      break;
    case 2458:
      gtsamRangeFactorPose3_keys_2458(nargout, out, nargin-1, in+1);
      break;
    case 2459:
      gtsamRangeFactorPose3_linearize_2459(nargout, out, nargin-1, in+1);
      break;
    case 2460:
      gtsamRangeFactorPose3_noiseModel_2460(nargout, out, nargin-1, in+1);
      break;
    case 2461:
      gtsamRangeFactorPose3_print_2461(nargout, out, nargin-1, in+1);
      break;
    case 2462:
      gtsamRangeFactorPose3_printKeys_2462(nargout, out, nargin-1, in+1);
      break;
    case 2463:
      gtsamRangeFactorPose3_size_2463(nargout, out, nargin-1, in+1);
      break;
    case 2464:
      gtsamRangeFactorPose3_unwhitenedError_2464(nargout, out, nargin-1, in+1);
      break;
    case 2465:
      gtsamRangeFactorPose3_whitenedError_2465(nargout, out, nargin-1, in+1);
      break;
    case 2466:
      gtsamRangeFactorCalibratedCameraPoint_collectorInsertAndMakeBase_2466(nargout, out, nargin-1, in+1);
      break;
    case 2467:
      gtsamRangeFactorCalibratedCameraPoint_upcastFromVoid_2467(nargout, out, nargin-1, in+1);
      break;
    case 2468:
      gtsamRangeFactorCalibratedCameraPoint_constructor_2468(nargout, out, nargin-1, in+1);
      break;
    case 2469:
      gtsamRangeFactorCalibratedCameraPoint_deconstructor_2469(nargout, out, nargin-1, in+1);
      break;
    case 2470:
      gtsamRangeFactorCalibratedCameraPoint_active_2470(nargout, out, nargin-1, in+1);
      break;
    case 2471:
      gtsamRangeFactorCalibratedCameraPoint_clone_2471(nargout, out, nargin-1, in+1);
      break;
    case 2472:
      gtsamRangeFactorCalibratedCameraPoint_dim_2472(nargout, out, nargin-1, in+1);
      break;
    case 2473:
      gtsamRangeFactorCalibratedCameraPoint_equals_2473(nargout, out, nargin-1, in+1);
      break;
    case 2474:
      gtsamRangeFactorCalibratedCameraPoint_error_2474(nargout, out, nargin-1, in+1);
      break;
    case 2475:
      gtsamRangeFactorCalibratedCameraPoint_get_noiseModel_2475(nargout, out, nargin-1, in+1);
      break;
    case 2476:
      gtsamRangeFactorCalibratedCameraPoint_keys_2476(nargout, out, nargin-1, in+1);
      break;
    case 2477:
      gtsamRangeFactorCalibratedCameraPoint_linearize_2477(nargout, out, nargin-1, in+1);
      break;
    case 2478:
      gtsamRangeFactorCalibratedCameraPoint_noiseModel_2478(nargout, out, nargin-1, in+1);
      break;
    case 2479:
      gtsamRangeFactorCalibratedCameraPoint_print_2479(nargout, out, nargin-1, in+1);
      break;
    case 2480:
      gtsamRangeFactorCalibratedCameraPoint_printKeys_2480(nargout, out, nargin-1, in+1);
      break;
    case 2481:
      gtsamRangeFactorCalibratedCameraPoint_size_2481(nargout, out, nargin-1, in+1);
      break;
    case 2482:
      gtsamRangeFactorCalibratedCameraPoint_unwhitenedError_2482(nargout, out, nargin-1, in+1);
      break;
    case 2483:
      gtsamRangeFactorCalibratedCameraPoint_whitenedError_2483(nargout, out, nargin-1, in+1);
      break;
    case 2484:
      gtsamRangeFactorSimpleCameraPoint_collectorInsertAndMakeBase_2484(nargout, out, nargin-1, in+1);
      break;
    case 2485:
      gtsamRangeFactorSimpleCameraPoint_upcastFromVoid_2485(nargout, out, nargin-1, in+1);
      break;
    case 2486:
      gtsamRangeFactorSimpleCameraPoint_constructor_2486(nargout, out, nargin-1, in+1);
      break;
    case 2487:
      gtsamRangeFactorSimpleCameraPoint_deconstructor_2487(nargout, out, nargin-1, in+1);
      break;
    case 2488:
      gtsamRangeFactorSimpleCameraPoint_active_2488(nargout, out, nargin-1, in+1);
      break;
    case 2489:
      gtsamRangeFactorSimpleCameraPoint_clone_2489(nargout, out, nargin-1, in+1);
      break;
    case 2490:
      gtsamRangeFactorSimpleCameraPoint_dim_2490(nargout, out, nargin-1, in+1);
      break;
    case 2491:
      gtsamRangeFactorSimpleCameraPoint_equals_2491(nargout, out, nargin-1, in+1);
      break;
    case 2492:
      gtsamRangeFactorSimpleCameraPoint_error_2492(nargout, out, nargin-1, in+1);
      break;
    case 2493:
      gtsamRangeFactorSimpleCameraPoint_get_noiseModel_2493(nargout, out, nargin-1, in+1);
      break;
    case 2494:
      gtsamRangeFactorSimpleCameraPoint_keys_2494(nargout, out, nargin-1, in+1);
      break;
    case 2495:
      gtsamRangeFactorSimpleCameraPoint_linearize_2495(nargout, out, nargin-1, in+1);
      break;
    case 2496:
      gtsamRangeFactorSimpleCameraPoint_noiseModel_2496(nargout, out, nargin-1, in+1);
      break;
    case 2497:
      gtsamRangeFactorSimpleCameraPoint_print_2497(nargout, out, nargin-1, in+1);
      break;
    case 2498:
      gtsamRangeFactorSimpleCameraPoint_printKeys_2498(nargout, out, nargin-1, in+1);
      break;
    case 2499:
      gtsamRangeFactorSimpleCameraPoint_size_2499(nargout, out, nargin-1, in+1);
      break;
    case 2500:
      gtsamRangeFactorSimpleCameraPoint_unwhitenedError_2500(nargout, out, nargin-1, in+1);
      break;
    case 2501:
      gtsamRangeFactorSimpleCameraPoint_whitenedError_2501(nargout, out, nargin-1, in+1);
      break;
    case 2502:
      gtsamRangeFactorCalibratedCamera_collectorInsertAndMakeBase_2502(nargout, out, nargin-1, in+1);
      break;
    case 2503:
      gtsamRangeFactorCalibratedCamera_upcastFromVoid_2503(nargout, out, nargin-1, in+1);
      break;
    case 2504:
      gtsamRangeFactorCalibratedCamera_constructor_2504(nargout, out, nargin-1, in+1);
      break;
    case 2505:
      gtsamRangeFactorCalibratedCamera_deconstructor_2505(nargout, out, nargin-1, in+1);
      break;
    case 2506:
      gtsamRangeFactorCalibratedCamera_active_2506(nargout, out, nargin-1, in+1);
      break;
    case 2507:
      gtsamRangeFactorCalibratedCamera_clone_2507(nargout, out, nargin-1, in+1);
      break;
    case 2508:
      gtsamRangeFactorCalibratedCamera_dim_2508(nargout, out, nargin-1, in+1);
      break;
    case 2509:
      gtsamRangeFactorCalibratedCamera_equals_2509(nargout, out, nargin-1, in+1);
      break;
    case 2510:
      gtsamRangeFactorCalibratedCamera_error_2510(nargout, out, nargin-1, in+1);
      break;
    case 2511:
      gtsamRangeFactorCalibratedCamera_get_noiseModel_2511(nargout, out, nargin-1, in+1);
      break;
    case 2512:
      gtsamRangeFactorCalibratedCamera_keys_2512(nargout, out, nargin-1, in+1);
      break;
    case 2513:
      gtsamRangeFactorCalibratedCamera_linearize_2513(nargout, out, nargin-1, in+1);
      break;
    case 2514:
      gtsamRangeFactorCalibratedCamera_noiseModel_2514(nargout, out, nargin-1, in+1);
      break;
    case 2515:
      gtsamRangeFactorCalibratedCamera_print_2515(nargout, out, nargin-1, in+1);
      break;
    case 2516:
      gtsamRangeFactorCalibratedCamera_printKeys_2516(nargout, out, nargin-1, in+1);
      break;
    case 2517:
      gtsamRangeFactorCalibratedCamera_size_2517(nargout, out, nargin-1, in+1);
      break;
    case 2518:
      gtsamRangeFactorCalibratedCamera_unwhitenedError_2518(nargout, out, nargin-1, in+1);
      break;
    case 2519:
      gtsamRangeFactorCalibratedCamera_whitenedError_2519(nargout, out, nargin-1, in+1);
      break;
    case 2520:
      gtsamRangeFactorSimpleCamera_collectorInsertAndMakeBase_2520(nargout, out, nargin-1, in+1);
      break;
    case 2521:
      gtsamRangeFactorSimpleCamera_upcastFromVoid_2521(nargout, out, nargin-1, in+1);
      break;
    case 2522:
      gtsamRangeFactorSimpleCamera_constructor_2522(nargout, out, nargin-1, in+1);
      break;
    case 2523:
      gtsamRangeFactorSimpleCamera_deconstructor_2523(nargout, out, nargin-1, in+1);
      break;
    case 2524:
      gtsamRangeFactorSimpleCamera_active_2524(nargout, out, nargin-1, in+1);
      break;
    case 2525:
      gtsamRangeFactorSimpleCamera_clone_2525(nargout, out, nargin-1, in+1);
      break;
    case 2526:
      gtsamRangeFactorSimpleCamera_dim_2526(nargout, out, nargin-1, in+1);
      break;
    case 2527:
      gtsamRangeFactorSimpleCamera_equals_2527(nargout, out, nargin-1, in+1);
      break;
    case 2528:
      gtsamRangeFactorSimpleCamera_error_2528(nargout, out, nargin-1, in+1);
      break;
    case 2529:
      gtsamRangeFactorSimpleCamera_get_noiseModel_2529(nargout, out, nargin-1, in+1);
      break;
    case 2530:
      gtsamRangeFactorSimpleCamera_keys_2530(nargout, out, nargin-1, in+1);
      break;
    case 2531:
      gtsamRangeFactorSimpleCamera_linearize_2531(nargout, out, nargin-1, in+1);
      break;
    case 2532:
      gtsamRangeFactorSimpleCamera_noiseModel_2532(nargout, out, nargin-1, in+1);
      break;
    case 2533:
      gtsamRangeFactorSimpleCamera_print_2533(nargout, out, nargin-1, in+1);
      break;
    case 2534:
      gtsamRangeFactorSimpleCamera_printKeys_2534(nargout, out, nargin-1, in+1);
      break;
    case 2535:
      gtsamRangeFactorSimpleCamera_size_2535(nargout, out, nargin-1, in+1);
      break;
    case 2536:
      gtsamRangeFactorSimpleCamera_unwhitenedError_2536(nargout, out, nargin-1, in+1);
      break;
    case 2537:
      gtsamRangeFactorSimpleCamera_whitenedError_2537(nargout, out, nargin-1, in+1);
      break;
    case 2538:
      gtsamRangeFactorWithTransformPosePoint2_collectorInsertAndMakeBase_2538(nargout, out, nargin-1, in+1);
      break;
    case 2539:
      gtsamRangeFactorWithTransformPosePoint2_upcastFromVoid_2539(nargout, out, nargin-1, in+1);
      break;
    case 2540:
      gtsamRangeFactorWithTransformPosePoint2_constructor_2540(nargout, out, nargin-1, in+1);
      break;
    case 2541:
      gtsamRangeFactorWithTransformPosePoint2_deconstructor_2541(nargout, out, nargin-1, in+1);
      break;
    case 2542:
      gtsamRangeFactorWithTransformPosePoint2_active_2542(nargout, out, nargin-1, in+1);
      break;
    case 2543:
      gtsamRangeFactorWithTransformPosePoint2_clone_2543(nargout, out, nargin-1, in+1);
      break;
    case 2544:
      gtsamRangeFactorWithTransformPosePoint2_dim_2544(nargout, out, nargin-1, in+1);
      break;
    case 2545:
      gtsamRangeFactorWithTransformPosePoint2_equals_2545(nargout, out, nargin-1, in+1);
      break;
    case 2546:
      gtsamRangeFactorWithTransformPosePoint2_error_2546(nargout, out, nargin-1, in+1);
      break;
    case 2547:
      gtsamRangeFactorWithTransformPosePoint2_get_noiseModel_2547(nargout, out, nargin-1, in+1);
      break;
    case 2548:
      gtsamRangeFactorWithTransformPosePoint2_keys_2548(nargout, out, nargin-1, in+1);
      break;
    case 2549:
      gtsamRangeFactorWithTransformPosePoint2_linearize_2549(nargout, out, nargin-1, in+1);
      break;
    case 2550:
      gtsamRangeFactorWithTransformPosePoint2_noiseModel_2550(nargout, out, nargin-1, in+1);
      break;
    case 2551:
      gtsamRangeFactorWithTransformPosePoint2_print_2551(nargout, out, nargin-1, in+1);
      break;
    case 2552:
      gtsamRangeFactorWithTransformPosePoint2_printKeys_2552(nargout, out, nargin-1, in+1);
      break;
    case 2553:
      gtsamRangeFactorWithTransformPosePoint2_size_2553(nargout, out, nargin-1, in+1);
      break;
    case 2554:
      gtsamRangeFactorWithTransformPosePoint2_unwhitenedError_2554(nargout, out, nargin-1, in+1);
      break;
    case 2555:
      gtsamRangeFactorWithTransformPosePoint2_whitenedError_2555(nargout, out, nargin-1, in+1);
      break;
    case 2556:
      gtsamRangeFactorWithTransformPosePoint3_collectorInsertAndMakeBase_2556(nargout, out, nargin-1, in+1);
      break;
    case 2557:
      gtsamRangeFactorWithTransformPosePoint3_upcastFromVoid_2557(nargout, out, nargin-1, in+1);
      break;
    case 2558:
      gtsamRangeFactorWithTransformPosePoint3_constructor_2558(nargout, out, nargin-1, in+1);
      break;
    case 2559:
      gtsamRangeFactorWithTransformPosePoint3_deconstructor_2559(nargout, out, nargin-1, in+1);
      break;
    case 2560:
      gtsamRangeFactorWithTransformPosePoint3_active_2560(nargout, out, nargin-1, in+1);
      break;
    case 2561:
      gtsamRangeFactorWithTransformPosePoint3_clone_2561(nargout, out, nargin-1, in+1);
      break;
    case 2562:
      gtsamRangeFactorWithTransformPosePoint3_dim_2562(nargout, out, nargin-1, in+1);
      break;
    case 2563:
      gtsamRangeFactorWithTransformPosePoint3_equals_2563(nargout, out, nargin-1, in+1);
      break;
    case 2564:
      gtsamRangeFactorWithTransformPosePoint3_error_2564(nargout, out, nargin-1, in+1);
      break;
    case 2565:
      gtsamRangeFactorWithTransformPosePoint3_get_noiseModel_2565(nargout, out, nargin-1, in+1);
      break;
    case 2566:
      gtsamRangeFactorWithTransformPosePoint3_keys_2566(nargout, out, nargin-1, in+1);
      break;
    case 2567:
      gtsamRangeFactorWithTransformPosePoint3_linearize_2567(nargout, out, nargin-1, in+1);
      break;
    case 2568:
      gtsamRangeFactorWithTransformPosePoint3_noiseModel_2568(nargout, out, nargin-1, in+1);
      break;
    case 2569:
      gtsamRangeFactorWithTransformPosePoint3_print_2569(nargout, out, nargin-1, in+1);
      break;
    case 2570:
      gtsamRangeFactorWithTransformPosePoint3_printKeys_2570(nargout, out, nargin-1, in+1);
      break;
    case 2571:
      gtsamRangeFactorWithTransformPosePoint3_size_2571(nargout, out, nargin-1, in+1);
      break;
    case 2572:
      gtsamRangeFactorWithTransformPosePoint3_unwhitenedError_2572(nargout, out, nargin-1, in+1);
      break;
    case 2573:
      gtsamRangeFactorWithTransformPosePoint3_whitenedError_2573(nargout, out, nargin-1, in+1);
      break;
    case 2574:
      gtsamRangeFactorWithTransformPose2_collectorInsertAndMakeBase_2574(nargout, out, nargin-1, in+1);
      break;
    case 2575:
      gtsamRangeFactorWithTransformPose2_upcastFromVoid_2575(nargout, out, nargin-1, in+1);
      break;
    case 2576:
      gtsamRangeFactorWithTransformPose2_constructor_2576(nargout, out, nargin-1, in+1);
      break;
    case 2577:
      gtsamRangeFactorWithTransformPose2_deconstructor_2577(nargout, out, nargin-1, in+1);
      break;
    case 2578:
      gtsamRangeFactorWithTransformPose2_active_2578(nargout, out, nargin-1, in+1);
      break;
    case 2579:
      gtsamRangeFactorWithTransformPose2_clone_2579(nargout, out, nargin-1, in+1);
      break;
    case 2580:
      gtsamRangeFactorWithTransformPose2_dim_2580(nargout, out, nargin-1, in+1);
      break;
    case 2581:
      gtsamRangeFactorWithTransformPose2_equals_2581(nargout, out, nargin-1, in+1);
      break;
    case 2582:
      gtsamRangeFactorWithTransformPose2_error_2582(nargout, out, nargin-1, in+1);
      break;
    case 2583:
      gtsamRangeFactorWithTransformPose2_get_noiseModel_2583(nargout, out, nargin-1, in+1);
      break;
    case 2584:
      gtsamRangeFactorWithTransformPose2_keys_2584(nargout, out, nargin-1, in+1);
      break;
    case 2585:
      gtsamRangeFactorWithTransformPose2_linearize_2585(nargout, out, nargin-1, in+1);
      break;
    case 2586:
      gtsamRangeFactorWithTransformPose2_noiseModel_2586(nargout, out, nargin-1, in+1);
      break;
    case 2587:
      gtsamRangeFactorWithTransformPose2_print_2587(nargout, out, nargin-1, in+1);
      break;
    case 2588:
      gtsamRangeFactorWithTransformPose2_printKeys_2588(nargout, out, nargin-1, in+1);
      break;
    case 2589:
      gtsamRangeFactorWithTransformPose2_size_2589(nargout, out, nargin-1, in+1);
      break;
    case 2590:
      gtsamRangeFactorWithTransformPose2_unwhitenedError_2590(nargout, out, nargin-1, in+1);
      break;
    case 2591:
      gtsamRangeFactorWithTransformPose2_whitenedError_2591(nargout, out, nargin-1, in+1);
      break;
    case 2592:
      gtsamRangeFactorWithTransformPose3_collectorInsertAndMakeBase_2592(nargout, out, nargin-1, in+1);
      break;
    case 2593:
      gtsamRangeFactorWithTransformPose3_upcastFromVoid_2593(nargout, out, nargin-1, in+1);
      break;
    case 2594:
      gtsamRangeFactorWithTransformPose3_constructor_2594(nargout, out, nargin-1, in+1);
      break;
    case 2595:
      gtsamRangeFactorWithTransformPose3_deconstructor_2595(nargout, out, nargin-1, in+1);
      break;
    case 2596:
      gtsamRangeFactorWithTransformPose3_active_2596(nargout, out, nargin-1, in+1);
      break;
    case 2597:
      gtsamRangeFactorWithTransformPose3_clone_2597(nargout, out, nargin-1, in+1);
      break;
    case 2598:
      gtsamRangeFactorWithTransformPose3_dim_2598(nargout, out, nargin-1, in+1);
      break;
    case 2599:
      gtsamRangeFactorWithTransformPose3_equals_2599(nargout, out, nargin-1, in+1);
      break;
    case 2600:
      gtsamRangeFactorWithTransformPose3_error_2600(nargout, out, nargin-1, in+1);
      break;
    case 2601:
      gtsamRangeFactorWithTransformPose3_get_noiseModel_2601(nargout, out, nargin-1, in+1);
      break;
    case 2602:
      gtsamRangeFactorWithTransformPose3_keys_2602(nargout, out, nargin-1, in+1);
      break;
    case 2603:
      gtsamRangeFactorWithTransformPose3_linearize_2603(nargout, out, nargin-1, in+1);
      break;
    case 2604:
      gtsamRangeFactorWithTransformPose3_noiseModel_2604(nargout, out, nargin-1, in+1);
      break;
    case 2605:
      gtsamRangeFactorWithTransformPose3_print_2605(nargout, out, nargin-1, in+1);
      break;
    case 2606:
      gtsamRangeFactorWithTransformPose3_printKeys_2606(nargout, out, nargin-1, in+1);
      break;
    case 2607:
      gtsamRangeFactorWithTransformPose3_size_2607(nargout, out, nargin-1, in+1);
      break;
    case 2608:
      gtsamRangeFactorWithTransformPose3_unwhitenedError_2608(nargout, out, nargin-1, in+1);
      break;
    case 2609:
      gtsamRangeFactorWithTransformPose3_whitenedError_2609(nargout, out, nargin-1, in+1);
      break;
    case 2610:
      gtsamBearingFactor2D_collectorInsertAndMakeBase_2610(nargout, out, nargin-1, in+1);
      break;
    case 2611:
      gtsamBearingFactor2D_upcastFromVoid_2611(nargout, out, nargin-1, in+1);
      break;
    case 2612:
      gtsamBearingFactor2D_constructor_2612(nargout, out, nargin-1, in+1);
      break;
    case 2613:
      gtsamBearingFactor2D_deconstructor_2613(nargout, out, nargin-1, in+1);
      break;
    case 2614:
      gtsamBearingFactor2D_active_2614(nargout, out, nargin-1, in+1);
      break;
    case 2615:
      gtsamBearingFactor2D_clone_2615(nargout, out, nargin-1, in+1);
      break;
    case 2616:
      gtsamBearingFactor2D_dim_2616(nargout, out, nargin-1, in+1);
      break;
    case 2617:
      gtsamBearingFactor2D_equals_2617(nargout, out, nargin-1, in+1);
      break;
    case 2618:
      gtsamBearingFactor2D_error_2618(nargout, out, nargin-1, in+1);
      break;
    case 2619:
      gtsamBearingFactor2D_get_noiseModel_2619(nargout, out, nargin-1, in+1);
      break;
    case 2620:
      gtsamBearingFactor2D_keys_2620(nargout, out, nargin-1, in+1);
      break;
    case 2621:
      gtsamBearingFactor2D_linearize_2621(nargout, out, nargin-1, in+1);
      break;
    case 2622:
      gtsamBearingFactor2D_noiseModel_2622(nargout, out, nargin-1, in+1);
      break;
    case 2623:
      gtsamBearingFactor2D_print_2623(nargout, out, nargin-1, in+1);
      break;
    case 2624:
      gtsamBearingFactor2D_printKeys_2624(nargout, out, nargin-1, in+1);
      break;
    case 2625:
      gtsamBearingFactor2D_size_2625(nargout, out, nargin-1, in+1);
      break;
    case 2626:
      gtsamBearingFactor2D_unwhitenedError_2626(nargout, out, nargin-1, in+1);
      break;
    case 2627:
      gtsamBearingFactor2D_whitenedError_2627(nargout, out, nargin-1, in+1);
      break;
    case 2628:
      gtsamBearingFactor2D_string_serialize_2628(nargout, out, nargin-1, in+1);
      break;
    case 2629:
      gtsamBearingFactor2D_string_deserialize_2629(nargout, out, nargin-1, in+1);
      break;
    case 2630:
      gtsamBearingRangeFactor2D_collectorInsertAndMakeBase_2630(nargout, out, nargin-1, in+1);
      break;
    case 2631:
      gtsamBearingRangeFactor2D_upcastFromVoid_2631(nargout, out, nargin-1, in+1);
      break;
    case 2632:
      gtsamBearingRangeFactor2D_constructor_2632(nargout, out, nargin-1, in+1);
      break;
    case 2633:
      gtsamBearingRangeFactor2D_deconstructor_2633(nargout, out, nargin-1, in+1);
      break;
    case 2634:
      gtsamBearingRangeFactor2D_active_2634(nargout, out, nargin-1, in+1);
      break;
    case 2635:
      gtsamBearingRangeFactor2D_clone_2635(nargout, out, nargin-1, in+1);
      break;
    case 2636:
      gtsamBearingRangeFactor2D_dim_2636(nargout, out, nargin-1, in+1);
      break;
    case 2637:
      gtsamBearingRangeFactor2D_equals_2637(nargout, out, nargin-1, in+1);
      break;
    case 2638:
      gtsamBearingRangeFactor2D_error_2638(nargout, out, nargin-1, in+1);
      break;
    case 2639:
      gtsamBearingRangeFactor2D_get_noiseModel_2639(nargout, out, nargin-1, in+1);
      break;
    case 2640:
      gtsamBearingRangeFactor2D_keys_2640(nargout, out, nargin-1, in+1);
      break;
    case 2641:
      gtsamBearingRangeFactor2D_linearize_2641(nargout, out, nargin-1, in+1);
      break;
    case 2642:
      gtsamBearingRangeFactor2D_noiseModel_2642(nargout, out, nargin-1, in+1);
      break;
    case 2643:
      gtsamBearingRangeFactor2D_print_2643(nargout, out, nargin-1, in+1);
      break;
    case 2644:
      gtsamBearingRangeFactor2D_printKeys_2644(nargout, out, nargin-1, in+1);
      break;
    case 2645:
      gtsamBearingRangeFactor2D_size_2645(nargout, out, nargin-1, in+1);
      break;
    case 2646:
      gtsamBearingRangeFactor2D_unwhitenedError_2646(nargout, out, nargin-1, in+1);
      break;
    case 2647:
      gtsamBearingRangeFactor2D_whitenedError_2647(nargout, out, nargin-1, in+1);
      break;
    case 2648:
      gtsamBearingRangeFactor2D_string_serialize_2648(nargout, out, nargin-1, in+1);
      break;
    case 2649:
      gtsamBearingRangeFactor2D_string_deserialize_2649(nargout, out, nargin-1, in+1);
      break;
    case 2650:
      gtsamGenericProjectionFactorCal3_S2_collectorInsertAndMakeBase_2650(nargout, out, nargin-1, in+1);
      break;
    case 2651:
      gtsamGenericProjectionFactorCal3_S2_upcastFromVoid_2651(nargout, out, nargin-1, in+1);
      break;
    case 2652:
      gtsamGenericProjectionFactorCal3_S2_constructor_2652(nargout, out, nargin-1, in+1);
      break;
    case 2653:
      gtsamGenericProjectionFactorCal3_S2_constructor_2653(nargout, out, nargin-1, in+1);
      break;
    case 2654:
      gtsamGenericProjectionFactorCal3_S2_constructor_2654(nargout, out, nargin-1, in+1);
      break;
    case 2655:
      gtsamGenericProjectionFactorCal3_S2_constructor_2655(nargout, out, nargin-1, in+1);
      break;
    case 2656:
      gtsamGenericProjectionFactorCal3_S2_deconstructor_2656(nargout, out, nargin-1, in+1);
      break;
    case 2657:
      gtsamGenericProjectionFactorCal3_S2_active_2657(nargout, out, nargin-1, in+1);
      break;
    case 2658:
      gtsamGenericProjectionFactorCal3_S2_calibration_2658(nargout, out, nargin-1, in+1);
      break;
    case 2659:
      gtsamGenericProjectionFactorCal3_S2_clone_2659(nargout, out, nargin-1, in+1);
      break;
    case 2660:
      gtsamGenericProjectionFactorCal3_S2_dim_2660(nargout, out, nargin-1, in+1);
      break;
    case 2661:
      gtsamGenericProjectionFactorCal3_S2_equals_2661(nargout, out, nargin-1, in+1);
      break;
    case 2662:
      gtsamGenericProjectionFactorCal3_S2_error_2662(nargout, out, nargin-1, in+1);
      break;
    case 2663:
      gtsamGenericProjectionFactorCal3_S2_get_noiseModel_2663(nargout, out, nargin-1, in+1);
      break;
    case 2664:
      gtsamGenericProjectionFactorCal3_S2_keys_2664(nargout, out, nargin-1, in+1);
      break;
    case 2665:
      gtsamGenericProjectionFactorCal3_S2_linearize_2665(nargout, out, nargin-1, in+1);
      break;
    case 2666:
      gtsamGenericProjectionFactorCal3_S2_measured_2666(nargout, out, nargin-1, in+1);
      break;
    case 2667:
      gtsamGenericProjectionFactorCal3_S2_noiseModel_2667(nargout, out, nargin-1, in+1);
      break;
    case 2668:
      gtsamGenericProjectionFactorCal3_S2_print_2668(nargout, out, nargin-1, in+1);
      break;
    case 2669:
      gtsamGenericProjectionFactorCal3_S2_printKeys_2669(nargout, out, nargin-1, in+1);
      break;
    case 2670:
      gtsamGenericProjectionFactorCal3_S2_size_2670(nargout, out, nargin-1, in+1);
      break;
    case 2671:
      gtsamGenericProjectionFactorCal3_S2_throwCheirality_2671(nargout, out, nargin-1, in+1);
      break;
    case 2672:
      gtsamGenericProjectionFactorCal3_S2_unwhitenedError_2672(nargout, out, nargin-1, in+1);
      break;
    case 2673:
      gtsamGenericProjectionFactorCal3_S2_verboseCheirality_2673(nargout, out, nargin-1, in+1);
      break;
    case 2674:
      gtsamGenericProjectionFactorCal3_S2_whitenedError_2674(nargout, out, nargin-1, in+1);
      break;
    case 2675:
      gtsamGenericProjectionFactorCal3_S2_string_serialize_2675(nargout, out, nargin-1, in+1);
      break;
    case 2676:
      gtsamGenericProjectionFactorCal3_S2_string_deserialize_2676(nargout, out, nargin-1, in+1);
      break;
    case 2677:
      gtsamGenericProjectionFactorCal3DS2_collectorInsertAndMakeBase_2677(nargout, out, nargin-1, in+1);
      break;
    case 2678:
      gtsamGenericProjectionFactorCal3DS2_upcastFromVoid_2678(nargout, out, nargin-1, in+1);
      break;
    case 2679:
      gtsamGenericProjectionFactorCal3DS2_constructor_2679(nargout, out, nargin-1, in+1);
      break;
    case 2680:
      gtsamGenericProjectionFactorCal3DS2_constructor_2680(nargout, out, nargin-1, in+1);
      break;
    case 2681:
      gtsamGenericProjectionFactorCal3DS2_constructor_2681(nargout, out, nargin-1, in+1);
      break;
    case 2682:
      gtsamGenericProjectionFactorCal3DS2_constructor_2682(nargout, out, nargin-1, in+1);
      break;
    case 2683:
      gtsamGenericProjectionFactorCal3DS2_deconstructor_2683(nargout, out, nargin-1, in+1);
      break;
    case 2684:
      gtsamGenericProjectionFactorCal3DS2_active_2684(nargout, out, nargin-1, in+1);
      break;
    case 2685:
      gtsamGenericProjectionFactorCal3DS2_calibration_2685(nargout, out, nargin-1, in+1);
      break;
    case 2686:
      gtsamGenericProjectionFactorCal3DS2_clone_2686(nargout, out, nargin-1, in+1);
      break;
    case 2687:
      gtsamGenericProjectionFactorCal3DS2_dim_2687(nargout, out, nargin-1, in+1);
      break;
    case 2688:
      gtsamGenericProjectionFactorCal3DS2_equals_2688(nargout, out, nargin-1, in+1);
      break;
    case 2689:
      gtsamGenericProjectionFactorCal3DS2_error_2689(nargout, out, nargin-1, in+1);
      break;
    case 2690:
      gtsamGenericProjectionFactorCal3DS2_get_noiseModel_2690(nargout, out, nargin-1, in+1);
      break;
    case 2691:
      gtsamGenericProjectionFactorCal3DS2_keys_2691(nargout, out, nargin-1, in+1);
      break;
    case 2692:
      gtsamGenericProjectionFactorCal3DS2_linearize_2692(nargout, out, nargin-1, in+1);
      break;
    case 2693:
      gtsamGenericProjectionFactorCal3DS2_measured_2693(nargout, out, nargin-1, in+1);
      break;
    case 2694:
      gtsamGenericProjectionFactorCal3DS2_noiseModel_2694(nargout, out, nargin-1, in+1);
      break;
    case 2695:
      gtsamGenericProjectionFactorCal3DS2_print_2695(nargout, out, nargin-1, in+1);
      break;
    case 2696:
      gtsamGenericProjectionFactorCal3DS2_printKeys_2696(nargout, out, nargin-1, in+1);
      break;
    case 2697:
      gtsamGenericProjectionFactorCal3DS2_size_2697(nargout, out, nargin-1, in+1);
      break;
    case 2698:
      gtsamGenericProjectionFactorCal3DS2_throwCheirality_2698(nargout, out, nargin-1, in+1);
      break;
    case 2699:
      gtsamGenericProjectionFactorCal3DS2_unwhitenedError_2699(nargout, out, nargin-1, in+1);
      break;
    case 2700:
      gtsamGenericProjectionFactorCal3DS2_verboseCheirality_2700(nargout, out, nargin-1, in+1);
      break;
    case 2701:
      gtsamGenericProjectionFactorCal3DS2_whitenedError_2701(nargout, out, nargin-1, in+1);
      break;
    case 2702:
      gtsamGenericProjectionFactorCal3DS2_string_serialize_2702(nargout, out, nargin-1, in+1);
      break;
    case 2703:
      gtsamGenericProjectionFactorCal3DS2_string_deserialize_2703(nargout, out, nargin-1, in+1);
      break;
    case 2704:
      gtsamGeneralSFMFactorCal3_S2_collectorInsertAndMakeBase_2704(nargout, out, nargin-1, in+1);
      break;
    case 2705:
      gtsamGeneralSFMFactorCal3_S2_upcastFromVoid_2705(nargout, out, nargin-1, in+1);
      break;
    case 2706:
      gtsamGeneralSFMFactorCal3_S2_constructor_2706(nargout, out, nargin-1, in+1);
      break;
    case 2707:
      gtsamGeneralSFMFactorCal3_S2_deconstructor_2707(nargout, out, nargin-1, in+1);
      break;
    case 2708:
      gtsamGeneralSFMFactorCal3_S2_active_2708(nargout, out, nargin-1, in+1);
      break;
    case 2709:
      gtsamGeneralSFMFactorCal3_S2_clone_2709(nargout, out, nargin-1, in+1);
      break;
    case 2710:
      gtsamGeneralSFMFactorCal3_S2_dim_2710(nargout, out, nargin-1, in+1);
      break;
    case 2711:
      gtsamGeneralSFMFactorCal3_S2_equals_2711(nargout, out, nargin-1, in+1);
      break;
    case 2712:
      gtsamGeneralSFMFactorCal3_S2_error_2712(nargout, out, nargin-1, in+1);
      break;
    case 2713:
      gtsamGeneralSFMFactorCal3_S2_get_noiseModel_2713(nargout, out, nargin-1, in+1);
      break;
    case 2714:
      gtsamGeneralSFMFactorCal3_S2_keys_2714(nargout, out, nargin-1, in+1);
      break;
    case 2715:
      gtsamGeneralSFMFactorCal3_S2_linearize_2715(nargout, out, nargin-1, in+1);
      break;
    case 2716:
      gtsamGeneralSFMFactorCal3_S2_measured_2716(nargout, out, nargin-1, in+1);
      break;
    case 2717:
      gtsamGeneralSFMFactorCal3_S2_noiseModel_2717(nargout, out, nargin-1, in+1);
      break;
    case 2718:
      gtsamGeneralSFMFactorCal3_S2_print_2718(nargout, out, nargin-1, in+1);
      break;
    case 2719:
      gtsamGeneralSFMFactorCal3_S2_printKeys_2719(nargout, out, nargin-1, in+1);
      break;
    case 2720:
      gtsamGeneralSFMFactorCal3_S2_size_2720(nargout, out, nargin-1, in+1);
      break;
    case 2721:
      gtsamGeneralSFMFactorCal3_S2_unwhitenedError_2721(nargout, out, nargin-1, in+1);
      break;
    case 2722:
      gtsamGeneralSFMFactorCal3_S2_whitenedError_2722(nargout, out, nargin-1, in+1);
      break;
    case 2723:
      gtsamSmartProjectionPose3Factor_collectorInsertAndMakeBase_2723(nargout, out, nargin-1, in+1);
      break;
    case 2724:
      gtsamSmartProjectionPose3Factor_upcastFromVoid_2724(nargout, out, nargin-1, in+1);
      break;
    case 2725:
      gtsamSmartProjectionPose3Factor_constructor_2725(nargout, out, nargin-1, in+1);
      break;
    case 2726:
      gtsamSmartProjectionPose3Factor_constructor_2726(nargout, out, nargin-1, in+1);
      break;
    case 2727:
      gtsamSmartProjectionPose3Factor_constructor_2727(nargout, out, nargin-1, in+1);
      break;
    case 2728:
      gtsamSmartProjectionPose3Factor_deconstructor_2728(nargout, out, nargin-1, in+1);
      break;
    case 2729:
      gtsamSmartProjectionPose3Factor_active_2729(nargout, out, nargin-1, in+1);
      break;
    case 2730:
      gtsamSmartProjectionPose3Factor_add_2730(nargout, out, nargin-1, in+1);
      break;
    case 2731:
      gtsamSmartProjectionPose3Factor_clone_2731(nargout, out, nargin-1, in+1);
      break;
    case 2732:
      gtsamSmartProjectionPose3Factor_dim_2732(nargout, out, nargin-1, in+1);
      break;
    case 2733:
      gtsamSmartProjectionPose3Factor_equals_2733(nargout, out, nargin-1, in+1);
      break;
    case 2734:
      gtsamSmartProjectionPose3Factor_error_2734(nargout, out, nargin-1, in+1);
      break;
    case 2735:
      gtsamSmartProjectionPose3Factor_keys_2735(nargout, out, nargin-1, in+1);
      break;
    case 2736:
      gtsamSmartProjectionPose3Factor_linearize_2736(nargout, out, nargin-1, in+1);
      break;
    case 2737:
      gtsamSmartProjectionPose3Factor_print_2737(nargout, out, nargin-1, in+1);
      break;
    case 2738:
      gtsamSmartProjectionPose3Factor_printKeys_2738(nargout, out, nargin-1, in+1);
      break;
    case 2739:
      gtsamSmartProjectionPose3Factor_size_2739(nargout, out, nargin-1, in+1);
      break;
    case 2740:
      gtsamGenericStereoFactor3D_collectorInsertAndMakeBase_2740(nargout, out, nargin-1, in+1);
      break;
    case 2741:
      gtsamGenericStereoFactor3D_upcastFromVoid_2741(nargout, out, nargin-1, in+1);
      break;
    case 2742:
      gtsamGenericStereoFactor3D_constructor_2742(nargout, out, nargin-1, in+1);
      break;
    case 2743:
      gtsamGenericStereoFactor3D_deconstructor_2743(nargout, out, nargin-1, in+1);
      break;
    case 2744:
      gtsamGenericStereoFactor3D_active_2744(nargout, out, nargin-1, in+1);
      break;
    case 2745:
      gtsamGenericStereoFactor3D_calibration_2745(nargout, out, nargin-1, in+1);
      break;
    case 2746:
      gtsamGenericStereoFactor3D_clone_2746(nargout, out, nargin-1, in+1);
      break;
    case 2747:
      gtsamGenericStereoFactor3D_dim_2747(nargout, out, nargin-1, in+1);
      break;
    case 2748:
      gtsamGenericStereoFactor3D_equals_2748(nargout, out, nargin-1, in+1);
      break;
    case 2749:
      gtsamGenericStereoFactor3D_error_2749(nargout, out, nargin-1, in+1);
      break;
    case 2750:
      gtsamGenericStereoFactor3D_get_noiseModel_2750(nargout, out, nargin-1, in+1);
      break;
    case 2751:
      gtsamGenericStereoFactor3D_keys_2751(nargout, out, nargin-1, in+1);
      break;
    case 2752:
      gtsamGenericStereoFactor3D_linearize_2752(nargout, out, nargin-1, in+1);
      break;
    case 2753:
      gtsamGenericStereoFactor3D_measured_2753(nargout, out, nargin-1, in+1);
      break;
    case 2754:
      gtsamGenericStereoFactor3D_noiseModel_2754(nargout, out, nargin-1, in+1);
      break;
    case 2755:
      gtsamGenericStereoFactor3D_print_2755(nargout, out, nargin-1, in+1);
      break;
    case 2756:
      gtsamGenericStereoFactor3D_printKeys_2756(nargout, out, nargin-1, in+1);
      break;
    case 2757:
      gtsamGenericStereoFactor3D_size_2757(nargout, out, nargin-1, in+1);
      break;
    case 2758:
      gtsamGenericStereoFactor3D_unwhitenedError_2758(nargout, out, nargin-1, in+1);
      break;
    case 2759:
      gtsamGenericStereoFactor3D_whitenedError_2759(nargout, out, nargin-1, in+1);
      break;
    case 2760:
      gtsamGenericStereoFactor3D_string_serialize_2760(nargout, out, nargin-1, in+1);
      break;
    case 2761:
      gtsamGenericStereoFactor3D_string_deserialize_2761(nargout, out, nargin-1, in+1);
      break;
    case 2762:
      gtsamPoseTranslationPrior2D_collectorInsertAndMakeBase_2762(nargout, out, nargin-1, in+1);
      break;
    case 2763:
      gtsamPoseTranslationPrior2D_upcastFromVoid_2763(nargout, out, nargin-1, in+1);
      break;
    case 2764:
      gtsamPoseTranslationPrior2D_constructor_2764(nargout, out, nargin-1, in+1);
      break;
    case 2765:
      gtsamPoseTranslationPrior2D_deconstructor_2765(nargout, out, nargin-1, in+1);
      break;
    case 2766:
      gtsamPoseTranslationPrior2D_active_2766(nargout, out, nargin-1, in+1);
      break;
    case 2767:
      gtsamPoseTranslationPrior2D_clone_2767(nargout, out, nargin-1, in+1);
      break;
    case 2768:
      gtsamPoseTranslationPrior2D_dim_2768(nargout, out, nargin-1, in+1);
      break;
    case 2769:
      gtsamPoseTranslationPrior2D_equals_2769(nargout, out, nargin-1, in+1);
      break;
    case 2770:
      gtsamPoseTranslationPrior2D_error_2770(nargout, out, nargin-1, in+1);
      break;
    case 2771:
      gtsamPoseTranslationPrior2D_get_noiseModel_2771(nargout, out, nargin-1, in+1);
      break;
    case 2772:
      gtsamPoseTranslationPrior2D_keys_2772(nargout, out, nargin-1, in+1);
      break;
    case 2773:
      gtsamPoseTranslationPrior2D_linearize_2773(nargout, out, nargin-1, in+1);
      break;
    case 2774:
      gtsamPoseTranslationPrior2D_noiseModel_2774(nargout, out, nargin-1, in+1);
      break;
    case 2775:
      gtsamPoseTranslationPrior2D_print_2775(nargout, out, nargin-1, in+1);
      break;
    case 2776:
      gtsamPoseTranslationPrior2D_printKeys_2776(nargout, out, nargin-1, in+1);
      break;
    case 2777:
      gtsamPoseTranslationPrior2D_size_2777(nargout, out, nargin-1, in+1);
      break;
    case 2778:
      gtsamPoseTranslationPrior2D_unwhitenedError_2778(nargout, out, nargin-1, in+1);
      break;
    case 2779:
      gtsamPoseTranslationPrior2D_whitenedError_2779(nargout, out, nargin-1, in+1);
      break;
    case 2780:
      gtsamPoseTranslationPrior3D_collectorInsertAndMakeBase_2780(nargout, out, nargin-1, in+1);
      break;
    case 2781:
      gtsamPoseTranslationPrior3D_upcastFromVoid_2781(nargout, out, nargin-1, in+1);
      break;
    case 2782:
      gtsamPoseTranslationPrior3D_constructor_2782(nargout, out, nargin-1, in+1);
      break;
    case 2783:
      gtsamPoseTranslationPrior3D_deconstructor_2783(nargout, out, nargin-1, in+1);
      break;
    case 2784:
      gtsamPoseTranslationPrior3D_active_2784(nargout, out, nargin-1, in+1);
      break;
    case 2785:
      gtsamPoseTranslationPrior3D_clone_2785(nargout, out, nargin-1, in+1);
      break;
    case 2786:
      gtsamPoseTranslationPrior3D_dim_2786(nargout, out, nargin-1, in+1);
      break;
    case 2787:
      gtsamPoseTranslationPrior3D_equals_2787(nargout, out, nargin-1, in+1);
      break;
    case 2788:
      gtsamPoseTranslationPrior3D_error_2788(nargout, out, nargin-1, in+1);
      break;
    case 2789:
      gtsamPoseTranslationPrior3D_get_noiseModel_2789(nargout, out, nargin-1, in+1);
      break;
    case 2790:
      gtsamPoseTranslationPrior3D_keys_2790(nargout, out, nargin-1, in+1);
      break;
    case 2791:
      gtsamPoseTranslationPrior3D_linearize_2791(nargout, out, nargin-1, in+1);
      break;
    case 2792:
      gtsamPoseTranslationPrior3D_noiseModel_2792(nargout, out, nargin-1, in+1);
      break;
    case 2793:
      gtsamPoseTranslationPrior3D_print_2793(nargout, out, nargin-1, in+1);
      break;
    case 2794:
      gtsamPoseTranslationPrior3D_printKeys_2794(nargout, out, nargin-1, in+1);
      break;
    case 2795:
      gtsamPoseTranslationPrior3D_size_2795(nargout, out, nargin-1, in+1);
      break;
    case 2796:
      gtsamPoseTranslationPrior3D_unwhitenedError_2796(nargout, out, nargin-1, in+1);
      break;
    case 2797:
      gtsamPoseTranslationPrior3D_whitenedError_2797(nargout, out, nargin-1, in+1);
      break;
    case 2798:
      gtsamPoseRotationPrior2D_collectorInsertAndMakeBase_2798(nargout, out, nargin-1, in+1);
      break;
    case 2799:
      gtsamPoseRotationPrior2D_upcastFromVoid_2799(nargout, out, nargin-1, in+1);
      break;
    case 2800:
      gtsamPoseRotationPrior2D_constructor_2800(nargout, out, nargin-1, in+1);
      break;
    case 2801:
      gtsamPoseRotationPrior2D_deconstructor_2801(nargout, out, nargin-1, in+1);
      break;
    case 2802:
      gtsamPoseRotationPrior2D_active_2802(nargout, out, nargin-1, in+1);
      break;
    case 2803:
      gtsamPoseRotationPrior2D_clone_2803(nargout, out, nargin-1, in+1);
      break;
    case 2804:
      gtsamPoseRotationPrior2D_dim_2804(nargout, out, nargin-1, in+1);
      break;
    case 2805:
      gtsamPoseRotationPrior2D_equals_2805(nargout, out, nargin-1, in+1);
      break;
    case 2806:
      gtsamPoseRotationPrior2D_error_2806(nargout, out, nargin-1, in+1);
      break;
    case 2807:
      gtsamPoseRotationPrior2D_get_noiseModel_2807(nargout, out, nargin-1, in+1);
      break;
    case 2808:
      gtsamPoseRotationPrior2D_keys_2808(nargout, out, nargin-1, in+1);
      break;
    case 2809:
      gtsamPoseRotationPrior2D_linearize_2809(nargout, out, nargin-1, in+1);
      break;
    case 2810:
      gtsamPoseRotationPrior2D_noiseModel_2810(nargout, out, nargin-1, in+1);
      break;
    case 2811:
      gtsamPoseRotationPrior2D_print_2811(nargout, out, nargin-1, in+1);
      break;
    case 2812:
      gtsamPoseRotationPrior2D_printKeys_2812(nargout, out, nargin-1, in+1);
      break;
    case 2813:
      gtsamPoseRotationPrior2D_size_2813(nargout, out, nargin-1, in+1);
      break;
    case 2814:
      gtsamPoseRotationPrior2D_unwhitenedError_2814(nargout, out, nargin-1, in+1);
      break;
    case 2815:
      gtsamPoseRotationPrior2D_whitenedError_2815(nargout, out, nargin-1, in+1);
      break;
    case 2816:
      gtsamPoseRotationPrior3D_collectorInsertAndMakeBase_2816(nargout, out, nargin-1, in+1);
      break;
    case 2817:
      gtsamPoseRotationPrior3D_upcastFromVoid_2817(nargout, out, nargin-1, in+1);
      break;
    case 2818:
      gtsamPoseRotationPrior3D_constructor_2818(nargout, out, nargin-1, in+1);
      break;
    case 2819:
      gtsamPoseRotationPrior3D_deconstructor_2819(nargout, out, nargin-1, in+1);
      break;
    case 2820:
      gtsamPoseRotationPrior3D_active_2820(nargout, out, nargin-1, in+1);
      break;
    case 2821:
      gtsamPoseRotationPrior3D_clone_2821(nargout, out, nargin-1, in+1);
      break;
    case 2822:
      gtsamPoseRotationPrior3D_dim_2822(nargout, out, nargin-1, in+1);
      break;
    case 2823:
      gtsamPoseRotationPrior3D_equals_2823(nargout, out, nargin-1, in+1);
      break;
    case 2824:
      gtsamPoseRotationPrior3D_error_2824(nargout, out, nargin-1, in+1);
      break;
    case 2825:
      gtsamPoseRotationPrior3D_get_noiseModel_2825(nargout, out, nargin-1, in+1);
      break;
    case 2826:
      gtsamPoseRotationPrior3D_keys_2826(nargout, out, nargin-1, in+1);
      break;
    case 2827:
      gtsamPoseRotationPrior3D_linearize_2827(nargout, out, nargin-1, in+1);
      break;
    case 2828:
      gtsamPoseRotationPrior3D_noiseModel_2828(nargout, out, nargin-1, in+1);
      break;
    case 2829:
      gtsamPoseRotationPrior3D_print_2829(nargout, out, nargin-1, in+1);
      break;
    case 2830:
      gtsamPoseRotationPrior3D_printKeys_2830(nargout, out, nargin-1, in+1);
      break;
    case 2831:
      gtsamPoseRotationPrior3D_size_2831(nargout, out, nargin-1, in+1);
      break;
    case 2832:
      gtsamPoseRotationPrior3D_unwhitenedError_2832(nargout, out, nargin-1, in+1);
      break;
    case 2833:
      gtsamPoseRotationPrior3D_whitenedError_2833(nargout, out, nargin-1, in+1);
      break;
    case 2834:
      gtsamPrintKeyList_2834(nargout, out, nargin-1, in+1);
      break;
    case 2835:
      gtsamPrintKeyList_2835(nargout, out, nargin-1, in+1);
      break;
    case 2836:
      gtsamPrintKeySet_2836(nargout, out, nargin-1, in+1);
      break;
    case 2837:
      gtsamPrintKeySet_2837(nargout, out, nargin-1, in+1);
      break;
    case 2838:
      gtsamPrintKeyVector_2838(nargout, out, nargin-1, in+1);
      break;
    case 2839:
      gtsamPrintKeyVector_2839(nargout, out, nargin-1, in+1);
      break;
    case 2840:
      gtsamutilitiesallPose3s_2840(nargout, out, nargin-1, in+1);
      break;
    case 2841:
      gtsamcheckConvergence_2841(nargout, out, nargin-1, in+1);
      break;
    case 2842:
      gtsamutilitiescreateKeyList_2842(nargout, out, nargin-1, in+1);
      break;
    case 2843:
      gtsamutilitiescreateKeyList_2843(nargout, out, nargin-1, in+1);
      break;
    case 2844:
      gtsamutilitiescreateKeySet_2844(nargout, out, nargin-1, in+1);
      break;
    case 2845:
      gtsamutilitiescreateKeySet_2845(nargout, out, nargin-1, in+1);
      break;
    case 2846:
      gtsamutilitiescreateKeyVector_2846(nargout, out, nargin-1, in+1);
      break;
    case 2847:
      gtsamutilitiescreateKeyVector_2847(nargout, out, nargin-1, in+1);
      break;
    case 2848:
      gtsamutilitiesextractPoint2_2848(nargout, out, nargin-1, in+1);
      break;
    case 2849:
      gtsamutilitiesextractPoint3_2849(nargout, out, nargin-1, in+1);
      break;
    case 2850:
      gtsamutilitiesextractPose2_2850(nargout, out, nargin-1, in+1);
      break;
    case 2851:
      gtsamutilitiesextractPose3_2851(nargout, out, nargin-1, in+1);
      break;
    case 2852:
      gtsamutilitiesinsertBackprojections_2852(nargout, out, nargin-1, in+1);
      break;
    case 2853:
      gtsamutilitiesinsertProjectionFactors_2853(nargout, out, nargin-1, in+1);
      break;
    case 2854:
      gtsamutilitiesinsertProjectionFactors_2854(nargout, out, nargin-1, in+1);
      break;
    case 2855:
      gtsamlinear_independent_2855(nargout, out, nargin-1, in+1);
      break;
    case 2856:
      gtsamload2D_2856(nargout, out, nargin-1, in+1);
      break;
    case 2857:
      gtsamload2D_2857(nargout, out, nargin-1, in+1);
      break;
    case 2858:
      gtsamload2D_2858(nargout, out, nargin-1, in+1);
      break;
    case 2859:
      gtsamload2D_2859(nargout, out, nargin-1, in+1);
      break;
    case 2860:
      gtsamload2D_2860(nargout, out, nargin-1, in+1);
      break;
    case 2861:
      gtsamload2D_robust_2861(nargout, out, nargin-1, in+1);
      break;
    case 2862:
      gtsamutilitieslocalToWorld_2862(nargout, out, nargin-1, in+1);
      break;
    case 2863:
      gtsamutilitieslocalToWorld_2863(nargout, out, nargin-1, in+1);
      break;
    case 2864:
      gtsammrsymbol_2864(nargout, out, nargin-1, in+1);
      break;
    case 2865:
      gtsammrsymbolChr_2865(nargout, out, nargin-1, in+1);
      break;
    case 2866:
      gtsammrsymbolIndex_2866(nargout, out, nargin-1, in+1);
      break;
    case 2867:
      gtsammrsymbolLabel_2867(nargout, out, nargin-1, in+1);
      break;
    case 2868:
      gtsamutilitiesperturbPoint2_2868(nargout, out, nargin-1, in+1);
      break;
    case 2869:
      gtsamutilitiesperturbPoint3_2869(nargout, out, nargin-1, in+1);
      break;
    case 2870:
      gtsamutilitiesperturbPose2_2870(nargout, out, nargin-1, in+1);
      break;
    case 2871:
      gtsamreadG2o_2871(nargout, out, nargin-1, in+1);
      break;
    case 2872:
      gtsamutilitiesreprojectionErrors_2872(nargout, out, nargin-1, in+1);
      break;
    case 2873:
      gtsamsave2D_2873(nargout, out, nargin-1, in+1);
      break;
    case 2874:
      gtsamsymbol_2874(nargout, out, nargin-1, in+1);
      break;
    case 2875:
      gtsamsymbolChr_2875(nargout, out, nargin-1, in+1);
      break;
    case 2876:
      gtsamsymbolIndex_2876(nargout, out, nargin-1, in+1);
      break;
    case 2877:
      gtsamtriangulatePoint3_2877(nargout, out, nargin-1, in+1);
      break;
    case 2878:
      gtsamtriangulatePoint3_2878(nargout, out, nargin-1, in+1);
      break;
    case 2879:
      gtsamwriteG2o_2879(nargout, out, nargin-1, in+1);
      break;
    }
  } catch(const std::exception& e) {
    mexErrMsgTxt(("Exception from gtsam:\n" + std::string(e.what()) + "\n").c_str());
  }

  std::cout.rdbuf(outbuf);
}
